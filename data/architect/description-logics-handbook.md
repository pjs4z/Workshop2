THE DESCRIPTION LOGIC HANDBOOK

Theory, implementation, and applications

Edited by

FRANZ BAADER DIEGO CALVANESE DEBORAH L. McGUINNESS DANIELE NARDI PETER F. PATEL-SCHNEIDER

   Cambridge, New York, Melbourne, Madrid, Cape Town, Singapore, São Paulo

Cambridge University Press The Edinburgh Building, Cambridge  , United Kingdom

Published in the United States of America by Cambridge University Press, New York www.cambridge.org

Information on this title: www.cambridge.org/9780521781763

© Cambridge University Press 2003

This book is in copyright. Subject to statutory exception and to the provision of relevant collective licensing agreements, no reproduction of any part may take place without the written permission of Cambridge University Press.

2003

First published in print format

- -



isbn-13 978-0-511-06694-8 eBook (NetLibrary)



isbn-10 0-511-06694-5 eBook (NetLibrary)

- -



isbn-13 978-0-521-78176-3 hardback



isbn-10 0-521-78176-0 hardback

Cambridge University Press has no responsibility for the persistence or accuracy of s for external or third-party internet websites referred to in this book, and does not guarantee that any content on such websites is, or will remain, accurate or appropriate.

Contents

List of contributors page ix Preface xiii

1 An Introduction to Description Logics D. Nardi and R. J. Brachman 1 1.1 Introduction 1 1.2 From networks to Description Logics 4 1.3 Knowledge representation in Description Logics 12 1.4 From theory to practice: Description Logic systems 16 1.5 Applications developed with Description Logic systems 20 1.6 Extensions of Description Logics 30 1.7 Relationship to other ﬁelds of Computer Science 36 1.8 Conclusion 39 Part I: Theory 41 2 Basic Description Logics F. Baader and W. Nutt 43 2.1 Introduction 43 2.2 Deﬁnition of the basic formalism 46 2.3 Reasoning algorithms 74 2.4 Language extensions 90 3 Complexity of Reasoning F. M. Donini 96 3.1 Introduction 96 3.2 OR-branching: ﬁnding a model 100 3.3 AND-branching: ﬁnding a clash 107 3.4 Combining sources of complexity 114 3.5 Reasoning in the presence of axioms 116 3.6 Undecidability 122 3.7 Reasoning about individuals in ABoxes 128 3.8 Discussion 132 3.9 A list of complexity results for subsumption and satisﬁability 133

4 Relationships with other Formalisms U. Sattler, D. Calvanese, and R. Molitor 137 4.1 AI knowledge representation formalisms 137 4.2 Logical formalisms 149 4.3 Database models 161 5 Expressive Description Logics D. Calvanese and G. De Giacomo 178 5.1 Introduction 178 5.2 Correspondence between Description Logics and Propositional Dynamic Logics 179 5.3 Functional restrictions 186 5.4 Qualiﬁed number restrictions 193 5.5 Objects 197 5.6 Fixpoint constructs 201 5.7 Relations of arbitrary arity 204 5.8 Finite model reasoning 209 5.9 Undecidability results 215 6 Extensions to Description Logics F. Baader, R. K¨usters, and F. Wolter 219 6.1 Introduction 219 6.2 Language extensions 220 6.3 Non-standard inference problems 250 Part II: Implementation 263 7 From Description Logic Provers to Knowledge Representation Systems D. L. McGuinness and P. F. Patel-Schneider 265 7.1 Introduction 265 7.2 Basic access 267 7.3 Advanced application access 270 7.4 Advanced human access 274 7.5 Other technical concerns 280 7.6 Public relations concerns 280 7.7 Summary 281 8 Description Logic Systems R. M¨oller and V. Haarslev 282 8.1 New light through old windows? 282 8.2 The ﬁrst generation 283 8.3 Second generation Description Logic systems 291 8.4 The next generation: Fact, Dlp and Racer 301 8.5 Lessons learned 303 9 Implementation and Optimization Techniques I. Horrocks 306 9.1 Introduction 306 9 2 Preliminaries 308

9.3 Subsumption-testing algorithms 313 9.4 Theory versus practice 317 9.5 Optimization techniques 322 9.6 Discussion 345 Part III: Applications 347 10 Conceptual Modeling with Description Logics A. Borgida and R. J. Brachman 349 10.1 Background 349 10.2 Elementary Description Logic modeling 351 10.3 Individuals in the world 353 10.4 Concepts 355 10.5 Subconcepts 358 10.6 Modeling relationships 361 10.7 Modeling ontological aspects of relationships 363 10.8 A conceptual modeling methodology 369 10.9 The ABox: modeling speciﬁc states of the world 370 10.10 Conclusions 371 11 Software Engineering C. A. Welty 373 11.1 Introduction 373 11.2 Background 373 11.3 Lassie 374 11.4 CodeBase 379 11.5 CSIS and CBMS 380 12 Conﬁguration D. L. McGuinness 388 12.1 Introduction 388 12.2 Conﬁguration description and requirements 390 12.3 The Prose and Questar family of conﬁgurators 403 12.4 Summary 404 13 Medical Informatics A. Rector 406 13.1 Background and history 407 13.2 Example applications 410 13.3 Technical issues in medical ontologies 416 13.4 Ontological issues in medical ontologies 422 13.5 Architectures: terminology servers, views, and change management 424 13.6 Discussion: key lessons from medical ontologies 426 14 Digital Libraries and Web-Based Information Systems I. Horrocks, D. L. McGuinness, and A. C. Welty 427 14.1 Background and history 427 14 2 Enabling the semantic web: DAML 432

14.3 OIL and DAML+OIL 434 14.4 Summary 448 15 Natural Language Processing E. Franconi 450 15.1 Introduction 450 15.2 Semantic interpretation 451 15.3 Reasoning with the logical form 454 15.4 Knowledge-based natural language generation 460 16 Description Logics for Databases A. Borgida, M. Lenzerini, and R. Rosati 462 16.1 Introduction 462 16.2 Data models and Description Logics 465 16.3 Description Logics and database querying 474 16.4 Data integration 478 16.5 Conclusions 483 Appendix Description Logic Terminology F. Baader 485 A.1 Notational conventions 485 A.2 Syntax and semantics of common Description Logics 485 A.3 Additional constructors 491 A.4 A note on the naming scheme for Description Logics 494

Bibliography 496 Index 547

Contributors

Franz Baader Institut f¨ur Theoretische Informatik Fakult¨at Informatik TU Dresden 01062 Dresden, Germany baader@tcs.inf.tu-dresden.de http://wwwtcs.inf.tu-dresden.de/~baader/

Alex Borgida Department of Computer Science Rutgers University Piscataway, NJ 08855, U.S.A. borgida@cs.rutgers.edu http://www.cs.rutgers.edu/~borgida/

Ronald J. Brachman Corporation for National Research Initiatives, U.S.A. rjb@brachman.org http://www.brachman.org/ Diego Calvanese Dipartimento di Informatica e Sistemistica Universit`a di Roma “La Sapienza” Via Salaria 113, 00198 Roma, Italy calvanese@dis.uniroma1.it http://www.dis.uniroma1.it/~calvanese/ Giuseppe De Giacomo Dipartimento di Informatica e Sistemistica Universit`a di Roma “La Sapienza” Via Salaria 113, 00198 Roma, Italy degiacomo@dis.uniroma1.it http://www.dis.uniroma1.it/~degiacomo/

Francesco M. Donini Dipartimento di Elettrotecnica ed Elettronica Politecnico di Bari Via Re David 200, 70125 Bari, Italy donini@poliba.it http://dee.poliba.it/dee-web/doniniweb/donini.html

Enrico Franconi Faculty of Computer Science Free University of Bozen-Bolzano Dominikanerplatz 3, I-39100 Bozen, Italy franconi@inf.unibz.it http://www.inf.unibz.it/~franconi/

Volker Haarslev Computer Science Department Concordia University 1455 de Maisonneuve Blvd. W., Montreal, Quebec H3G IM8, Canada haarslev@cs.concordia.ca http://www.cs.concordia.ca/~faculty/haarslev/

Ian Horrocks Information Management Group Department of Computer Science University of Manchester Manchester M13 9PL, U.K. horrocks@cs.man.ac.uk http://www.cs.man.ac.uk/~horrocks/

Ralf K¨usters Institut f¨ur Informatik und Praktische Mathematik Christian-Albrechts-Universit¨at zu Kiel Olshausenstraße 40, 24098 Kiel, Germany kuesters@ti.informatik.uni-kiel.de http://www.ti.informatik.uni-kiel.de/~kuesters/

Maurizio Lenzerini Dipartimento di Informatica e Sistemistica Universit`a di Roma “La Sapienza” Via Salaria 113, 00198 Roma, Italy lenzerini@dis.uniroma1.it http://www.dis.uniroma1.it/~lenzerini/ Deborah L. McGuinness Knowledge Systems Laboratory Gates Building 2A, Stanford University Stanford, CA 94305-9020, U.S.A. dlm@ksl.stanford.edu http://ksl.stanford.edu/people/dlm/

Ralf Molitor Swiss Life IT Research and Development Group General Guisan Quai 40, CH-8002 Z¨urich, Switzerland ralf.molitor@swisslife.ch http://research.swisslife.ch/~molitor/

Ralf M¨oller Computer Science Department University of Hamburg Vogt-K¨olln-Straße 30, 22527 Hamburg, Germany moeller@informatik.uni-hamburg.de http://kogs-www.informatik.uni-hamburg.de/~moeller/

Daniele Nardi Dipartimento di Informatica e Sistemistica Universit`a di Roma “La Sapienza” Via Salaria 113, 00198 Roma, Italy nardi@dis.uniroma1.it http://www.dis.uniroma1.it/~nardi/

Werner Nutt Department of Computing and Electrical Engineering Heriot-Watt University Edinburgh, EH14 4AS, U.K. nutt@cee.hw.ac.uk http://www.cee.hw.ac.uk/~nutt/ Peter F. Patel-Schneider Bell Labs Research 600 Mountain Avenue Murray Hill, NJ 07974, U.S.A. pfps@research.bell-labs.com http://www.bell-labs.com/user/pfps/

Alan Rector Medical Informatics Group Department of Computer Science University of Manchester Manchester M13 9PL, U.K. rector@cs.man.ac.uk http://www.cs.man.ac.uk/mig/ Riccardo Rosati Dipartimento di Informatica e Sistemistica Universit`a di Roma “La Sapienza” Via Salaria 113, 00198 Roma, Italy rosati@dis.uniroma1.it http://www.dis.uniroma1.it/~rosati/

Ulrike Sattler Institut f¨ur Theoretische Informatik Fakult¨at Informatik TU Dresden 01062 Dresden, Germany sattler@tcs.inf.tu-dresden.de http://wwwtcs.inf.tu-dresden.de/~uli/ Christopher A. Welty Knowledge Structures Group IBM Watson Research Center 19 Skyline Dr., Hawthorne, NY 10532, U.S.A. weltyc@us.ibm.com Frank Wolter Institut f¨ur Informatik Universit¨at Leipzig Augustus-Platz 10–11, 04109 Leipzig, Germany wolter@informatik.uni-leipzig.de http://www.informatik.uni-leipzig.de/~wolter/

Preface

Knowledge Representation is the ﬁeld of Artiﬁcial Intelligence that focuses on the design of formalisms that are both epistemologically and computationally ad- equate for expressing knowledge about a particular domain. One of the main lines of investigation has been concerned with the principle that knowledge should be represented by characterizing classes of objects and the relationships between them The organization of the classes used to describe a domain of interest is based on a hierarchical structure, which not only provides an effective and compact represen- tation of information, but also allows the relevant reasoning tasks to be performed in a computationally effective way. The above principle drove the development of the ﬁrst frame-based systems and semantic networks in the 1970s. However, these systems were in general not for- mally deﬁned and the associated reasoning tools were strongly dependent on the implementation strategies. A fundamental step towards a logic-based characteriza- tion of required formalisms was accomplished through the work on the Kl-One system, which collected many of the ideas stemming from earlier semantic net- works and frame-based systems, and provided a logical basis for interpreting ob- jects, classes (or concepts), and relationships (or links, roles) between them. The ﬁrst goal of such a logical reconstruction was the precise characterization of the set of constructs used to build class and link expressions. The second goal was to provide reasoning procedures that are sound and complete with respect to the se- mantics. The article ‘The tractability of subsumption in Frame-Based Description Languages’ by Ron Brachman and Hector Levesque, presented at AAAI 1984, addressing the tradeoff between the expressiveness of Kl-One like languages and the computational complexity of reasoning, is usually regarded as the origin of research on Description Logics. Subsequent research came under the label terminological systems to emphasize the fact that classes and relationships were used to establish the basic terminology adopted in the modeled domain Still later the emphasis was on the set of concept

forming constructs admitted in the language, giving rise to the name concept lan- guages. Recently, attention has moved closer to the properties of the underlying logical systems, and the term Description Logics has become popular. Research on Description Logics has covered theoretical aspects, implementation of knowledge representation systems (modern frame-based systems) and the use of such systems to realize applications in several areas. This pattern of development is an example of one of the standard research methodologies, as is recognized by the Artiﬁcial Intelligence community. The key element has been the very close interaction between theory and practice. On the one hand, there are various im- plemented systems based on Description Logics, offering a palette of description formalisms with differing expressive power, and which are employed in various application domains (such as natural language processing, conﬁguration of tech- nical systems, databases). On the other hand, the formal and computational prop- erties (like decidability, complexity) of various description formalisms have been studied in detail. These investigations are usually motivated by the use of certain constructors in systems or the need for these constructors in speciﬁc applications, and the results of such investigations have strongly inﬂuenced the design of new systems. The Description Logics research community currently consists of at least 100 active researchers. In addition, other communities are now becoming interested in Description Logics, most notably the Databases community and, more recently, the Semantic Web one. After more than a decade of research on Description Log- ics there is a substantial body of work and well-established technical literature. However, there is no comprehensive presentation of the major achievements in the ﬁeld, although survey papers have been published and workshop proceedings are available. Now, since 1989 a workshop dedicated to Description Logics has been held, initially every two years but annually from 1994. At the 1997 workshop a Working Group was formed to develop a proposal for a book that would provide a system- atic introduction to Description Logics, covering all aspects of the research in the ﬁeld, namely: theory, implementation, and applications. Following the spirit that fostered this research, the Description Logic Handbook would provide a thorough introduction to Description Logics both for the more theoretically oriented reader interested in the formal study of Description Logics and for the more practically oriented reader aiming at a principled usage of knowledge representation systems based on Description Logics. Although some reﬁnements have been made to the initial proposal to embody recent developments in the ﬁeld, the ﬁnal structure of the Handbook reﬂects the original intentions. The Handbook is organized into three parts plus an initial chapter providing a general introduction to the ﬁeld

Part I addresses the theoretical work in Description Logics and includes ﬁve chapters. Chapter 2 introduces Description Logics as a formal language for repre- senting knowledge and reasoning about it. Chapter 3 addresses the computational complexity of reasoning in several Description Logics. Chapter 4 explores the re- lationship with other representation formalisms, within and outside the ﬁeld of Knowledge Representation. Chapter 5 covers extensions of the basic Description Logics introduced in Chapter 2 by very expressive constructs that require advanced reasoning techniques. Chapter 6 considers extensions of Description Logics by representation features and non-standard inference problems not available in the basic framework. Part II is concerned with the implementation of knowledge representation sys- tems based on Description Logics. Chapter 7 describes the features that need to be provided, in addition to the inference engine for a particular Description Logic, to build a knowledge representation system. Chapter 8 reviews implemented knowl- edge representation systems based on Description Logics that have played or play an important role in the ﬁeld. Chapter 9 describes the implementation of the reason- ing services which form the core of Description Logic knowledge representation systems. Part III addresses the deployment of Description Logics in the design and im- plementation of ﬁelded applications. Chapter 10 discusses the issues involved in the development of an ontology for some universe of discourse, which is to be- come a conceptual model or knowledge base represented and reasoned with using Description Logics. Chapter 11 presents applications of Description Logics in the area of software engineering. Chapter 12 introduces the problem of conﬁgura- tion and the largest and longest lived family of Description Logic-based conﬁg- urators. Chapter 13 is concerned with the use of Description logics in various kinds of applications in medical informatics—terminology, intelligent user inter- faces, decision support and semantic indexing, language technology, and systems integration. Chapter 14 reviews the applications of Description Logics in web- based information systems, and the more recent developments related to languages for the Semantic Web. Chapter 15 analyzes the uses of Description Logics for natural language processing to encode syntactic, semantic, and pragmatic ele- ments needed to drive semantic interpretation and natural language generation processes. Chapter 16 surveys the major classes of application of Description Logics and their reasoning facilities to the issues of data management, includ- ing the expression of the conceptual domain model/ontology of the data source, the integration of multiple data sources, and the formulation and evaluation of queries. The syntax and semantics for Description Logics is summarized in an Appendix, which has been used as a reference to unify the notation throughout the book

Finally, an extended, integrated bibliography is provided and, within each chapter, comprehensive guides through the relevant literature are given. The chapters are written by some of the most prominent researchers in the ﬁeld, introducing the basic technical material before taking the reader to the current state of the subject. The chapters have been reviewed in a two step process, which involved two or three reviewers for each chapter. We have relied on the work of several external reviewers, selected both within the Description Logic community, and outside the ﬁeld, to increase the readability for non experts. In addition, each chapter has been read also by authors of other chapters, to improve the overall coherence. As such, the book is conceived as a unique reference for the subject. Although not intended as a textbook, the Handbook can be used as a basis for specialized courses on Description Logics. In addition, some of the chapters can be used as teaching material in Knowledge Representation courses. The Handbook is also a comprehensive reference to the subject in more introductory courses in the ﬁeld of Artiﬁcial Intelligence. We want to acknowledge the contribution and help of several people. First of all, the authors, who have successfully accomplished the hardest task of writing the chapters, carefully addressing the reviewers’ comments as well as the issues raised by the effort in making the presentation and notation uniform. Second, we thank the reviewers for their precious work, which led to signiﬁcant improvements in the ﬁnal outcome. The external reviewers were:

Premkumar T. Devanbu, Peter L. Elkin, Jerome Euzenat, Erich Gr¨adel, Michael Gruninger, Frank van Harmelen, Jana Koehler, Diane Litman, Robert M. MacGregor, Amedeo Napoli, Hans-J¨urgen Ohlbach, Marie-Christine Rousset, Nestor Rychtyckyj, Renate Schmidt, James G. Schmolze, Roberto Sebastiani, Michael Uschold,

Moshe Y. Vardi, Grant Weddell, Robert A. Weida.

A special thank you goes also to Christopher A. Welty who, besides serving as a reviewer, also coordinated the reviewing process for some of the chapters. Third, we express our gratitude to the Description Logics community as a whole (see also the Description Logics homepage at http://dl.kr.org/) for the outstanding research achievements and for applying the pressure that enabled us to complete the Handbook. Finally, we are indebted to Cambridge University Press, and, in particular, to David Tranah, for giving us the opportunity to put the Handbook together and for the excellent support in the editing process.

The publisher has used its best endeavours to ensure that the URLs for external websites referred to in this book are correct and active at the time of going to press. However, the publisher has no responsibility for the websites and can make no guarantee that a site will remain live or that the content is or will remain appropriate.

1

An Introduction to Description Logics

DANIELE NARDI RONALD J. BRACHMAN

Abstract

This introduction presents the main motivations for the development of Description Logics (DLs) as a formalism for representing knowledge, as well as some important basic notions underlying all systems that have been created in the DL tradition. In addition, we provide the reader with an overview of the entire book and some guidelines for reading it. We ﬁrst address the relationship between Description Logics and earlier seman- tic network and frame systems, which represent the original heritage of the ﬁeld. We delve into some of the key problems encountered with the older efforts. Sub- sequently, we introduce the basic features of DL languages and related reasoning techniques. DL languages are then viewed as the core of knowledge representation systems, considering both the structure of a DL knowledge base and its associated reasoning services. The development of some implemented knowledge representation systems based on Description Logics and the ﬁrst applications built with such systems are then reviewed. Finally, we address the relationship of Description Logics to other ﬁelds of Com- puter Science. We also discuss some extensions of the basic representation language machinery; these include features proposed for incorporation in the formalism that originally arose in implemented systems, and features proposed to cope with the needs of certain application domains.

1.1 Introduction

Research in the ﬁeld of knowledge representation and reasoning is usually focused on methods for providing high-level descriptions of the world that can be effectively usedtobuildintelligentapplications Inthiscontext “intelligent”referstotheability

of a system to ﬁnd implicit consequences of its explicitly represented knowledge. Such systems are therefore characterized as knowledge-based systems. Approaches to knowledge representation developed in the 1970s – when the ﬁeld enjoyed great popularity – are sometimes divided roughly into two categories: logic- based formalisms, which evolved out of the intuition that predicate calculus could be used unambiguously to capture facts about the world; and other, non-logic-based representations. The latter were often developed by building on more cognitive notions – for example, network structures and rule-based representations derived from experiments on recall from human memory and human execution of tasks like mathematical puzzle solving. Even though such approaches were often developed for speciﬁc representational chores, the resulting formalisms were usually expected to serve in general use. In other words, the non-logical systems created from very speciﬁc lines of thinking (e.g., early production systems) evolved to be treated as general-purpose tools, expected to be applicable in different domains and to different types of problems. On the other hand, since ﬁrst-order logic provides very powerful and general ma- chinery, logic-based approaches were more general-purpose from the very start. In a logic-based approach, the representation language is usually a variant of ﬁrst-order predicate calculus, and reasoning amounts to verifying logical consequence. In the non-logical approaches, often based on the use of graphical interfaces, knowledge is represented by means of some ad hoc data structures, and reasoning is accomplished by similarly ad hoc procedures that manipulate the structures. Among these spe- cialized representations we ﬁnd semantic networks and frames. Semantic networks were developed after the work of Quillian [1967], with the goal of characterizing by means of network-shaped cognitive structures the knowledge and the reasoning of the system. Similar goals were shared by later frame systems [Minsky, 1981], which rely on the notion of a “frame” as a prototype and on the capability of expressing relationships between frames. Although there are signiﬁcant differences between semantic networks and frames, both in their motivating cognitive intuitions and in their features, they have a strong common basis. In fact, they can both be regarded as network structures, where the structure of the network aims at representing sets of individuals and their relationships. Consequently, we use the term network-based structures to refer to the representation networks underlying semantic networks and frames (see [Lehmann, 1992] for a collection of papers concerning various families of network-based structures). Owing to their more human-centered origins, the network-based systems were often considered more appealing and more effective from a practical viewpoint than the logical systems. Unfortunately, they were not fully satisfactory, because of their usual lack of precise semantic characterization. The end result of this was that every system behaved differently from the others in many cases despite

virtually identical-looking components and even identical relationship names. The question then arose as to how to provide semantics to representation structures, in particular to semantic networks and frames, which carried the intuition that, by exploiting the notion of hierarchical structure, one could gain both in terms of ease of representation and in terms of the efﬁciency of reasoning. One important step in this direction was the recognition that frames (at least their core features) could be given a semantics by relying on ﬁrst-order logic [Hayes, 1979]. The basic elements of the representation are characterized as unary pred- icates, denoting sets of individuals, and binary predicates, denoting relationships between individuals. However, such a characterization does not capture the con- straints of semantic networks and frames with respect to logic. Indeed, although logic is the natural basis for specifying a meaning for these structures, it turns out that frames and semantic networks (for the most part) did not require all the ma- chinery of ﬁrst-order logic, but could be regarded as fragments of it [Brachman and Levesque, 1985]. In addition, different features of the representation language would lead to different fragments of ﬁrst-order logic. The most important conse- quence of this fact is the recognition that the typical forms of reasoning used in structure-based representations could be accomplished by specialized reasoning techniques, without necessarily requiring ﬁrst-order logic theorem provers. More- over, reasoning in different fragments of ﬁrst-order logic leads to computational problems of differing complexity. Subsequent to this realization, research in the area of Description Logics began under the label terminological systems, to emphasize that the representation lan- guage was used to establish the basic terminology adopted in the modeled domain. Later, the emphasis was on the set of concept-forming constructs admitted in the language, giving rise to the name concept languages. In more recent years, after at- tention was further moved towards the properties of the underlying logical systems, the term Description Logics became popular. In this book we mainly use the term “Description Logics” for the representation systems, but often use the word “concept” to refer to the expressions of a DL language, denoting sets of individuals, and the word “terminology” to denote a (hierarchical) structure built to provide an intensional representation of the domain of interest. Research on Description Logics has covered theoretical underpinnings as well as implementation of knowledge representation systems and the development of ap- plications in several areas. This kind of development has been quite successful. The key element has been the methodology of research, based on a very close interaction between theory and practice. On the one hand, there are various implemented sys- tems based on Description Logics, which offer a palette of description formalisms with differing expressive power and which are employed in various application

domains (such as natural language processing, conﬁguration of technical products, or databases). On the other hand, the formal and computational properties of rea- soning (like decidability and complexity) of various description formalisms have been investigated in detail. The investigations are usually motivated by the use of certain constructors in implemented systems or by the need for these construc- tors in speciﬁc applications – and the results have inﬂuenced the design of new systems. This book is meant to provide a thorough introduction to Description Logics, covering all the above-mentioned aspects of DL research – namely theory, imple- mentation, and applications. Consequently, the book is divided into three parts:

r Part I introduces the theoretical foundations of Description Logics, addressing some of the most recent developments in theoretical research in the area; r Part II focuses on the implementation of knowledge representation systems based on Description Logics, describing the basic functionality of a DL system, surveying the most inﬂuential knowledge representation systems based on Description Logics, and addressing specialized implementation techniques; r Part III addresses the use of Description Logics and of DL-based systems in the design of several applications of practical interest.

In the remainder of this introductory chapter, we review the main steps in the development of Description Logics, and introduce the main issues that are dealt with later in the book, providing pointers for its reading. In particular, in the next section we address the origins of Description Logics and then we review knowledge representation systems based on Description Logics, the main applications devel- oped with Description Logics, the main extensions to the basic DL framework, and relationships with other ﬁelds of Computer Science.

1.2 From networks to Description Logics

Inthissectionwebeginbyrecallingapproachestorepresentingknowledgethatwere developed before research on Description Logics began (i.e., semantic networks and frames). We then provide a very brief introduction to the basic elements of these approaches, based on Tarski-style semantics. Finally, we discuss the importance of computational analyses of the reasoning methods developed for Description Logics, a major ingredient of research in this ﬁeld.

1.2.1 Network-based representation structures

In order to provide some intuition about the ideas behind representations of knowl- edge in network form, we here speak in terms of a generic network, avoiding references to any particular system The elements of a network are nodes and links

v/r hasChild

Person

(1,NIL)

Female

Parent

Woman

Mother

Fig. 1.1. An example network.

Typically, nodes are used to characterize concepts, i.e., sets or classes of individ- ual objects, and links are used to characterize relationships among them. In some cases, more complex relationships are themselves represented as nodes; these are carefully distinguished from nodes representing concepts. In addition, concepts can have simple properties, often called attributes, which are typically attached to the corresponding nodes. Finally, in many of the early networks both individual objects and concepts were represented by nodes. Here, however, we restrict our attention to knowledge about concepts and their relationships, deferring for now treatment of knowledge about speciﬁc individuals. Let us consider a simple example, whose pictorial representation is given in Figure 1.1, which represents knowledge concerning persons, parents, children, etc. The structure in the ﬁgure is also referred to as a terminology, and it is indeed meant to represent the generality or speciﬁcity of the concepts involved. For example the link between Mother and Parent says that “mothers are parents”; this is sometimes called an “IS-A” relationship. The IS-A relationship deﬁnes a hierarchy over the concepts and provides the basis for the “inheritance of properties”: when a concept is more speciﬁc than some other concept, it inherits the properties of the more general one. For example, if a person has an age, then a woman has an age, too. This is the typical setting of the so-called (monotonic) inheritance networks (see [Brachman, 1979]). A characteristic feature of Description Logics is their ability to represent other kinds of relationships that can hold between concepts, beyond IS-A relationships. For example, in Figure 1.1, which follows the notation of [Brachman and Schmolze, 1985], the concept of Parent has a property that is usually called a “role”, expressed by a link from the concept to a node for the role labeled hasChild. The role has what is called a “value restriction” denoted by the label v/r which expresses a limitation

on the range of types of objects that can ﬁll that role. In addition, the node has a number restriction expressed as (1,NIL), where the ﬁrst number is a lower bound on the number of children and the second element is the upper bound, and NIL denotes inﬁnity. Overall, the representation of the concept of Parent here can be read as “A parent is a person having at least one child, and all of his/her children are persons.” Relationships of this kind are inherited from concepts to their subconcepts. For example, the concept Mother, i.e., a female parent, is a more speciﬁc descendant of both the concepts Female and Parent, and as a result inherits from Parent the link to Person through the role hasChild; in other words, Mother inherits the restriction on its hasChild role from Parent. Observe that there may be implicit relationships between concepts. For example, if we deﬁne Woman as the concept of a female person, it is the case that every Mother is a Woman. It is the task of the knowledge representation system to ﬁnd implicit relationships such as these (many are more complex than this one). Typically, such inferences have been characterized in terms of properties of the network. In this case one might observe that both Mother and Woman are connected to both Female and Person, but the path from Mother to Person includes a node Parent, which is more speciﬁc then Person, thus enabling us to conclude that Mother is more speciﬁc than Person. However, the more complex the relationships established among concepts, the more difﬁcult it becomes to give a precise characterization of what kind of rela- tionships can be computed, and how this can be done without failing to recognize some of the relationships or without providing wrong answers.

1.2.2 A logical account of network-based representation structures

Building on the above ideas, a number of systems were implemented and used in many kinds of applications. As a result, the need emerged for a precise characteri- zation of the meaning of the structures used in the representations and of the set of inferences that could be drawn from those structures. A precise characterization of the meaning of a network can be given by deﬁning a language for the elements of the structure and by providing an interpretation for the strings of that language. While the syntax may have different ﬂavors in different settings, the semantics is typically given as a Tarski-style semantics. For the syntax we introduce a kind of abstract language, which resembles other logical formalisms. The basic step of the construction is provided by two disjoint alphabets of symbols that are used to denote atomic concepts, designated by unary predicate symbols, and atomic roles, designated by binary predicate symbols; the latter are used to express relationships between concepts

Terms are then built from the basic symbols using several kinds of constructors. For example, intersection of concepts, which is denoted C ⊓D, is used to restrict the set of individuals under consideration to those that belong to both C and D. Notice that, in the syntax of Description Logics, concept expressions are variable- free. In fact, a concept expression denotes the set of all individuals satisfying the properties speciﬁed in the expression. Therefore, C ⊓D can be regarded as the ﬁrst- order logic sentence, C(x) ∧D(x), where the variable ranges over all individuals in the interpretation domain and C(x) is true for those individuals that belong to the concept C. In this book, we will present other syntactic notations that are more closely related to the concrete syntax adopted by implemented DL systems, and which are more suitable for the development of applications. One example of concrete syntax proposed in [Patel-Schneider and Swartout, 1993] is based on a Lisp-like notation, where the concept of female persons, for example, is denoted by (and Person Female). The key characteristic features of Description Logics reside in the constructs for establishing relationships between concepts. The basic ones are value restrictions. For example, a value restriction, written ∀R.C, requires that all the individuals that are in the relationship R with the concept being described belong to the concept C (technically, it is all individuals that are in the relationship R with an individual described by the concept in question that are themselves describable as C’s). As for the semantics, concepts are given a set-theoretic interpretation: a concept is interpreted as a set of individuals, and roles are interpreted as sets of pairs of individuals. The domain of interpretation can be chosen arbitrarily, and it can be inﬁnite. The non-ﬁniteness of the domain and the open-world assumption are dis- tinguishing features of Description Logics with respect to the modeling languages developed in the study of databases (see Chapters 4 and 16). Atomic concepts are thus interpreted as subsets of the intepretation domain, while the semantics of the other constructs is then speciﬁed by deﬁning the set of individuals denoted by each construct. For example, the concept C ⊓D is the set of individuals obtained by intersecting the sets of individuals denoted by C and D, respectively. Similarly, the interpretation of ∀R.C is the set of individuals that are in the relationship R with individuals belonging to the set denoted by the concept C. As an example, let us suppose that Female, Person, and Woman are atomic concepts and that hasChild and hasFemaleRelative are atomic roles. Using the operators intersection, union and complement of concepts, interpreted as set opera- tions, we can describe the concept of “persons that are not female” and the concept of “individuals that are female or male” by the expressions

Person ⊓ Female and Female ⊔Male

It is worth mentioning that intersection, union, and complement of concepts have been also referred to as concept conjunction, concept disjunction and concept nega- tion, respectively, to emphasize the relationship to logic. Let us now turn our attention to role restrictions by looking ﬁrst at quantiﬁed role restrictions and, subsequently, at what we call “number restrictions”. Most languages provide (full) existential quantiﬁcation and value restriction that allow one to describe, for example, the concept of “individuals having a female child” as ∃hasChild.Female, and to describe the concept of “individuals all of whose children are female” by the concept expression ∀hasChild.Female. In order to distinguish the function of each concept in the relationship, the individual object that corresponds to the second argument of the role viewed as a binary predicate is called a role ﬁller. In the above expressions, which describe the properties of parents having female children, individual objects belonging to the concept Female are the ﬁllers of the role hasChild. Existential quantiﬁcation and value restrictions are thus meant to characterize relationships between concepts. In fact, the role link between Parent and Person in Figure 1.1 can be expressed by the concept expression

∃hasChild.Person ⊓∀hasChild.Person.

Such an expression therefore characterizes the concept of Parent as the set of individuals having at least one ﬁller of the role hasChild belonging to the concept Person; moreover, every ﬁller of the role hasChild must be a person. Finally, notice that in quantiﬁed role restrictions the variable being quantiﬁed is not explicitly mentioned. The corresponding sentence in ﬁrst-order logic is ∀y.R(x, y) ⊃C(y), where x is again a free variable ranging over the interpretation domain. Another important kind of role restriction is given by number restrictions, which restrict the cardinality of the sets of role ﬁllers. For instance, the concept

(⩾3 hasChild) ⊓(⩽2 hasFemaleRelative)

represents the concept of “individuals having at least three children and at most two female relatives”. Number restrictions are sometimes viewed as a distinguishing feature of Description Logics, although one can ﬁnd some similar constructs in some database modeling languages (notably Entity–Relationship models). Beyond the constructs to form concept expressions, Description Logics provide constructs for roles, which can, for example, establish role hierarchies. However, the use of role expressions is generally limited to expressing relationships between concepts. Intersection of roles is an example of a role-forming construct. Intuitively, hasChild ⊓hasFemaleRelative yields the role “has daughter” so that the concept

expression

Woman ⊓⩽2 (hasChild ⊓hasFemaleRelative)

denotes the concept of “a woman having at most 2 daughters”. A more comprehensive view of the basic deﬁnitions of DL languages will be given in Chapter 2.

1.2.3 Reasoning

The basic inference on concept expressions in Description Logics is subsumption, typically written as C ⊑D. Determining subsumption is the problem of checking whether the concept denoted by D (the subsumer) is considered more general than the one denoted by C (the subsumee). In other words, subsumption checks whether the ﬁrst concept always denotes a subset of the set denoted by the second one. For example, one might be interested in knowing whether Woman ⊑Mother. In order to verify this kind of relationship one has in general to take into account the relationships deﬁned in the terminology. As we explain in the next section, under appropriate restrictions, one can embody such knowledge directly in concept expressions, thus making subsumption over concept expressions the basic reason- ing task. Another typical inference on concept expressions is concept satisﬁability, which is the problem of checking whether a concept expression does not neces- sarily denote the empty concept. In fact, concept satisﬁability is a special case of subsumption, with the subsumer being the empty concept, meaning that a concept is not satisﬁable. Although the meaning of concepts had already been speciﬁed with a logical semantics, the design of inference procedures in Description Logics was inﬂuenced for a long time by the tradition of semantic networks, where concepts were viewed as nodes and roles as links in a network. Subsumption between concept expressions was recognized as the key inference and the basic idea of the earliest subsumption algorithms was to transform two input concepts into labeled graphs and test whether one could be embedded into the other; the embedded graph would correspond to the more general concept (the subsumer) [Lipkis, 1982]. This method is called structural comparison, and the relation between concepts being computed is called structural subsumption. However, a careful analysis of the algorithms for structural subsumption shows that they are sound, but not always complete in terms of the logical semantics: whenever they return “yes” the answer is correct, but when they report “no” the answer may be incorrect. In other words, structural subsumption is in general weaker than logical subsumption. The need for complete subsumption algorithms is motivated by the fact that in the usage of knowledge representation systems it is often necessary to have a

guarantee that the system has not failed in verifying subsumption. Consequently, new algorithms for computing subsumption have been devised that are no longer based on a network representation, and these can be proven to be complete. Such algorithms have been developed by specializing classical settings for deductive reasoning to the DL subsets of ﬁrst-order logics, as done for tableau calculi by Schmidt-Schauß and Smolka [1991], and also by more specialized methods. In the paper “The tractability of subsumption in frame-based description lan- guages”, Brachman and Levesque [1984] argued that there is a tradeoff between the expressiveness of a representation language and the difﬁculty of reasoning over the representations built using that language. In other words, the more expres- sive the language, the harder the reasoning. They also provided a ﬁrst example of this tradeoff by analyzing the language FL−(Frame Language), which included intersection of concepts, value restrictions and a simple form of existential quan- tiﬁcation. They showed that for such a language the subsumption problem could be solved in polynomial time, while adding a construct called role restriction to the language makes subsumption a conp-hard problem (the extended language was called FL). The paper by Brachman and Levesque introduced at least two new ideas:

(i) “efﬁciency of reasoning” over knowledge structures can be studied using the tools of computational complexity theory; (ii) different combinations of constructs can give rise to languages with different compu- tational properties.

An immediate consequence of the above observations is that one can study formally and methodically the tradeoff between the computational complexity of reasoning and the expressiveness of the language, which itself is deﬁned in terms of the constructs that are admitted in the language. After the initial paper, a number of results on this tradeoff for concept languages were obtained (see Chapters 2 and 3), and these results allow us to draw a fairly complete picture of the complexity of reasoning for a wide class of concept languages. Moreover, the problem of ﬁnding the optimal tradeoff, namely the most expressive extensions of FL−with respect to a given set of constructs that still keep subsumption polynomial, has been studied extensively [Donini et al., 1991b; 1999]. One of the assumptions underlying this line of research is to use worst-case complexity as a measure of the efﬁciency of reasoning in Description Logics (and more generally in knowledge representation formalisms). Such an assumption has sometimes been criticized (see for example [Doyle and Patil, 1991]) as not ad- equately characterizing system performance or accounting for more average-case behavior. While this observation suggests that computational complexity alone may not be sufﬁcient for addressing performance issues research on the computational

complexity of reasoning in Description Logics has most deﬁnitely led to a much deeper understanding of the problems arising in implementing reasoning tools. Let us brieﬂy address some of the contributions of this body of work. First of all, the study of the computational complexity of reasoning in Description Logics has led to a clear understanding of the properties of the language constructs and their interaction. This is not only valuable from a theoretical viewpoint, but gives insight to the designer of deduction procedures, with clear indications of the language constructs and their combinations that are difﬁcult to deal with, as well as general methods to cope with them. Secondly, the complexity results have been obtained by exploiting a general tech- nique for satisﬁability checking in concept languages, which relies on a form of tableau calculus [Schmidt-Schauß and Smolka, 1991]. Such a technique has proved extremely useful for studying both the correctness and the complexity of the algo- rithms. More speciﬁcally, it provides an algorithmic framework that is parametric with respect to the language constructs. The algorithms for concept satisﬁability and subsumption obtained in this way have also led directly to practical implemen- tations by application of clever control strategies and optimization techniques. The most recent knowledge representation systems based on Description Logics adopt tableau calculi [Horrocks, 1998b]. Thirdly, the analysis of pathological cases in this formal framework has led to the discovery of incompleteness in the algorithms developed for implemented systems. This has also consequently proven useful in the deﬁnition of suitable test sets for verifying implementations. For example, the comparison of implemented systems (see for example [Baader et al., 1992b; Heinsohn et al., 1992]) has greatly beneﬁtted from the results of the complexity analysis. The basic reasoning techniques for Description Logics are presented in Chapter 2, while a detailed analysis of the complexity of reasoning problems in several languages is developed in Chapter 3. After the tradeoff between expressiveness and tractability of reasoning was thor- oughly analyzed and the range of applicability of the corresponding inference tech- niques had been experimented with, there was a shift of focus in the theoretical research on reasoning in Description Logics. Interest grew in relating Description Logics to the modeling languages used in database management. In addition, the discovery of strict relationships with expressive modal logics stimulated the study of so-called very expressive Description Logics. These languages, besides admit- ting very general mechanisms for deﬁning concepts (for example cyclic deﬁnitions, addressed in the next section), provide a richer set of concept-forming constructs and constructs for forming complex role expressions. For these languages, the ex- pressiveness is great enough that the new challenge became enriching the language while retaining the decidability of reasoning It is worth pointing out that this new

direction of theoretical research was accompanied by a corresponding shift in the implementation of knowledge representation systems based on very expressive DL languages. The study of reasoning methods for very expressive Description Logics is addressed in Chapter 5.

1.3 Knowledge representation in Description Logics

In the previous section a basic representation language for Description Logics was introduced along with some key associated reasoning techniques. Our goal now is to illustrate how Description Logics can be useful in the design of knowledge-based applications, that is to say, how a DL language is used in a knowledge representation system that provides a language for deﬁning a knowledge base and tools to carry out inferences over it. The realization of knowledge systems involves two primary aspects. The ﬁrst consists in providing a precise characterization of a knowledge base; this involves precisely characterizing the type of knowledge to be speciﬁed to the system as well as clearly deﬁning the reasoning services the system needs to provide – the kind of questions that the system should be able to answer. The second aspect consists in providing a rich development environment where users can beneﬁt from different services that can make their interaction with the system more effective. In this section we address the logical structure of the knowledge base, while the design of systems and tools for the development of applications is addressed in the next section. One of the products of some important historical efforts to provide precise char- acterizations of the behavior of semantic networks and frames was a functional approach to knowledge representation [Levesque, 1984]. The idea was to give a precise speciﬁcation of the functionality to be provided by a knowledge base and, speciﬁcally, of the inferences performed by the knowledge base – independent of any implementation. In practice, the functional description of a reasoning system is productively speciﬁed through a so-called “Tell&Ask” interface. Such an inter- face speciﬁes operations that enable knowledge base construction (Tell operations) and operations that allow one to get information out of the knowledge base (Ask operations). In the following we shall adopt this view for characterizing both the deﬁnition of a DL knowledge base and the deductive services it provides. Within a knowledge base one can see a clear distinction between intensional knowledge, or general knowledge about the problem domain, and extensional knowledge, which is speciﬁc to a particular problem. A typical DL knowledge base analogously comprises two components – a TBox and an ABox. The TBox con- tains intensional knowledge in the form of a terminology (hence the term “TBox”, but “taxonomy” could be used as well) and is built through declarations that de- scribe general properties of concepts Because of the nature of the subsumption

relationships among the concepts that constitute the terminology, TBoxes are usu- ally thought of as having a lattice-like structure; this mathematical structure is entailed by the subsumption relationship – it has nothing to do with any imple- mentation. The ABox contains extensional knowledge – also called assertional knowledge (hence the term “ABox”) – knowledge that is speciﬁc to the individuals of the domain of discourse. Intensional knowledge is usually thought not to change – to be “timeless”, in a way – and extensional knowledge is usually thought to be contingent, or dependent on a single set of circumstances, and therefore subject to occasional or even constant change. In the rest of the section we present a basic Tell&Ask interface by analyzing the TBox and the ABox of a DL knowledge base.

1.3.1 The TBox

One key element of a DL knowledge base is given by the operations used to build the terminology. Such operations are directly related to the forms and the meaning of the declarations allowed in the TBox. The basic form of declaration in a TBox is a concept deﬁnition, that is, the deﬁnition of a new concept in terms of other previously deﬁned concepts. For example, a woman can be deﬁned as a female person by writing this declaration:

Woman ≡Person ⊓Female.

Such a declaration is usually interpreted as a logical equivalence, which amounts to providing both sufﬁcient and necessary conditions for classifying an individ- ual as a woman. This form of deﬁnition is much stronger than the ones used in other kinds of representations of knowledge, which typically impose only nec- essary conditions; the strength of this kind of declaration is usually considered a characteristic feature of DL knowledge bases. In DL knowledge bases, there- fore, a terminology is constituted by a set of concept deﬁnitions of the above form. However, there are some important common assumptions usually made about DL terminologies:

r Only one deﬁnition for a concept name is allowed. r Deﬁnitions are acyclic in the sense that concepts are neither deﬁned in terms of themselves nor in terms of other concepts that indirectly refer to them.

This kind of restriction is common to many DL knowledge bases and implies that every deﬁned concept can be expanded in a unique way into a complex expression containing only atomic concepts by replacing every deﬁned concept with the right- hand side of its deﬁnition

Nebel [1990b] showed that even simple expansion of deﬁnitions like this gives rise to an unavoidable source of complexity; in practice, however, deﬁnitions that inordinately increase the complexity of reasoning do not seem to occur. Under these assumptions the computational complexity of inferences can be studied by abstracting from the terminology and by considering all given concepts as fully expanded expressions. Therefore, much of the study of reasoning methods in Description Logics has been focused on concept expressions and, more speciﬁcally, as discussed in the previous section, on subsumption, which can be considered the basic reasoning service for the TBox. In particular, the basic task in constructing a terminology is classiﬁcation, which amounts to placing a new concept expression in the proper place in a taxonomic hier- archy of concepts. Classiﬁcation can be accomplished by verifying the subsumption relation between each deﬁned concept in the hierarchy and the new concept expres- sion. The placement of the concept will be in between the most speciﬁc concepts that subsume the new concept and the most general concepts that the new concept subsumes. More general settings for concept deﬁnitions have recently received some atten- tion, deriving from attempts to establish formal relationships between Description Logics and other formalisms and from attempts to satisfy a need for increased ex- pressive power. In particular, the admission of cyclic deﬁnitions has led to different semantic interpretations of the declarations, known as greatest/least ﬁxed-point, and descriptive semantics. Although it has been argued that different semantics may be adopted depending on the target application, the more commonly adopted one is descriptive semantics, which simply requires that all the declarations be satisﬁed in the interpretation. Moreover, by dropping the requirement that on the left-hand side of a deﬁnition there can only be an atomic concept name, one can consider so-called (general) inclusion axioms of the form

C ⊑D

where C and D are arbitrary concept expressions. Notice that a concept deﬁnition can be expressed by two general inclusions. As a result of several theoretical stud- ies concerning both the decidability of and implementation techniques for cyclic TBoxes, the most recent DL systems admit rather powerful constructs for deﬁning concepts. The basic deduction service for such TBoxes can be viewed as logical implication and it amounts to verifying whether a generic relationship (for example a subsump- tion relationship between two concept expressions) is a logical consequence of the declarations in the TBox. The issues arising in the semantic characterization of cyclic TBoxes are dealt with in Chapter 2, while techniques for reasoning in

cyclic TBoxes are addressed in Chapter 2 and in Chapter 5, where very expressive Description Logics are presented.

1.3.2 The ABox

The ABox contains extensional knowledge about the domain of interest, that is, assertions about individuals, usually called membership assertions. For example,

Female ⊓Person(ANNA)

states that the individual ANNA is a female person. Given the above deﬁnition of woman, one can derive from this assertion that ANNA is an instance of the concept Woman. Similarly,

hasChild(ANNA, JACOPO)

speciﬁes that ANNA has JACOPO as a child. Assertions of the ﬁrst kind are also called concept assertions, while assertions of the second kind are also called role assertions. As illustrated by these examples, in the ABox one can typically specify knowl- edge in the form of concept assertions and role assertions. In concept assertions general concept expressions are typically allowed, while role assertions, where the role is not a primitive role but a role expression, are typically not allowed, being treated in the case of very expressive languages only. The basic reasoning task in an ABox is instance checking, which veriﬁes whether a given individual is an instance of (belongs to) a speciﬁed concept. Although other reasoning services are usually considered and employed, they can be deﬁned in terms of instance checking. Among them we ﬁnd knowledge base consistency, which amounts to verifying whether every concept in the knowledge base admits at least one individual; realization, which ﬁnds the most speciﬁc concept an individual object is an instance of; and retrieval, which ﬁnds the individuals in the knowledge base that are instances of a given concept. These can all be accomplished by means of instance checking. The presence of individuals in a knowledge base makes reasoning more complex from a computational viewpoint [Donini et al., 1994b], and may require signiﬁcant extensions of some TBox reasoning techniques. Reasoning in the ABox is addressed in Chapter 3. It is worth emphasizing that, although we have separated out for convenience the services for the ABox, when the TBox cannot be dealt with by means of the simple substitution mechanism used for acyclic TBoxes, the reasoning services may have to take into account all of the knowledge base including both the TBox and the

ABox, and the corresponding reasoning problems become more complex. A full setting including general TBox and ABox is addressed in Chapter 5, where very expressive Description Logics are discussed. More general languages for deﬁning ABoxes have also been considered. Knowl- edgerepresentationsystemsprovidingapowerfullogicallanguagefortheABoxand a DL language for the TBox are often considered hybrid reasoning systems, since completely different knowledge representation languages may be used to specify the knowledge in the different components. Hybrid reasoning systems were popular in the 1980s (see for example [Brachman et al., 1985]); lately, the topic has regained attention [Levy and Rousset, 1997; Donini et al., 1998b], focusing on knowledge bases with a DL component for concept deﬁnitions and a logic-programming com- ponent for assertions about individuals. Sound and complete inference methods for hybrid knowledge bases become difﬁcult to devise whenever there is a strict interaction between the knowledge components.

1.4 From theory to practice: Description Logic systems

A direct practical result of research on knowledge representation has been the devel- opment of tools for the construction of knowledge-based applications. As already noted, research on Description Logics has been characterized by a tight connection between theoretical results and implementation of systems. This has been achieved by maintaining a very close relationship between theoreticians, system implemen- tors and users of knowledge representation systems based on Description Logics (DL-KRSs). The results of work on reasoning algorithms and their complexity have inﬂuenced the design of systems, and research on reasoning algorithms has itself been focused by a careful analysis of the capabilities and the limitations of imple- mented systems. In this section we ﬁrst sketch the functionality of some knowledge representation systems and, subsequently, discuss the evolution of DL-KRSs. The reader can ﬁnd a deeper treatment of the ﬁrst topic in Chapter 7, while a survey of knowledge representation systems based on Description Logics is provided in Chapter 8. Chapter 9 is devoted to more specialized implementation and optimiza- tion techniques.

1.4.1 The design of knowledge representation systems based on Description Logics

In order to appreciate the difﬁculties of implementing and maintaining a knowledge representation system, it is necessary to consider that in the usage of a knowledge representation system, the reasoning service is really only one aspect of a complex system one which may even be hidden from the ﬁnal user The user before getting

to “push the reasoning button”, has to model the domain of interest, and input knowledge into the system. Further, in many cases, a simple yes/no answer is of little use, so a simplistic implementation of the Tell&Ask paradigm may be inadequate. As a consequence, the path one follows to get from the identiﬁcation of a suitable knowledge representation system to the design of applications based on it is a complex and demanding one (see for example [Brachman, 1992]). In the case of Description Logics, this is especially true if the goal is to devise a system to be used by users who are not DL experts and who need to obtain a working system as quickly as possible. In the 1980s, when frame-based systems (such as, for example, Kee [Fikes and Kehler, 1985]; see [Karp, 1992] for an overview) had reached the strength of commercial products, the burden on a user of moving to the more modern DL-KRSs had to be kept small. Consequently, a stream of research addressed important aspects of the pragmatic usability of DL systems. This issue was especially relevant for those systems aiming at limiting the expressiveness of the language, but providing the user with sound, complete and efﬁcient reasoning services. The issue of embedding a DL language within an environment suitable for application development is further addressed in Chapter 7. In recent years, we might add, useful DL systems have often come as internal components of larger environments whose interfaces could completely hide the DL language and its core reasoning services. Systems like Imacs [Brachman et al., 1993] and Prose [Wright et al., 1993] were quite successful in classifying data and conﬁguring products, respectively, without the need for any user to understand the details of the DL representation language (Classic) they were built upon. Nowadays, applications for gathering information from the World Wide Web, where the interface can be speciﬁcally designed to support the retrieval of such information, also hide the knowledge representation and reasoning component. In addition, some data modeling tools, where the system provides a more conventional interface, can provide additional facilities based on the capability of reasoning about models with a DL inference engine. The possible settings for taking advantage of Description Logics as components of larger systems are discussed in Part III; more speciﬁcally, Chapter 14 presents Web applications and Chapter 15 natural language applications, while the reasoning capabilities of Description Logics in database applications are addressed in Chapter 16.

1.4.2 Knowledge representation systems based on Description Logics

The history of knowledge representation is covered in the literature in numerous ways (see for example [Woods and Schmolze, 1992; Rich, 1991; Baader et al., 1992b]). Here we identify three generations of systems, highlighting their histori- cal evolution rather than their speciﬁc functionality We shall characterize them as

Pre-DL systems, DL systems and Current Generation DL systems. Detailed refer- ences to implemented systems are given in Chapter 8.

1.4.2.1 Pre-Description Logic systems

The ancestor of DL systems is Kl-One [Brachman and Schmolze, 1985], which signaled the transition from semantic networks to more well-founded terminologi- cal (description) logics. The inﬂuence of Kl-One was profound and it is considered the root of the entire family of languages [Woods and Schmolze, 1990]. Semantic networks were introduced around 1966 as a representation for the concepts underlying English words, and became a popular type of framework for representing a wide variety of concepts in AI applications. Important and common- sensical ideas evolved in this work, from named nodes and links for representing concepts and relationships, to hierarchical networks with inheritance of properties, to the notion of “instantiation” of a concept by an individual object. But semantic network systems were fraught with problems, including vagueness and inconsis- tency in the meaning of various constructs, and the lack of a level of structure on which to base application-independent inference procedures. In his PhD thesis [Brachman, 1977a] and subsequent work (e.g., see [Brachman, 1979]), Brachman addressed representation at what he called an “epistemological”, or knowledge- structuring level. This led to a set of primitives for structuring knowledge that was less application- and world-knowledge-dependent than “semantic” representations (like those for processing natural language case structures), yet richer than the im- poverished set of primitives available in strictly logical languages. The main result of this work was a new knowledge representation framework whose primitive el- ements allowed cleaner, more application-independent representations than prior network formalisms. In the late 1970s, Brachman and his colleagues explored the utility and implications of this kind of framework in the Kl-One system. Kl-One introduced most of the key notions explored in the extensive work on Description Logics that followed. These included, for example, the notions of con- cepts and roles and how they were to be interrelated; the important ideas of “value restriction” and “number restriction”, which modiﬁed the use of roles in the deﬁ- nitions of concepts; and the crucial inferences of subsumption and classiﬁcation. It also sowed the seeds for the later distinction between the TBox and ABox and a host of other signiﬁcant notions that greatly inﬂuenced subsequent work. Kl-One also was the initial example of the substantial interplay between theory and practice that characterizes the history of Description Logics. It was inﬂuenced by work in logic and philosophy (and in turn itself inﬂuenced work in philosophy and psychology), and signiﬁcant care was taken in its design to allow it to be consistent and seman- tically sound. But it was also used in multiple applications, covering intelligent information presentation and natural language understanding among other things

Most of the focus of the original work on Kl-One was on the representation of and reasoning with concepts, with only a small amount of attention paid to reasoning with individual objects. The ﬁrst descendants of Kl-One were focused on architec- tures providing a clear distinction between a powerful logic-based (or rule-based) component and a specialized terminological component. These systems came to be referred to as hybrid systems. A major research issue was the integration of the two components to provide uniﬁed reasoning services over the whole knowledge base.

1.4.2.2 Description Logic systems

The earliest “pre-DL” systems derived directly from Kl-One, which, while itself a direct result of formal analysis of the shortcomings of semantic networks, was mainly about the implementation of a viable classiﬁcation algorithm and the data structures to adequately represent concepts. DL systems, per se, which followed as the next generation, were more derived from a wave of theoretical research on terminological logics that resulted from examination of Kl-One and some other early systems. This work was initiated in roughly 1984, inspired by a paper by Brachman and Levesque [Brachman and Levesque, 1984] on the formal complex- ity of reasoning in Description Logics. Subsequent results on the tradeoff between the expressiveness of a DL language and the complexity of reasoning with it, and more generally, the identiﬁcation of the sources of complexity in DL sys- tems, showed that a careful selection of language constructs was needed and that the reasoning services provided by the system are deeply inﬂuenced by the set of constructs provided to the user. We can thus characterize three different ap- proaches to the implementation of reasoning services. The ﬁrst can be referred to as limited+complete, and includes systems that are designed by restricting the set of constructs in such a way that subsumption would be computed efﬁciently, possibly in polynomial time. The Classic system [Brachman et al., 1991] is the most signiﬁcant example of this kind. The second approach can be denoted as expressive+incomplete, since the idea is to provide both an expressive language and efﬁcient reasoning. The drawback is, however, that reasoning algorithms turn out to be incomplete in these systems. Notable examples of this kind of system are Loom [MacGregor and Bates, 1987], and Back [Nebel and von Luck, 1988]. After some of the sources of incompleteness were discovered, often by identifying the constructs – or, more precisely, combinations of constructs – that would re- quire an exponential algorithm to preserve the completeness of reasoning, systems with complete reasoning algorithms were designed. Systems of this sort (see for example Kris [Baader and Hollunder, 1991a]) are therefore characterized as expressive+complete; they were not as efﬁcient as those following the other ap- proaches, but they provided a testbed for the implementation of reasoning tech- niques developed in the theoretical investigations and they played an important role

in stimulating comparison and benchmarking with other systems [Heinsohn et al., 1992; Baader et al., 1992b].

1.4.2.3 Current generation Description Logic systems

In the current generation of DL-KRSs, the need for complete algorithms for expres- sive languages has been the focus of attention. The expressiveness of the DL lan- guagerequiredforreasoningondatamodelsandsemistructureddatahascontributed to the identiﬁcation of the most important extensions for practical applications. The design of complete algorithms for expressive Description Logic has led to signiﬁcant extensions of tableau-based techniques and to the introduction of several optimization techniques, partly borrowed from theorem proving and partly specif- ically developed for Description Logics. The ﬁrst example of a system developed along these lines is Fact [Horrocks, 1998b]. This research has also been inﬂuenced by newly discovered relationships be- tween Description Logics and other logics, leading to exchanging benchmarks and experimental comparisons with other deduction systems. The techniques that have been used in the implementation of very expressive Description Logics are addressed in detail in Chapter 9.

1.5 Applications developed with Description Logic systems

The third component in the picture of the development of Description Logics is the implementation of applications in different domains. Some of the applications created over the years may have only reached the level of prototype, but many of them have the completeness of industrial systems and have been deployed in production use. AcriticalelementinthedevelopmentofapplicationsbasedonDescriptionLogics is the usability of the knowledge representation system. We have already empha- sized that building a tool to be used in the design and implementation of knowledge- based applications requires signiﬁcant work to make it suitable for interactive development, explanation and debugging, interface implementation, and so on. In addition, here we focus on the effectiveness of Description Logics as a modeling language. A modeling language should have intuitive semantics and the syntax must help convey the intended meaning. To this end, a somewhat different syntax than we have seen so far, closer to that of natural language, has often been adopted, and graphical interfaces that provide an operational view of the process of knowledge base construction have been developed. The issues arising in modeling application domains using Description Logics are dealt with in Chapter 10, and will be brieﬂy addressed in the next subsection.

It is natural to expect that some classes of applications share similarities both in methodological patterns and in the design of speciﬁc structures or reasoning capabilities.Consequently,weidentifyseveralapplicationdomainsinSection1.5.2; these include software engineering, conﬁguration, medicine, and digital libraries and Web-based information systems. In Subsection 1.5.3 we consider several application areas where Description Logics play a major role; these include natural language processing and database management, where Description Logics can be used in several ways. When addressing the design of applications it is also worth pointing out that there has been signiﬁcant evolution in the way Description Logics have been used within complex applications. In particular, the DL-centered view that underlies the earliest generation of systems, wherein an application was developed in a single environment (the one provided by the DL system), was characterized by very loose interaction, if any, between the DL system and other applications. Later, an ap- proach that viewed the Description Logic more as a component became evident; in this view the DL system acts as a component of a larger environment, typically leaving out functions, such those for data management, that are more effectively implemented by other technologies. The architecture where the component view is taken requires the deﬁnition of a clear interface between the components, possibly adopting different modeling languages, but focusing on Description Logics for the implementation of the reasoning services that can add powerful capabilities to the application. Obviously, the choice between the above architectural views depends upon the needs of the application at hand. Finally, we have already stressed that research in Description Logics has beneﬁted from tight interaction between language designers and developers of DL-KRSs. Thus, another major impact on the development of DL research was provided by the implementation of applications using DL-KRSs. Indeed, work on DL applications not only demonstrated the effectiveness of Description Logics and of DL-KRSs, but also provided mutual feedback within the DL community con- cerning the weaknesses of both the representation language and the features of an implemented DL-KRS.

1.5.1 Modeling with Description Logics

In order for designers to be able to use Description Logics to model their application domains, it is important for the DL constructs to be easily understandable; this helps facilitate the construction of convenient to use yet effective tools. To this end, the abstract notation that we have previously introduced and that is nowadays commonly used in the DL community is not fully satisfactory.

As already mentioned, there are at least two major alternatives for increasing the usability of Description Logics as a modeling language:

(i) providing a syntax that resembles more closely natural language; (ii) implementinginterfaceswheretheusercanspecifytherepresentationstructuresthrough graphical operations.

Before addressing the above two possibilities, one brief remark is in order. While alternative ways of specifying knowledge, such as natural-language-style syntax, can be more appealing to the user, one should remember that Description Logics in part arose from a need to respond to the inadequacy – the lack of a formal semantic basis – of early semantic networks and frame systems. Those early systems often relied on an assumption of intuitive readings of natural-language-like constructs or graphical structures, which in the end made them unsatisfactory. Therefore, we need to keep in mind always the correspondence of the language used by the user and the abstract DL syntax, and consequently correspondences with the formal semantics should always be clear and available. The option of a more readable syntax has been pursued in the majority of DL- KRSs. In particular, we refer to the concrete syntax proposed in [Patel-Schneider and Swartout, 1993], which is based on a Lisp-like notation, where, for example, the concept of a female person is denoted by (and Person Female). Similarly, the concept ∀hasChild.Female would be written (all hasChild Female). In ad- dition, there are shorthand expressions, such as (the hasChild Female), which indicates the existence of a unique female child, and can be phrased using qualiﬁed existential restriction and number restriction. In Chapter 10 this kind of syntax is discussed in detail and the possible sources for ambiguities in the natural language reading of the constructs are discussed. The second option for providing the user with a concrete syntax is to rely on a graphical interface. Starting with the Kl-One system, this possibility has been pursued by introducing a graphical notation for the representation of concepts and roles, as well as their relationships. More recently, Web-based interfaces for De- scription Logics have been proposed [Welty, 1996a]; in addition, an XML standard has been proposed [Bechhofer et al., 1999; Euzenat, 2001], which is suitable not only for data interchange, but also for providing full-ﬂedged Web interfaces to DL-KRSs or applications embodying them as components. The modeling language is the vehicle for the expression of the modeling no- tions that are provided to the designers. Modeling in Description Logics requires the designer to specify the concepts of the domain of discourse and characterize their relationships to other concepts and to speciﬁc individuals. Concepts can be regarded as classes of individuals and Description Logics as an object-centered modeling language since they allow one to introduce individuals (objects) and

explicitly deﬁne their properties, as well as to express relationships among them. Concept deﬁnition, which provides for both necessary and sufﬁcient conditions, is a characteristic feature of Description Logics. The basic relationship between concepts is subsumption, which allows one to capture various kinds of subclass- ing mechanisms; however, other kinds of relationships can be modeled, such as grouping, materialization, and part–whole aggregation. The model of a domain in Description Logics is embedded in a knowledge base. We have already addressed the TBox–ABox characterization of the knowledge base. We recall that the roles of TBox and ABox were motivated by the need to dis- tinguish general knowledge about the domain of interest from speciﬁc knowledge about individuals characterizing a speciﬁc world or situation under consideration. Besides the TBox–ABox, other mechanisms for organizing a knowledge base such as contexts and views have been introduced in Description Logics. The use of the modeling notions provided by Description Logics and the organization of knowl- edge bases are addressed in greater detail in Chapter 10. Finally, we recall that Description Logics as modeling languages overlap to a largeextentwithothermodelinglanguagesdevelopedinﬁeldssuchasprogramming languages and database management. While we shall focus on this relationship later, we recall here that, when compared to modeling languages developed in other ﬁelds, the characteristic feature of Description Logics is in the reasoning capabilities that are associated with them. In other words, we believe that, while modeling has general signiﬁcance, the capability of exploiting the description of the model to draw conclusions about the problem at hand is a particular advantage of modeling using Description Logics.

1.5.2 Application domains

Description Logics have been used (and are being used) in the implementation of many systems that demonstrate their practical effectiveness. Some of these systems have found their way into production use, despite the fact that there was no real commercial platform that could be used for developing them.

1.5.2.1 Software engineering

Software engineering was one of the ﬁrst application domains for Desciption Logics undertaken at AT&T, where the Classic system was developed. The basic idea was to use a Description Logic to implement a software information system, i.e., a system that would support the software developer by helping him or her in ﬁnding out information about a large software system. More speciﬁcally, it was found that the information of interest for software devel- opment was a combination of knowledge about the domain of the application and

code-speciﬁc information. However, while the structure of the code can be deter- mined automatically, the connection between code elements and domain concepts needs to be speciﬁed by the user. One of the most novel applications of Description Logics is the Lassie system [Devambu et al., 1991], which allowed users to incrementally build a taxonomy of concepts relating domain notions to the code implementing them. The system could thereafter provide useful information in response to user queries concerning the code, such as, for example “the function to generate a dial tone”. By exploiting the description of the domain, the information retrieval capabilities of the system wentsigniﬁcantlybeyondthoseofthestandardtoolsusedforsoftwaredevelopment. The Lassie system had considerable success but ultimately stumbled because of the difﬁculty of maintenance of the knowledge base, given the constantly changing nature of industrial software. Both the ideas of a software information system and the usage of Description Logics survived that particular application and have been subsequently used in other systems. The usage of Description Logics in applications for software engineering is described in Chapter 11.

1.5.2.2 Conﬁguration

One very successful domain for knowledge-based applications built using Descrip- tion Logics is conﬁguration, which includes applications that support the design of complex systems created by combining multiple components. The conﬁguration task amounts to ﬁnding a proper set of components that can be suitably connected in order to implement a system that meets a given speciﬁca- tion. For example, choosing computer components in order to build a home PC is a relatively simple conﬁguration task. When the number, the type, and the connec- tivity of the components grow, the conﬁguration task can become rather complex. In particular, computer conﬁguration has been among the application ﬁelds of the ﬁrst expert systems and can thus be viewed as a standard application domain for knowledge-based systems. Conﬁguration tasks arise in many industrial domains, such as telecommunications, the automotive industry, building construction, etc. DL-based knowledge representation systems meet the requirements for the devel- opment of conﬁguration applications. In particular, they enable the object-oriented modeling of system components, which combines powerfully with the ability to reason from incomplete speciﬁcations and to automatically detect inconsistencies. Using Description Logics one can exploit the ability to classify the components and organize them within a taxonomy. In addition a DL-based approach supports incre- mental speciﬁcation and modularity. Applications for conﬁguration tasks require at least two features that were not in the original core of DL-KRSs: the representation of rules (together with a rule propagation mechanism), and the ability to provide ex- planations However extensions with so called “active rules” are now very common

in DL-KRSs, and a precise semantic account is given in Chapter 2; signiﬁcant work on explanation capabilities of DL-KRSs has been developed in connection with the designofconﬁgurationapplications[McGuinnessandBorgida,1995].Chapter12is devoted to the applications developed in Description Logics for conﬁguration tasks.

1.5.2.3 Medicine

Medicine is also a domain where expert systems have been developed since the 1980s; however, the complexity of the medical domain calls for a variety of uses for a DL-KRS. In practice, decision support for medical diagnosis is only one of the tasks in need of automation. One focus has been on the construction and maintenance of very large ontologies of medical knowledge, the subject of some large government initiatives. The need to deal with large-scale knowledge bases (hundreds of thousands of concepts) led to the development of specialized systems, such as Galen [Rector et al., 1993], while the requirement for standardization arising from the need to deal with several sources of information led to the adoption of the DL standard language Krss [Patel-Schneider and Swartout, 1993] in projects like Snomed [Spackman et al., 1997]. In order to cope with the scalability of the knowledge base, the DL language adopted in these applications is often limited to a few basic constructs and the knowledge base turns out to be rather shallow, that is to say the taxonomy does not have very many levels of subconcepts below the top concepts. Nonetheless, there are several advanced language features that would be very useful in the represen- tation of medical knowledge, such as, for example, speciﬁc support for PART-OF hierarchies (see Chapter 10), as well as defaults and modalities to capture lack of knowledge (see Chapter 6). Obviously, since medical applications most often must be used by doctors, a for- mal logical language is not well-suited; therefore special attention is given to the design of the user interface; in particular, natural language processing (see Chap- ter 15) is important both in the construction of the ontology and in the operational interfaces. Further, the DL component of a medical application usually operates within a larger information system, comprising several sources of information, which need to be integrated in order to provide a coherent view of the available data (on this topic see Chapter 16). Finally, an important issue that arises in the medical domain is the management of ontologies, which not only requires common tools for project management, such as versioning systems, but also tools to support knowledge acquisition and re-use (on this topic see Chapter 8). The use of Description Logics speciﬁcally in the design of medical applications is addressed in Chapter 13

1.5.2.4 Digital libraries and Web-based information systems

The relationship between semantic networks and the linked structures implied by hypertext has motivated the development of DL applications for representing bib- liographic information and for supporting classiﬁcation and retrieval in digital li- braries [Welty and Jenkins, 2000]. These applications have proven the effectiveness of Description Logics for representing the taxonomies that are commonly used in library classiﬁcation schemes, and they have shown the advantage of subsumption reasoning for classifying and retrieving information. In these instances, a number of technical questions, mostly related to the use of individuals in the taxonomy, have motivated the use of more expressive Description Logics. The possibility of viewing the World Wide Web as a semantic network has been considered since the advent of the Web itself. Even in the early days of the Web, thought was given to the potential beneﬁts of enabling programs to handle not only simple unlabeled navigation structures, but also the information content of Web pages. The goal was to build systems for querying the Web “semantically”, allowing the user to pose queries of the Web as if it were a database, roughly speaking. Based on the relationship between Description Logics and semantic networks, a number of proposals were developed that used Description Logics to model Web structures, allowing the exploitation of DL reasoning capabilities in the acquisition and management of information [Kirk et al., 1995; De Rosa et al., 1998]. More recently, there have been signiﬁcant efforts based on the use of markup languages to capture the information content of Web structures. The relationship be- tween Description Logics and markup languages, such as XML, has been precisely characterized [Calvanese et al., 1999d], thus identifying DL language features for representing XML documents. Moreover, interest in the standardization of knowl- edge representation mechanisms for enabling knowledge exchange has led to the development of DAML-ONT [McGuinness et al., 2002], an ontology language for the Web inspired by object-oriented and frame-based languages, and OIL [Fensel et al., 2001], with a similar goal of expressing ontologies, but with a closer con- nection to Description Logics. Since the two initiatives have similar goals and use languages that are somewhat similar (see Chapter 4 for the relationships between frames and Description Logics), their merger is in progress. The use of Descrip- tion Logics in the design of digital libraries and Web applications is addressed in Chapter 14, with speciﬁc discussion on DAML-ONT, OIL, and DAML+OIL.

1.5.2.5 Other application domains

The above list of application domains, while presenting some of the most relevant applications designed with DL-KRSs, is far from complete. There are many other domains that have been addressed by the DL community Among the application

areas that have resorted to Description Logics for useful functions are planning and data mining. With respect to planning, many knowledge-based applications rely on the ser- vices of a planning component. While Description Logics do not provide such a component themselves, they have been used to implement several general-purpose planning systems. The basic idea is to represent plans and actions, as well as their constituent elements, as concepts. The system can thus maintain a taxon- omy of plan types and provide several reasoning services, such as plan recog- nition, plan subsumption, plan retrieval, and plan reﬁnement. Two examples of planning components developed in a DL-KRS are Clasp [Yen et al., 1991b], de- veloped on top of Classic, and Expect [Swartout and Gil, 1996], developed on top of Loom. In addition, the integration of Description Logics and other for- malisms, such as constraint networks, has been proposed [Weida and Litman, 1992]. Planning systems based on Description Logics have been used in many application domains to support planning services in conjunction with a taxo- nomic representation of the domain knowledge. Such application domains include, amongothers,softwareengineering,medicine,campaignplanning,andinformation integration. It is worth mentioning that Description Logics have also been used to represent dynamic systems and to automatically generate plans based on such representations. However, in such cases the use of Description Logics is limited to the formalization of properties that characterize the states of the system, while plan generation is achieved through the use of a rule propagation mechanism [De Giacomo et al., 1999]. Such use of Description Logics is inspired by the correspondence between Description Logics and Dynamic Logics described in Chapter 5. Description Logics have also been used in data mining applications, where their inferences can help the process of analyzing large amounts of data. In this kind of application, DL structures can represent views, and DL systems can be used to store and classify such views. The classiﬁcation mechanism can help in discovering interesting classes of items in the data. We address this type of application brieﬂy in the next subsection on database management.

1.5.3 Application areas

From the beginning Description Logics have been considered general-purpose lan- guages for knowledge representation and reasoning, and therefore suited for many applications. In particular, they were considered especially effective for those do- mains where the knowledge could be easily organized along a hierarchical struc- ture, based on the “IS-A” relationship. The ability to represent and reason about taxonomies in Description Logics has motivated their use as a modeling language

in the design and maintenance of large, hierarchically structured bodies of knowl- edge as well as their adoption as the representation language for formal ontologies [Welty and Guarino, 2001]. We now brieﬂy look at some other research areas that have a more general relationship with Description Logics. Such a relationship exists either because Description Logics are viewed as a basic representation language, as in the case of natural language processing, or because they can be used in a variety of ways in concert with the main technology of the area, as in the ﬁeld of database management.

1.5.3.1 Natural language

Description Logics, as well as semantic networks and frames, originally had natural language processing as a major ﬁeld for application (see for example [Brachman, 1979]). In particular, when work on Description Logics began, not only was a large part of the DL community working on natural language applications, but Description Logics also bore a strong similarity to other formalisms used in natural language work, such as Feature Logics [Nebel and Smolka, 1991]. TheuseofDescriptionLogicsinnaturallanguageprocessingismainlyconcerned with the representation of semantic knowledge that can be used to convey meanings of sentences. Such knowledge is typically concerned with the meaning of words (the lexicon), and with context, that is, a representation of the situation and domain of discourse. A signiﬁcant body of work has been devoted to the problem of disambiguating different syntactic readings of sentences, based on semantic knowledge, a pro- cess called semantic interpretation. Moreover, semantic knowledge expressed in Description Logics has also been used to support natural language generation. Since the domain of discourse for a natural language application can be arbitrarily broad, work on natural language has also involved the construction of ontologies [Welty and Guarino, 2001]. In addition, the expressiveness of natural language has led also to investigations concerning extensions of Description Logics, such as default reasoning (see Chapter 6). SeverallargeprojectsfornaturallanguageprocessingbasedontheuseofDescrip- tion Logics have been undertaken, some reaching the level of industrially-deployed applications. They are referenced in Chapter 15, where the role of Description Logics in natural language processing is addressed in more detail.

1.5.3.2 Database management

The relationship between Description Logics and databases is rather strong. In fact, there is often the need to build systems where both a DL-KRS and a DataBase ManagementSystem(DBMS)arepresent. DBMSsdealwithpersistenceofdataand with the management of large amounts of it while a DL KRS manages intensional

knowledge, typically keeping the knowledge base in memory (possibly including assertions about individuals that correspond to data). While some of the applications created with DL-KRSs have developed ad hoc solutions to the problem of dealing with large amounts of persistent data, in a complex application domain it is very likely that a DL-KRSs and a DBMS would both be components of a larger system, and they would work together. In addition, Description Logics provide a formal framework that has been shown to be rather close to the languages used in semantic data modeling, such as the Entity–Relationship model [Calvanese et al., 1998g]. Description Logics are equipped with reasoning tools that can bring to the conceptual modeling phase sig- niﬁcant advantages, as compared with traditional languages, whose role is limited to modeling. For instance, by using concept consistency one can verify at design time whether an entity can have at least one instance, thus clearly saving all the difﬁculties arising from discovering such a situation when the database is being populated [Borgida, 1995]. A second dimension of the enhancement of DBMSs with Description Logics involves the query language. By expressing the queries to a database in a Description Logic one gains the ability to classify them and therefore to deal with issues such as query processing and optimization. However, the basic DL machinery needs to be extended in order to deal with conjunctive queries; otherwise DL expressiveness with respect to queries is rather limited. In addition, Description Logics can be used to express constraints and intensional answers to queries. A corollary of the relationship between Description Logics and DBMS query languages is the utility of Description Logics in reasoning with and about views. In the Imacs system [Brachman et al., 1993], the Classic language was used as a “lens” [Brachman, 1994] with which data in a conventional relational database could be viewed. The interface to the data was made signiﬁcantly more appropriate for a data analyst, and views that were found to be productive could be saved; in fact, they were saved in a taxonomy and could be classiﬁed with respect to one another. In a sense, this allows the schema to be viewed and queried explicitly, something normally not available when using a raw DBMS directly. A more recent use of Description Logics is concerned with so-called “semi- structured” data models [Calvanese et al., 1998c], which are being proposed in order to overcome the difﬁculties in treating data that are not structured in a relational form, such as data on the Web, data in spreadsheets, etc. In this area Description Logics are sufﬁciently expressive to represent models and languages that are being used in practice, and they can offer signiﬁcant advantages over other approaches because of the reasoning services they provide. Another problem that has recently increased the applicability of Description Logics is information integration As already remarked data are nowadays available

in large quantities and from a variety of sources. Information integration is the task of providing a unique coherent view of the data stored in the sources available. In order to create such a view, a proper relationship needs to be established between the data in the sources and the uniﬁed view of the data. Description Logics not only have the expressiveness needed in order to model the data in the sources, but their reasoning services can help in the selection of the sources that are relevant for a query of interest, as well as to specify the extraction process [Calvanese et al., 2001c]. The uses of Description Logics with databases are addressed in more detail in Chapter 16.

1.6 Extensions of Description Logics

In this section we look at several types of extensions that have been proposed for Description Logics; these are addressed in more detail in Chapter 6. Such extensions are generally motivated by needs arising in applications. Unfortunately, some extended features in implemented DL-KRSs were created without precise, formal accounts; in some other cases, such accounts have been provided using a formal framework that is not restricted to ﬁrst-order logic. A ﬁrst group of extensions has the purpose of adding to DL languages some representational features that were common in frame systems or that are relevant for certain classes of applications. Such extensions provide a representation of some novel epistemological notions and address the reasoning problems that arise in the extended framework. Extensions of a second sort are concerned with reasoning services that are useful in the development of knowledge bases but are typically not provided by DL-KRSs. The implementation of such services relies on additional inference techniques that are considered non-standard, because they go beyond the basic reasoning services provided by DL-KRSs. Below we ﬁrst address the extensions of the knowledge representation framework and then non-standard inferences.

1.6.1 Language extensions

Some of the research associated with language extensions has investigated the se- mantics of the proposed extensions, but often the emphasis is only on ﬁnding rea- soning procedures for the extended languages. Within these language extensions we ﬁnd constructs for non-monotonic, epistemic, and temporal reasoning, and con- structs for representing belief and uncertain and vague knowledge. In addition some constructs address reasoning in concrete domains

1.6.1.1 Non-monotonic reasoning

When frame-based systems began to be formally characterized as fragments of ﬁrst-order logic, it became clear that those frame-based systems as well as some DL-KRSs that were used in practice occasionally provided the user with constructs that could not be given a precise semantic characterization within the framework of ﬁrst-order logic. Notable among the problematic constructs were those associated with the notion of defaults, which over time have been extensively studied in the ﬁeld of non-monotonic reasoning [Brachman, 1985]. While one of the problems arising in semantic networks was the oft-cited so- called “Nixon diamond” [Reiter and Criscuolo, 1981], a whole line of research in non-monotonic reasoning was developed in trying to characterize the system behavior by studying structural properties of networks. For example, the general property that “birds ﬂy” might not be inherited by a penguin, because a rule that penguins do not ﬂy would give rise to an arc in the network that would block the default inference. But as soon as the network becomes relatively complex (see for example [Touretzky et al., 1991]), we can see that attempts to provide semantic characterization in terms of network structure are inadequate. Another approach that has been pursued in the formalization of non-monotonic reasoning in semantic networks is based on the use of default logic [Reiter, 1980; Etherington, 1987; Nado and Fikes, 1987]. Following a similar approach is the treatment of defaults in DL-based systems [Baader and Hollunder, 1995a], where formal tools borrowed from work on non-monotonic reasoning have been adapted to the framework of Description Logics. Such adaptation is non-trivial, however, because Description Logics are not, in general, propositional languages.

1.6.1.2 Modal representation of knowledge and belief

Modal logics have been widely studied to model a variety of features that in ﬁrst- order logic would require the application of special constraints on certain elements of the formalization. For example, the notions of knowing something or believing that some sentence is true can be captured by introducing modal operators, which characterize properties that sentences have. For instance the assertion

B(Married(ANNA))

states a fact explicitly concerning the system’s beliefs (the system believes that Anna is married), rather than asserting the truth of something about the world being modeled (the system could believe something to be true without ﬁrm knowledge about its truth in the world). In general, by introducing a modal operator one gains the ability to model prop- erties like knowledge belief time dependence obligation and so on On the one

hand, extensions of Description Logics with modal operators can be viewed very much like the corresponding modal extensions of ﬁrst-order logic. In particular, the semantic issues arising in the interpretation of quantiﬁed modal sentences (i.e., sen- tences with modal operators appearing inside the scope of quantiﬁers) are the same. On the other hand, the syntactic restrictions that are suited to a DL language lead to formalisms whose expressiveness and reasoning problems inherit some of the fea- tures of a specialized DL language. Extensions of Description Logics with modal operators including those for representing knowledge and belief are discussed in [Baader and Ohlbach, 1995].

1.6.1.3 Epistemic reasoning

Itisnotsufﬁcienttoprovideasemanticsfordefaultstoobtainafullsemanticaccount of frame-based systems. Frame-based systems have included procedural rules as well as other forms of closure and epistemic reasoning that need to be covered by the semantics as well as by the reasoning algorithms. In particular, if one looks at the most widely-used systems based on Description Logics, such features are still present, possibly in new ﬂavors, while their semantics is given informally and the consequences of reasoning sometimes not adequately explained. Among the non-ﬁrst-order features that are used in the practice of knowledge- based applications in both DL-based and frame-based systems we point out these:

r procedural rules (also called trigger rules), which are normally described as if–then statements and are used to infer new facts about known individuals; r default rules, which enable default reasoning in inheritance hierarchies; r role closure, which limits the reasoning involving role restrictions to the individuals explicitly in the knowledge base; r integrity constraints, which provide consistency restrictions on admissible knowledge bases.

In Chapter 6, among other approaches an epistemic extension of Description Logics with a modal operator is addressed. In the resulting formalism [Donini et al., 1998a] one can express epistemic queries and, by admitting a simple form of epistemic sentences in the knowledge base, one can formalize the aforementioned procedural rules. This characterization of procedural rules in terms of an epistemic operator has been widely accepted in the DL community and is thus also included in Chapter 2. The approach has been further extended to what have been called Autoepistemic Description Logics (ADLs) [Donini et al., 1997b, 2002], where it is combined with default reasoning. This combination is achieved by relying on the non-monotonic modal logic MKNF [Lifschitz, 1991], thus introducing a second modal operator interpreted as autoepistemic assumption. The features mentioned above can be uniformly treated as epistemic sentences in the knowledge base

without the need to give them special status as in the case of procedural rules, defaults, and epistemic constraints on the knowledge base. This expressiveness does not come without making reasoning more difﬁcult. An extension of the rea- soning methods available for deduction in the propositional formalizations of non-monotonic reasoning to the fragment of ﬁrst-order logic corresponding to Description Logics has nonetheless been shown to be decidable.

1.6.1.4 Temporal reasoning

One notion that is often required in the formalization of application domains is time. Temporal extensions of Description Logics have been treated as a special kind of modal extension. The ﬁrst proposal for handling time in a DL framework [Schmiedel, 1990] was originated in the context of the DL system Back. Later, following the standard approaches in the representation of time, both interval- based and point-based approaches have been studied, speciﬁcally focusing on the decidability and complexity of the reasoning problems (see [Artale and Franconi, 2001] for a survey the temporal extensions of Description Logics). Time intervals can also be treated as a form of concrete domain (see below).

1.6.1.5 Representation of uncertain and vague knowledge

Another aspect of knowledge that is sometimes useful in representing and reason- ing about application domains is uncertainty. As in other knowledge representation frameworks there are several approaches to the representation of uncertain knowl- edge in Description Logics. Two of them, namely probabilistic logic and fuzzy logic, have been proposed in the context of Description Logics. In the case of prob- abilistic Description Logics [Heinsohn, 1994; Jaeger, 1994] the knowledge about the domain is expressed in terms of probabilistic terminological axioms, which allow one to represent statistical information about the domain, and in terms of probabilistic assertions, which specify the degree of belief of asserted properties. The reasoning tasks aim at ﬁnding the probability bounds for subsumption relations and assertions. A more recent line of work tries to combine Description Logics with Bayesian networks. In the case of fuzzy Description Logics [Yen, 1991] the goal is to characterize no- tions that cannot be properly deﬁned with a “crisp” numerical bound. For example, the concept of living near Rome cannot be always deﬁned with a crisp boundary on the map, but must be represented with a membership or degree function, which expresses closeness to the city in a continuous way. Proposed approaches to fuzzy Description Logics not only deﬁne the semantics of assertions in terms of fuzzy sets, but also introduce new operators to express notions like “mostly”, “very”, etc. Reasoning algorithms are also provided for computing fuzzy subsumption within the framework of tableau based methods

1.6.1.6 Concrete domains

One of the limitations of basic Description Logics is related to the difﬁculty of inte- grating knowledge (and, consequently, performing reasoning) of speciﬁc domains, such as numbers or strings, which are needed in many applications. For example, in order to model the concept of a young person it seems rather natural to introduce the (functional) role age and to use a concrete value (or range of values) in the deﬁnition of the concept. In addition, one would like to be able to conclude that a person of school age is also a young person. Such a conclusion might require the use of properties of numbers to establish that the expected subsumption relation holds. While for some time such extensions were designed in ad hoc ways, in [Baader and Hanschke, 1991a] a general method was established for integrating knowl- edge about concrete domains within a DL language. If a domain can be properly formalized, it is shown that the tableau-based reasoning technique can be suitably extended to handle the reasoning services in the extended language. Concrete domains include not only data types such as numerical types, but also more elaborate domains, such as tuples of the relational calculus, spatial regions, or time intervals.

1.6.2 Additional reasoning services

Non-standard inference tasks can serve a variety of purposes, among them support in building and maintaining the knowledge base, as well as in obtaining information about the knowledge represented in it. Among the more useful non-standard inference tasks in Description Logics we ﬁnd the computation of the least common subsumer and the most speciﬁc concept, matching/uniﬁcation, and concept rewriting.

1.6.2.1 Least common subsumer and most speciﬁc concept

The least common subsumer (lcs) of a set of concepts is the minimal concept that subsumes all of them. The minimality condition implies there is no other concept that subsumes all the concepts in the set and is less general (subsumed by) the lcs. This notion was ﬁrst studied in [Cohen et al., 1992] and it has subsequently been used for several tasks: inductive learning of concept description from examples; knowledge base viviﬁcation (as a way to represent disjunction in languages that do not admit it); and in the bottom-up construction of DL knowledge bases (starting from instances of the concepts). The notion of lcs is closely related to that of most speciﬁc concept (msc) of an individual i e the least concept description that the individual is an instance of

given the assertions in the knowledge base; the minimality condition is speciﬁed as before. More generally, one can deﬁne the msc of a set of assertions about individuals as the lcs of the msc associated with each individual. Based on the computationofthemscofasetofassertionsaboutindividualsonecanincrementally construct a knowledge base [Baader and K¨usters, 1999]. It interesting to observe that the techniques that have been proposed to compute the lcs and mcs rely on compact representations of concept expressions, which are built either following the structural subsumption approach, or through the deﬁnition of a well-suited normal form.

1.6.2.2 Uniﬁcation and matching

Another tool to support the construction and maintenance of DL knowledge bases that goes beyond the standard inference services provided by DL-KRSs is the uniﬁcation of concepts. Concept uniﬁcation [Baader and Narendran, 1998] is an operation that can be regarded as weakening the equivalence between two concept expressions. More precisely, two concept expressions unify if one can ﬁnd a substitution of con- cept variables into concept expressions such that the result of applying the sub- stitution gives equivalent concepts. The intuition is that, in order to ﬁnd possible overlaps between concept deﬁnitions, one can treat certain concept names as vari- ables and discover, via uniﬁcation, that two concepts (possibly independently de- ﬁned by distinct knowledge designers) are in fact equivalent. The knowledge base can consequently be simpliﬁed by introducing a single deﬁnition of the uniﬁable concepts. As usual, matching is deﬁned as a special case of uniﬁcation, where variables occur only in one of the two concept expressions. In addition, in the framework of Description Logics, one can deﬁne matching and uniﬁcation based on the sub- sumption relation instead of equivalence [Baader et al., 1999a]. As with other non-standard inferences, the computation of matching and uniﬁ- cation relies on the use of specialized representations for concept expressions, and it has been shown to be decidable for rather simple Description Logics.

1.6.2.3 Concept rewriting

Finally, there has been a signiﬁcant body of work on the problem of concept rewrit- ing. Given a concept expressed in a source language, concept rewriting amounts to ﬁnding a concept, possibly expressed in a target language, which is related to the given concept according to equivalence, subsumption, or some other relation. In order to specify the rewriting, one can provide a suitable set of constraints be- tween concepts in the source language and concepts in the target language. Concept rewriting can be applied to the translation of concepts from one knowledge base to

another, or in the reformulation of concepts during the process of knowledge base construction and maintenance. In addition, concept rewriting has been addressed in the context of the rewriting of queries using views, in database management (see also Chapter 16), and has recently been investigated in the framework of information integration. In this setting, one can apply concept rewriting techniques to automatically generate the queries that enable a system to gather information from a set of sources [Beeri et al., 1997]. Given an initial speciﬁcation of the query according to a common, global language, and a set of constraints expressing the relationship between the global schema and the individual sources where information is stored, the problem is to compute the queries to be posed to the local sources that provide answers, possibly approximate, to the original query [Calvanese et al., 2000a].

1.7 Relationship to other ﬁelds of Computer Science

Description Logics were developed with the goals of providing formal, declarative meanings to semantic networks and frames, and of showing that such representation structures can be equipped with efﬁcient reasoning tools. However, the underly- ing ideas of concept/class and hierarchical structure based upon the generality and speciﬁcity of a set of classes have appeared in many other ﬁelds of Computer Sci- ence, such as database management and programming languages. Consequently, there have been a number of attempts to ﬁnd commonalities and differences among formalisms with similar underlying notions, but which were developed in different ﬁelds. Moreover, by looking at the syntactic form of Description Logics – logics that are restricted to unary and binary predicates and allow restricted forms of quan- tiﬁcation – other logical formalisms that have strong relationships with Description Logics have been identiﬁed. In this section we brieﬂy address such relationships; in particular, we focus our attention on the relationship of Description Logics to other class-based languages, and then we address the relationship between Description Logics and other logics. These topics are addressed in more detail in Chapter 4.

1.7.1 Description Logics and other class-based formalisms

As we have mentioned, Description Logics can, in principle, be related to other class-based formalisms. Before looking at other ﬁelds, it is worth relating Descrip- tion Logics to other formalisms developed within the ﬁeld of knowledge repre- sentation that share the intuitions underlying network-based representation struc- ture. In [Lehmann, 1992] several languages aiming at structured representations of knowledge are reviewed. We have already discussed the relationship between Description Logics and semantic networks and frames since they provided the

basic motivations for developing Description Logics in the ﬁrst place. Among others, conceptual graphs [Sowa, 1991] have been regarded as a way of representing conceptual structures very closely related to semantic networks (and consequently, to Description Logics). However, only recently has there been a detailed analysis of the relationship between conceptual graphs and Description Logics [Baader et al., 1999c]. The outcome of this work makes it apparent that, although one can estab- lish a relationship between simple conceptual graphs and a DL language, there are substantial differences between the two formalisms. The most signiﬁcant one is that Description Logics are characterized by the universally quantiﬁed role restriction, which is not present in conceptual graphs. Consequently, the interpretation of the representation structures becomes substantially different. In many other ﬁelds of Computer Science we ﬁnd formalisms for the repre- sentation of objects and classes [Motschnig-Pitrik and Mylopoulous, 1992]. Such formalisms share the notion of a class that denotes a subset of the domain of dis- course, and they allow one to express several kinds of relationships and constraints (e.g., subclass constraints) that hold among classes. Moreover, class-based for- malisms aim at taking advantage of the class structure in order to provide various types of information, such as whether an element belongs to a class, whether a class is a subclass of another class, and more generally, whether a given constraint holds between two classes. In particular, formalisms that are built upon the notions of class and class-based hierarchies have been developed in the ﬁeld of database man- agement, in semantic data modeling (see for example [Hull and King, 1987]), in object-oriented languages (see for example [Kim and Lochovsky, 1989]), and more generally, in programming languages (see for example [Lenzerini et al., 1991]). There have been several attempts to establish relationships among the class-based formalismsdevelopedindifferentﬁelds.Inparticular,thecommonintuitionsbehind classes and concepts have stimulated several pieces of work aimed at establishing a precise relationship between class-based formalisms and Description Logics. However, it is difﬁcult to ﬁnd a common framework for carrying out a precise comparison. In Chapter 4 a speciﬁc Description Logic is taken as a basis for identifying the common features of frame systems and object-oriented and semantic data models (see also [Calvanese et al., 1999e]). Speciﬁcally, a precise correspondence between the chosen DL and the Entity–Relationship model [Chen, 1976], as well as with an object-oriented language in the style of [Abiteboul and Kanellakis, 1989], is presented there. This kind of comparison shows that one can indeed identify a large common basis, but also that there are features that are currently missing in each formalism. For example, to capture semantic data models one needs a cyclic form of inclusion assertion as well as the inverses of roles for modeling relationships that work in

both directions, while DL roles have a directionality from one concept to another. Moreover, in order to make a comparison with frame-based systems, one has to leave out both the non-monotonic features of frames, such as defaults and closures (which are addressed among the extensions of Description Logics in the previous section) and their dynamic aspects such as daemons and and triggers (with the ex- ception of trigger rules, which are also addressed in the previous section). Finally, with respect to object-oriented data models the main difference is that although Description Logics provide the expressiveness to model record and set structures, they are not explicitly available in Description Logics and thus their representation is a little cumbersome. On the other hand, semantic and object-oriented data models are typically not equipped with reasoning tools that are available with Description Logics. This issue is further developed in Chapter 16, where the applications of Description Logics in the ﬁeld of database management are addressed. However, if the language is sufﬁciently expressive, as it needs to be in order to establish rela- tionships among various class-based formalisms, one needs to distinguish between ﬁnite model reasoning, which is required for database languages that are designed to represent a closed domain of discourse, and unrestricted reasoning, which is typical of knowledge representation formalisms and, therefore, of Description Logics.

1.7.2 Relationships to other logics

The initial observation for addressing the relationship of Description Logics to other logics is the fact that Description Logics are subsets of ﬁrst-order logic. This has been known since the earliest days of Description Logics, and has been thoroughly investigated in [Borgida, 1996]. In fact, the Description Logic ALC corresponds to the fragment of ﬁrst-order logic obtained by restricting the syntax to formulas containing two variables. The importance of this and subsequent studies on this issue is related to ﬁnding adequate characterizations of the expressiveness of Description Logics. Since Description Logics focus on a language formed by unary and binary pred- icates, it turned out that they are closely related to modal languages, if one regards roles as accessibility relations. In particular, Schild [1991] pointed out that some Description Logics are notational variants of certain propositional modal logics; speciﬁcally, the Description Logic ALC has a modal logic counterpart, namely the multi-modal version of the logic K (see [Halpern and Moses, 1992]). Actually, ALC-concepts and formulas in multi-modal K can immediately be translated into each other. Moreover, an ALC-concept is satisﬁable if and only if the corresponding K-formula is satisﬁable. Research in the complexity of the satisﬁability problem for modal propositional logics was initiated quite some time before the complex- ity of Description Logics was investigated Consequently this relationship made it

possible to borrow from modal logic complexity results, reasoning techniques, and language constructs that had not been previously considered in Description Logics. On the other hand, there are features of Description Logics that did not have coun- terparts in modal logics and therefore needed ad hoc extensions of the reasoning techniques developed for modal logics. In particular, number restrictions as well as the treatment of individuals in the ABox required speciﬁc treatments based on the idea of reiﬁcation, which amounts to expressing the extensions through a special kind of axiom within the logic. Finally, we mention that recent work has pointed out a relationship between Description Logics and guarded fragments, which can be regarded as generalizations of modal logics. Most of the research on very expres- sive Description Logics, addressed in Chapter 5, has its roots in the correspondence with modal logic.

1.8 Conclusion

From their humble origins in the late 1970s as a remedy for logical and semantic problems in frame and semantic network representations, Description Logics have grown to be a unique and important keystone in the history of knowledge repre- sentation. DL formalisms certainly evoked interest in their earliest days, with the invention and application of the Kl-One system, but international attention and re- search was given a signiﬁcant boost in 1984 when Brachman and Levesque used the simple and intuitive structure of Description Logics as the basis for their observation about the tradeoff between knowledge representation language expressiveness and computational complexity of reasoning. The way Description Logics were able to separate out the structure of concepts and roles into simple term-forming operators opened the door to extensive analysis of a broad family of languages. One could add and subtract these operators to and from the language and explore both the computational ramiﬁcations and the relationship of the resulting language to other formal languages in Computer Science, such as modal logics and data models for database systems. As a result, the family of Description Logic languages is probably the most thoroughly understood set of formalisms in all of knowledge representation. The computational space has been thoroughly mapped out, and a wide variety of systems have been built, testing out different styles of inference computation and being used in many applications. Description Logics are responsible for many of the cornerstone notions used in knowledge representation and reasoning. They helped crystallize many of the ideas treated informally in earlier notations, such as concepts and roles. But they added many new important building blocks for later work in the ﬁeld: the terminology/assertion distinction (TBox/ABox) number and value restrictions on

roles, internal structure for concepts, Tell&Ask interfaces, and others. They have been the subject of a great deal of comparison and analysis with their cousins in other ﬁelds of Computer Science, and DL systems run the gamut from simple, re- stricted systems with provably advantageous computational properties to extremely expressive systems that can support very powerful applications. Perhaps the most important aspect of work on Description Logics has been the very tight coupling between theory and practice. The exemplary give-and-take between the formal, an- alytical side of the ﬁeld and the pragmatic, implemented side – notable throughout the entire history of Description Logics – has been a role model for other areas of AI.

Acknowledgements

We are grateful to Franz Baader, Francesco M. Donini, Maurizio Lenzerini, and Riccardo Rosati for reading the manuscript and making suggestions for improving the ﬁnal version of the chapter.

Part I

Theory

2

Basic Description Logics

FRANZ BAADER WERNER NUTT

Abstract

This chapter provides an introduction to Description Logics as a formal language for representing knowledge and reasoning about it. It ﬁrst gives a short overview of the ideas underlying Description Logics. Then it introduces syntax and semantics, covering the basic constructors that are used in systems or have been introduced in the literature, and the way these constructors can be used to build knowledge bases. Finally, it deﬁnes the typical inference problems, shows how they are interrelated, and describes different approaches for effectively solving these problems. Some of the topics that are only brieﬂy mentioned in this chapter will be treated in more detail in subsequent chapters.

2.1 Introduction

As sketched in the previous chapter, Description Logics is the most recent name1

for a family of knowledge representation (KR) formalisms that represent the knowl- edge of an application domain (the “world”) by ﬁrst deﬁning the relevant concepts of the domain (its terminology), and then using these concepts to specify properties of objects and individuals occurring in the domain (the world description). As the name Description Logics indicates, one of the characteristics of these languages is that, unlike some of their predecessors, they are equipped with a formal, logic-based semantics. Another distinguished feature is the emphasis on reasoning as a central service: reasoning allows one to infer implicitly represented knowledge from the knowledge that is explicitly contained in the knowledge base. Description Logics support inference patterns that occur in many applications of intelligent information processing systems, and which are also used by humans to structure and understand

1 Previously used names are terminological knowledge representation languages, concept languages, term sub- ti l d K O b d k l d t ti l

the world: classiﬁcation of concepts and individuals. Classiﬁcation of concepts de- termines subconcept–superconcept relationships (called subsumption relationships in Description Logics) between the concepts of a given terminology, and thus allows one to structure the terminology in the form of a subsumption hierarchy. This hi- erarchy provides useful information on the connection between different concepts, and it can be used to speed up other inference services. Classiﬁcation of individuals (or objects) determines whether a given individual is always an instance of a certain concept (i.e., whether this instance relationship is implied by the description of the individual and the deﬁnition of the concept). It thus provides useful information on the properties of an individual. Moreover, instance relationships may trigger the application of rules that insert additional facts into the knowledge base. Because Description Logics are a KR formalism, and since in KR one usually assumes that a KR system should always answer the queries of a user in reasonable time, the reasoning procedures DL researchers are interested in are decision proce- dures, i.e., unlike ﬁrst-order theorem provers, for example, these procedures should always terminate, both for positive and for negative answers. Since the guarantee of an answer in ﬁnite time need not imply that the answer is given in reasonable time, investigating the computational complexity of a given Description Logic with decidable inference problems is an important issue. Decidability and complexity of the inference problems depend on the expressive power of the Description Logic at hand. On the one hand, very expressive Description Logics are likely to have inference problems of high complexity, or they may even be undecidable. On the other hand, very weak Description Logics (with efﬁcient reasoning procedures) may not be sufﬁciently expressive to represent the important concepts of a given application. As mentioned in the previous chapter, investigating this tradeoff be- tween the expressivity of Description Logics and the complexity of their reasoning problems has been one of the most important issues in DL research. Description Logics are descended from so-called “structured inheritance net- works” [Brachman, 1977b; 1978], which were introduced to overcome the ambi- guities of early semantic networks and frames, and which were ﬁrst realized in the system Kl-One [Brachman and Schmolze, 1985]. The following three ideas, ﬁrst put forward in Brachman’s work on structured inheritance networks, have largely shaped the subsequent development of Description Logics:

r The basic syntactic building blocks are atomic concepts (unary predicates), atomic roles (binary predicates), and individuals (constants). r The expressive power of the language is restricted in that it uses a rather small set of (epistemologically adequate) constructors for building complex concepts and roles. r Implicit knowledge about concepts and individuals can be inferred automatically with the help of inference procedures. In particular, subsumption relationships between concepts and instance relationships bet een indi id als and concepts pla an important role: nlike

IS-A links in semantic networks, which are explicitly introduced by the user, subsumption relationships and instance relationships are inferred from the deﬁnition of the concepts and the properties of the individuals.

After the ﬁrst logic-based semantics for Kl-One-like KR languages were proposed, the inference problems like subsumption could also be provided with a precise meaning, which led to the ﬁrst formal investigations of the computational proper- ties of such languages. It has turned out that the languages used in early DL sys- tems were too expressive, which led to undecidability of the subsumption problem [Schmidt-Schauß, 1989; Patel-Schneider, 1989b]. The ﬁrst worst-case complexity results [Levesque and Brachman, 1987; Nebel, 1988] showed that the subsumption problem is intractable (i.e., not polynomially solvable) even for very inexpressive languages. As mentioned in the previous chapter, this work was the starting point of a thorough investigation of the worst-case complexity of reasoning in Kl-One-like KR languages (see Chapter 3 for details). Later on it has turned out, however, that intractability of reasoning (in the sense of being non-polynomial in the worst case) does not prevent a Description Logic from being useful in practice, provided that sophisticated optimization techniques are used when implementing a system based on such a Description Logic (see Chapter 9). When implementing a DL system, the efﬁcient implementation of the basic reasoning algorithms is not the only issue, though. On the one hand, the derived system services (such as classiﬁcation, i.e., constructing the subsump- tion hierarchy between all concepts deﬁned in a terminology) must be optimized as well [Baader et al., 1994]. On the other hand, one needs a good user and application programming interface (see Chapter 7 for more details). Most imple- mented DL systems provide for a rule language, which can be seen as a very sim- ple, but effective, application programming mechanism (see Subsection 2.2.5 for details). Section 2.2 introduces the basic formalism of Description Logics. By way of a prototypical example, it ﬁrst introduces the formalism for describing concepts (i.e., the description language), and then deﬁnes the terminological (TBox) and the assertional (ABox) formalisms. Next, it introduces the basic reasoning problems and shows how they are related to each other. Finally, it deﬁnes the rule language that is available in many of the implemented DL systems. Section 2.3 describes algorithms for solving the basic reasoning problems in Description Logics. After shortly sketching structural subsumption algorithms, it concentrates on tableau-based algorithms. Finally, it comments on the problem of reasoning w.r.t. terminologies. Finally, Section 2.4 describes some additional language constructors that are not included in the prototypical family of description languages introduced in

TBox

Description Reasoning

Language

ABox

KB

Application Programs Rules

Fig. 2.1. Architecture of a knowledge representation system based on Description Logics.

Section 2.2, but have been considered in the literature and are available in some DL systems.

2.2 Deﬁnition of the basic formalism

A KR system based on Description Logics provides facilities to set up knowledge bases, to reason about their content, and to manipulate them. Figure 2.1 sketches the architecture of such a system (see Chapter 8 for more information on DL systems). A knowledge base (KB) comprises two components, the TBox and the ABox. The TBox introduces the terminology, i.e., the vocabulary of an application do- main, while the ABox contains assertions about named individuals in terms of this vocabulary. The vocabulary consists of concepts, which denote sets of individuals, and roles, which denote binary relationships between individuals. In addition to atomic con- cepts and roles (concept and role names), all DL systems allow their users to build complex descriptions of concepts and roles. The TBox can be used to assign names to complex descriptions. The language for building descriptions is a characteristic of each DL system, and different systems are distinguished by their description languages. The description language has a model-theoretic semantics. Thus, state- ments in the TBox and in the ABox can be identiﬁed with formulae in ﬁrst-order logic or, in some cases, a slight extension of it. A DL system not only stores terminologies and assertions, but also offers ser- vices that reason about them. Typical reasoning tasks for a terminology are to determine whether a description is satisﬁable (i.e., non-contradictory), or whether one description is more general than another one, that is, whether the ﬁrst subsumes the second. Important problems for an ABox are to ﬁnd out whether its set of as- sertions is consistent, that is, whether it has a model, and whether the assertions in the ABox entail that a particular individual is an instance of a given concept description Satisﬁability checks of descriptions and consistency checks of sets of

assertions are useful to determine whether a knowledge base is meaningful at all. With subsumption tests, one can organize the concepts of a terminology into a hi- erarchy according to their generality. A concept description can also be conceived as a query, describing a set of objects one is interested in. Thus, with instance tests, one can retrieve the individuals that satisfy the query. In any application, a KR system is embedded into a larger environment. Other components interact with the KR component by querying the knowledge base and by modifying it, that is, by adding and retracting concepts, roles, and assertions. A restricted mechanism for adding assertions uses rules. Rules are an extension of the logical core formalism, which can still be interpreted logically. However, many systems, in addition to providing an application programming interface that consists of functions with a well-deﬁned logical semantics, provide an escape hatch by which application programs can operate on the KB in arbitrary ways.

2.2.1 Description languages

Elementary descriptions are atomic concepts and atomic roles. Complex descrip- tions can be built from them inductively with concept constructors. In abstract notation, we use the letters A and B for atomic concepts, the letter R for atomic roles, and the letters C and D for concept descriptions. Description languages are distinguished by the constructors they provide. In the sequel we shall discuss vari- ous languages from the family of AL-languages. The language AL (= attributive language) has been introduced in [Schmidt-Schauß and Smolka, 1991] as a min- imal language that is of practical interest. The other languages of this family are extensions of AL.

2.2.1.1 The basic description language AL

Concept descriptions in AL are formed according to the following syntax rule:

C, D −→ A | (atomic concept) ⊤| (universal concept) ⊥| (bottom concept) ¬A | (atomic negation) C ⊓D | (intersection) ∀R.C | (value restriction) ∃R.⊤ (limited existential quantiﬁcation).

Note that, in AL, negation can only be applied to atomic concepts, and only the top concept is allowed in the scope of an existential quantiﬁcation over a role. For historical reasons the sublanguage of AL obtained by disallowing atomic

negation is called FL−and the sublanguage of FL−obtained by disallowing limited existential quantiﬁcation is called FL0. To give examples of what can be expressed in AL, we suppose that Person and Female are atomic concepts. Then Person ⊓Female and Person ⊓¬Female are AL-concepts describing, intuitively, those persons that are female, and those that are not female. If, in addition, we suppose that hasChild is an atomic role, we can form the concepts Person ⊓∃hasChild.⊤and Person ⊓∀hasChild.Female, denoting those persons that have a child, and those persons all of whose children are female. Using the bottom concept, we can also describe those persons without a child by the concept Person ⊓∀hasChild.⊥. In order to deﬁne a formal semantics of AL-concepts, we consider interpreta- tions I that consist of a non-empty set I (the domain of the interpretation) and an interpretation function, which assigns to every atomic concept A a set AI ⊆I

and to every atomic role R a binary relation RI ⊆I × I. The interpretation function is extended to concept descriptions by the following inductive deﬁnitions:

⊤I = I

⊥I = ∅ (¬A)I = I \ AI

(C ⊓D)I = CI ∩DI

(∀R.C)I = {a ∈I | ∀b. (a, b) ∈RI →b ∈CI} (∃R.⊤)I = {a ∈I | ∃b. (a, b) ∈RI}.

We say that two concepts C, D are equivalent, and write C ≡D, if CI = DI

for all interpretations I. For instance, going back to the deﬁnition of the semantics of concepts, one easily veriﬁes that ∀hasChild.Female ⊓∀hasChild.Student and ∀hasChild.(Female ⊓Student) are equivalent.

2.2.1.2 The family of AL-languages

We obtain more expressive languages if we add further constructors to AL. The union of concepts (indicated by the letter U) is written as C ⊔D, and interpreted as

(C ⊔D)I = CI ∪DI.

Full existential quantiﬁcation (indicated by the letter E) is written as ∃R.C, and interpreted as

(∃R.C)I = {a ∈I | ∃b. (a, b) ∈RI ∧b ∈CI}.

Note that ∃R.C differs from ∃R.⊤in that arbitrary concepts are allowed to occur in the scope of the existential quantiﬁer

Number restrictions (indicated by the letter N) are written as ⩾n R (at-least restriction) and as ⩽n R (at-most restriction), where n ranges over the nonnegative integers. They are interpreted as

(⩾n R)I =  a ∈I  |{b | (a, b) ∈RI}| ≥n  ,

and

(⩽n R)I =  a ∈I  |{b | (a, b) ∈RI}| ≤n  ,

respectively, where “| · |” denotes the cardinality of a set. From a semantic view- point, the coding of numbers in number restrictions is immaterial. However, for the complexity analysis of inferences it can matter whether a number n is represented in binary (or decimal) notation or by a string of length n, since binary (decimal) notation allows a more compact representation. The negation of arbitrary concepts (indicated by the letter C, for “complement”) is written as ¬C, and interpreted as

(¬C)I = I \ CI.

With the additional constructors, we can, for example, describe those persons that have either not more than one child or at least three children, one of whom is female:

Person ⊓(⩽1 hasChild ⊔(⩾3 hasChild ⊓∃hasChild.Female)).

Extending AL by any subset of the above constructors yields a particular AL- language. We name each AL-language by a string of the form

AL[U][E][N][C],

where a letter in the name stands for the presence of the corresponding constructor. For instance, ALEN is the extension of AL by full existential quantiﬁcation and number restrictions (see the appendix on DL terminology for how to extend this naming scheme to more expressive Description Logics). From the semantic point of view, not all these languages are distinct, how- ever. The semantics enforces the equivalences C ⊔D ≡¬(¬C ⊓¬D) and ∃R.C ≡ ¬∀R.¬C. Hence, union and full existential quantiﬁcation can be expressed using negation. Conversely, the combination of union and full existential quantiﬁcation gives us the ability to express negation of concepts (through their equivalent nega- tion normal form, see Subsection 2.3.2). Therefore, we assume w.l.o.g. that union and full existential quantiﬁcation are available in every language that contains nega- tion, and vice versa. It follows that (modulo the equivalences mentioned above), all AL-languages can be written using the letters U, E, N only. It is not hard to see that the eight languages obtained this way are indeed pairwise non equivalent In

the sequel, we shall not distinguish between an AL-language with negation and its counterpart that has union and full existential quantiﬁcation instead. In the same vein, we shall use the letter C instead of the letters UE in language names. For instance, we shall write ALC instead of ALUE and ALCN instead of ALUEN.

2.2.1.3 Description languages as fragments of predicate logic

The semantics of concepts identiﬁes description languages as fragments of ﬁrst- order predicate logic. Since an interpretation I respectively assigns to every atomic concept and role a unary and binary relation over I, we can view atomic concepts and roles as unary and binary predicates. Then, any concept C can be translated effectively into a predicate logic formula φC(x) with one free variable x such that for every interpretation I the set of elements of I satisfying φC(x) is exactly CI: An atomic concept A is translated into the formula A(x); the constructors intersec- tion, union, and negation are translated into logical conjunction, disjunction, and negation, respectively; if C is already translated into φC(x) and R is an atomic role, then value restriction and existential quantiﬁcation are captured by the formulae

φ∃R.C(y) = ∃x. R(y, x) ∧φC(x) φ∀R.C(y) = ∀x. R(y, x) →φC(x),

where y is a new variable; number restrictions are expressed by the formulae

φ⩾n R(x) = ∃y1, . . . , yn. R(x, y1) ∧· · · ∧R(x, yn) ∧ 

i< j yi ̸= y j

φ⩽n R(x) = ∀y1, . . . , yn+1. R(x, y1) ∧· · · ∧R(x, yn+1) → 

i< j yi = y j.

Note that the equality predicate “=” is needed to express number restrictions, while concepts without number restrictions can be translated into equality-free formulae. One may argue that, since concepts can be translated into predicate logic, there is no need for a special syntax. However, the above translations show that, in particular for number restrictions, the variable-free syntax of Description Logics is much more concise. As can be seen from Section 2.3, it also lends itself easily to the development of algorithms. A more detailed analysis of the connection between fragments of ﬁrst-order predicate logic and Description Logics can be found in Chapter 4.

2.2.2 Terminologies

We have seen how we can form complex descriptions of concepts to describe classes of objects Now we introduce terminological axioms which make statements about

how concepts or roles are related to each other. Then we single out deﬁnitions as speciﬁc axioms and identify terminologies as sets of deﬁnitions by which we can introduce atomic concepts as abbreviations or names for complex concepts. If the deﬁnitions in a terminology contain cycles, we may have to adopt ﬁxpoint semantics to make them unequivocal. We discuss for which types of terminologies ﬁxpoint models exist.

2.2.2.1 Terminological axioms

In the most general case, terminological axioms have the form

C ⊑D (R ⊑S) or C ≡D (R ≡S),

where C, D are concepts (and R, S are roles). Axioms of the ﬁrst kind are called inclusions, while axioms of the second kind are called equalities. To simplify the exposition, we deal in the following only with axioms involving concepts. The semantics of axioms is deﬁned as one would expect. An interpretation I satisﬁes an inclusion C ⊑D if CI ⊆DI, and it satisﬁes an equality C ≡D if CI = DI. If T is a set of axioms, then I satisﬁes T iff I satisﬁes each element of T . If I satisﬁes an axiom (resp. a set of axioms), then we say that it is a model of this axiom (resp. set of axioms). Two axioms or two sets of axioms are equivalent if they have the same models.

2.2.2.2 Deﬁnitions

An equality whose left-hand side is an atomic concept is a deﬁnition. Deﬁnitions are used to introduce symbolic names for complex descriptions. For instance, by the axiom

Mother ≡Woman ⊓∃hasChild.Person

we associate to the description on the right-hand side the name Mother. Symbolic names may be used as abbreviations in other descriptions. If, for example, we have deﬁned Father analogously to Mother, we can deﬁne Parent as

Parent ≡Mother ⊔Father.

A set of deﬁnitions should be unequivocal. We call a ﬁnite set of deﬁnitions T a terminology or TBox if no symbolic name is deﬁned more than once, that is, if for every atomic concept A there is at most one axiom in T whose left-hand side is A. Figure 2.2 shows a terminology with concepts concerned with family relationships. Suppose T is a terminology. We divide the atomic concepts occurring in T into two sets, the name symbols NT that occur on the left-hand side of some axiom and the base symbols B that occur only on the right hand side of axioms Name

Woman ≡ Person ⊓Female Man ≡ Person ⊓¬Woman Mother ≡ Woman ⊓∃hasChild.Person Father ≡ Man ⊓∃hasChild.Person Parent ≡ Father ⊔Mother Grandmother ≡ Mother ⊓∃hasChild.Parent MotherWithManyChildren ≡ Mother ⊓⩾3 hasChild MotherWithoutDaughter ≡ Mother ⊓∀hasChild.¬Woman Wife Woman hasHusband.Man

Fig. 2.2. A terminology (TBox) with concepts about family relationships.

symbols are often called deﬁned concepts and base symbols primitive concepts.2

We expect that the terminology deﬁnes the name symbols in terms of the base symbols, which now we make more precise. A base interpretation for T is an interpretation that interprets only the base symbols. Let J be such a base interpretation. An interpretation I that interprets also the name symbols is an extension of J if it has the same domain as J , i.e., I = J , and if it agrees with J for the base symbols. We say that T is deﬁnitorial if every base interpretation has exactly one extension that is a model of T . In other words, if we know what the base symbols stand for, and T is deﬁnitorial, then the meaningofthenamesymbolsiscompletelydetermined.Obviously,ifaterminology is deﬁnitorial, then every equivalent terminology is also deﬁnitorial. The question whether a terminology is deﬁnitorial or not is related to the question whether or not its deﬁnitions are cyclic. For instance, the terminology that consists of the the single axiom

Human′ ≡Animal ⊓∀hasParent.Human′ (2.1)

contains a cycle, which in this special case is very simple. In general, we deﬁne cycles in a terminology T as follows. Let A, B be atomic concepts occurring in T . We say that A directly uses B in T if B appears on the right-hand side of the deﬁnition of A, and we deﬁne uses to be the transitive closure of the relation directly uses. Then T contains a cycle iff there exists an atomic concept in T that uses itself. Otherwise, T is called acyclic. Unique extensions need not exist if a terminology contains cycles. Consider, for instance, the terminology that contains only Axiom (2.1). Here, Human′ is a name symbol and Animal and hasParent are base symbols. For an interpretation where hasParent relates every animal to its progenitors, many extensions are possible to interpret Human′ in a such a way that the axiom is satisﬁed: Human′ can, among others, be interpreted as the set of all animals, as some species, or any other set of animals with the property that for each animal it contains also its progenitors.

2 Note that some papers use the notion “primitive concept” with a different meaning; e.g., synonymous with what ll t i t t d t th ( t i ) l ft h d id f t i l i

Woman ≡ Person ⊓Female Man ≡ Person ⊓¬(Person ⊓Female) Mother ≡ (Person ⊓Female) ⊓∃hasChild.Person Father ≡ (Person ⊓¬(Person ⊓Female)) ⊓∃hasChild.Person Parent ≡ ((Person ⊓¬(Person ⊓Female)) ⊓∃hasChild.Person) ⊔((Person ⊓Female) ⊓∃hasChild.Person)

Grandmother ≡ ((Person ⊓Female) ⊓∃hasChild.Person) ⊓∃hasChild.(((Person ⊓¬(Person ⊓Female)) ⊓∃hasChild.Person) ⊔((Person ⊓Female) ⊓∃hasChild.Person)) MotherWithManyChildren ≡ ((Person ⊓Female) ⊓∃hasChild.Person) ⊓⩾3 hasChild MotherWithoutDaughter ≡ ((Person ⊓Female) ⊓∃hasChild.Person) ⊓∀hasChild.(¬(Person ⊓Female)) Wife ≡ (Person ⊓Female)

hasHusband.(Person (Person Female))

Fig. 2.3. The expansion of the Family TBox in Figure 2.2.

In contrast, if a terminology T is acyclic, then it is deﬁnitorial. The reason is that we can expand through an iterative process the deﬁnitions in T by replacing each occurrence of a name on the right-hand side of a deﬁnition by the concepts that it stands for. Since there is no cycle in the set of deﬁnitions, the process eventually stops and we end up with a terminology T ′ consisting solely of deﬁnitions of the form A ≡C′, where C′ contains only base symbols and no name symbols. We call T ′ the expansion of T . Note that the size of the expansion can be exponen- tial in the size of the original terminology [Nebel, 1990b]. The Family TBox in Figure 2.2 is acyclic. Therefore, we can compute the expansion, which is shown in Figure 2.3.

Proposition 2.1 Let T be an acyclic terminology and T ′ be its expansion. Then

(i) T and T ′ have the same name and base symbols; (ii) T and T ′ are equivalent; (iii) both T and T ′ are deﬁnitorial.

Proof Let T1 be a terminology. Suppose A ≡C and B ≡D are deﬁnitions in T1 such that B occurs in C. Let C′ be the concept obtained from C by replacing each occurrence of B in C by D, and let T2 be the terminology obtained from T1 by replacing the deﬁnition A ≡C by A ≡C′. Then both terminologies have the same name and base symbols. Moreover, since T2 has been obtained from T1 by replacing equals by equals, both terminologies have the same models. Since T ′

is obtained from T by a sequence of replacement steps like the ones above, this proves claims (i) and (ii). Suppose now that J is an interpretation of the base symbols. We extend it to an interpretation I that covers also the name symbols by setting AI C′J if A ≡C′

is the deﬁnition of A in T ′. Clearly, I is a model of T ′, and it is the only extension of J that is a model of T ′. This shows that T ′ is deﬁnitorial. Moreover, T is deﬁnitorial as well, since it is equivalent to T ′.

It is characteristic of acyclic terminologies, in a sense to be made more precise, to uniquely deﬁne the name symbols in terms of the base symbols. Of course, there are also terminologies with cycles that are deﬁnitorial. Consider for instance the one consisting of the axiom

A ≡ ∀R.B ⊔∃R.(A ⊓¬A), (2.2)

which has a cycle. However, since ∃R.(A ⊓¬A) is equivalent to the bottom concept, Axiom (2.2) is equivalent to the acyclic axiom

A ≡ ∀R.B. (2.3)

This example is typical of the general situation.

Theorem 2.2 Every deﬁnitorial ALC-terminology is equivalent to an acyclic terminology.

The theorem is a reformulation of Beth’s Deﬁnability Theorem [Gabbay, 1972] for the modal propositional logic Kn, which, as shown by Schild [1991], is a notational variant of ALC.

2.2.2.3 Fixpoint semantics for terminological cycles

Under the semantics we have studied so far, which is essentially the semantics of ﬁrst-order logic, terminologies have deﬁnitorial effect only if they are essentially acyclic. Following Nebel [1991], we shall call this semantics descriptive semantics to distinguish it from the ﬁxpoint semantics introduced below. Fixpoint semantics are motivated by the fact that there are situations where intuitively cyclic deﬁni- tions are meaningful and the intuition can be captured by least or greatest ﬁxpoint semantics.

Example 2.3 Suppose that we want to specify the concept of a “man who has only male descendants”, for short Momd. In particular, such a man is a Mos, that is, a “man who has only sons”. A Mos can be deﬁned without cycles as

Mos ≡ Man ⊓∀hasChild.Man.

For a Momd, however, we want to make a statement about the ﬁllers of the transitive closure of the role hasChild. Here a recursive deﬁnition of Momd seems to be natural A man having only male descendants is himself a man and all his children

are men having only male descendants:

Momd ≡ Man ⊓∀hasChild.Momd. (2.4)

In order to achieve the desired meaning, we have to interpret this deﬁnition under an appropriateﬁxpointsemantics. Weshallshowbelowthatgreatestﬁxpointsemantics captures our intuition here.

Cycles also appear when we want to model recursive structures, e.g., binary trees.3

Example 2.4 We suppose that there is a set of objects that are Trees and a binary relation has-branch between objects that leads from a tree to its subtrees. Then the binary trees are the trees with at most two subtrees that are themselves binary trees:

BinaryTree ≡ Tree ⊓⩽2 has-branch ⊓∀has-branch.BinaryTree.

As with the deﬁnition of Momo, a ﬁxpoint semantics will yield the desired meaning. However, for this example we have to use least ﬁxpoint semantics.

We now give a formal deﬁnition of ﬁxpoint semantics. In a terminology T , every name symbol A occurs exactly once as the left-hand side of an axiom A ≡C. Therefore, we can view T as a mapping that associates to a name symbol A the concept description T (A) = C. With this notation, an interpretation I is a model of T if, and only if, AI = (T (A))I. This characterization has the ﬂavor of a ﬁxpoint equation. We exploit this similarity to introduce a family of mappings such that an interpretation is a model of T iff it is a ﬁxpoint of such a mapping. Let T be a terminology, and let J be a ﬁxed base interpretation of T . By ExtJ we denote the set of all extensions of J . Let TJ : ExtJ →ExtJ be the mapping that maps the extension I to the extension TJ (I) deﬁned by ATJ (I) = (T (A))I for each name symbol A. Now, I is a ﬁxpoint of TJ iff I = TJ (I), i.e., iff AI = ATJ (I) for all name symbols. This means that, for every deﬁnition A ≡C in T , we have AI = ATJ (I) = (T (A))I = CI,whichmeansthatI isamodelofT .Thisprovesthefollowingresult.

Proposition 2.5 Let T be a terminology, I be an interpretation, and J be the restriction of I to the base symbols of T . Then I is a model of T if, and only if, I is a ﬁxpoint of TJ .

According to the preceding proposition, a terminology T is deﬁnitorial iff every base interpretation J has a unique extension that is a ﬁxpoint of TJ .

3 Th f ll i l i t k f [N b l 1991]

Example 2.6 To get a feel for why cyclic terminologies are not deﬁnitorial, we discuss as an example the terminology T Momd that consists only of Axiom (2.4). Consider the base interpretation J deﬁned by

J = {Charles1, Charles2, . . .} ∪{James1, . . . , JamesLast}, ManJ = J , hasChildJ = {(Charlesi, Charles(i+1)) | i ≥1} ∪ {(Jamesi, James(i+1)) | 1 ≤i < Last}.

This means that the Charles dynasty does not die out, whereas there is a last member of the James dynasty. We want to identify the ﬁxpoints of T Momd J . Note that an individual with- out children, i.e., without ﬁllers of hasChild, is always in the interpretation of ∀hasChild.Momd, no matter how Momd is interpreted. Therefore, if I is a ﬁxpoint extension of J , then JamesLast is in (∀hasChild.Momd)I, and thus in MomdI. We conclude that every James is a Momd. Let I1 be the extension of J such that MomdI1 comprises exactly the James dynasty. Then it is easy to check that I1 is a ﬁxpoint. If, in addition to the James dynasty, some Charles is a Momd, then all the members of the Charles dynasty before and after him must belong to the concept Momd. One can easily check that the extension I2 that interprets Momd as the entire domain is also a ﬁxpoint, and that there is no other ﬁxpoint.

In order to give deﬁnitorial effect to a cyclic terminology T , we must single out a particular ﬁxpoint of the mapping TJ if there are more than one. To this end, we deﬁne a partial ordering “⪯” on the extensions of J . We say that I ⪯I′ if AI ⊆AI′ for every name symbol in T . In the above example, Momd is the only name symbol. Since MomdI1 ⊆MomdI2, we have I1 ⪯I2. A ﬁxpoint I of TJ is the least ﬁxpoint (lfp) if I ⪯I′ for every other ﬁxpoint I′. We say that I is a least ﬁxpoint model of T if I is the least ﬁxpoint of TJ for some base interpretation J . Under least ﬁxpoint semantics we only admit the least ﬁxpoint models of T as intended interpretations. Greatest ﬁxpoints (gfp), greatest ﬁxpoint models, and greatest ﬁxpoint semantics are deﬁned analogously. In the Momd example, I1 is the least and I2 the greatest ﬁxpoint of TJ .

2.2.2.4 Existence of ﬁxpoint models

Least and greatest ﬁxpoint models need not exist for every terminology.

Example 2.7 As a simple example, consider the axiom

A ≡ A (2 5)

If I is a model of this axiom, then AI = I \ AI, which implies I = ∅, an absurdity. A terminology containing Axiom (2.5) thus does not have any models, and therefore also no gfp (lfp) models. There are also cases where models (i.e., ﬁxpoints) exist, but there is neither a least one nor a greatest one. As an example, consider the terminology T with the single axiom

A ≡ ∀R.¬A. (2.6)

Let J be the base interpretation with J = {a, b} and RJ = {(a, b), (b, a)}. Then there are two ﬁxpoint extensions I1, I2, deﬁned by AI1 = {a} and AI2 = {b}. However, they are not comparable with respect to “⪯”.

In order to identify terminologies with the property that for every base interpre- tation there exists a least and a greatest ﬁxpoint extension, we draw upon results from lattice theory. Recall that a lattice is complete if every family of elements has a least upper bound. On ExtJ we have introduced the partial ordering “⪯”. For a family of interpreta- tions (Ii)i∈I in ExtJ we deﬁne I0 =  i∈I Ii as the pointwise union of the Iis, that is, for every name symbol A we have AI0 =  i∈I AIi. Then I0 is the least upper bound of the Iis, which shows that (ExtJ , ⪯) is a complete lattice. A function f : L →L on a lattice (L, ⪯) is monotone if f (x) ⪯f (y) whenever x ⪯y. Tarski’s Fixpoint Theorem [Tarski, 1955] says that for a monotone function on a complete lattice the set of ﬁxpoints is nonempty and itself forms a complete lattice. In particular, there is a least and a greatest ﬁxpoint. We deﬁne that a terminology T is monotone if the mapping TJ is monotone for all base interpretations J . By Tarski’s theorem, such terminologies have greatest and least ﬁxpoints. However, to apply the theorem, we must be able to recognize monotone terminologies. A simple syntactic criterion is the following. We call a terminology negation-free if no negation occurs in it. By an induction over the depth of concept descriptions one can check that every negation-free ALCN-terminology is monotone.

Proposition 2.8 If T is a negation-free terminology and J a base interpretation, then there exist extensions of J that are an lfp-model and a gfp-model of T , respectively.

Negation-free terminologies are not the most general class of terminologies having least and greatest ﬁxpoints. We have seen in Proposition 2.1 that acyclic terminologies are deﬁnitorial and thus for a given base interpretation admit only a

single extension that is a model, which then is both a least and a greatest ﬁxpoint model. We obtain a more reﬁned criterion for the existence of least and greatest ﬁxpoints if we pay attention to the interplay between cycles and negation. To this end, we associate to a terminology T a dependency graph GT , whose nodes are the name symbols in T . If T contains the axiom A ≡C, then for every occurrence of the name symbol A′ in C, there is an arc from A to A′ in GT . Arcs are labeled as positive and negative. The arc from A to A′ is positive if A′ occurs in C in the scope of an even number of negations, and it is negative if A′ occurs in the scope of an odd number of negations. A sequence of nodes A1, . . . , An is a path if there is an arc in GT from Ai to Ai+1 for all i = 1, . . . , n −1. A path is a cycle if A1 = An.

Proposition 2.9 Let T be a terminology such that each cycle in GT contains an even number of negative arcs. Then T is monotone.

We call a terminology satisfying the precondition of this proposition syntactically monotone.

2.2.2.5 Terminologies with inclusion axioms

For certain concepts we may be unable to deﬁne them completely. In this case, we can still state necessary conditions for concept membership using an inclusion. We call an inclusion whose left-hand side is atomic a specialization. For example, if a (male) knowledge engineer thinks that the deﬁnition of “woman” in our example TBox (Figure 2.2) is not satisfactory, but if he also feels that he is not able to deﬁne the concept “woman” in all detail, he can require that every woman is a person with the specialization

Woman ⊑Person. (2.7)

If we also allow specializations in a terminology, then the terminology loses its deﬁnitorial effect, even if it is acyclic. A set of axioms T is a generalized terminology if the left-hand side of each axiom is an atomic concept and for every atomic concept there is at most one axiom where it occurs on the left-hand side. We shall transform a generalized terminology T into a regular terminology ¯T , containing deﬁnitions only, such that ¯T is equivalent to T in a sense that will be speciﬁed below. We obtain ¯T from T by choosing for every specialization A ⊑C in T a new base symbol ¯A and by replacing the specialization A ⊑C with the deﬁnition A ≡¯A ⊓C. The terminology ¯T is the normalization of T .

If a TBox contains the specialization (2.7), then the normalization contains the deﬁnition

Woman ≡Woman ⊓Person.

Intuitively, the additional base symbol Woman stands for the qualities that distinguish a woman among persons. Thus, normalization results in a TBox with a deﬁnition for Woman that is similar to the one in the Family TBox.

Proposition 2.10 Let T be a generalized terminology and ¯T its normalization.

r Every model of ¯T is a model of T . r For every model I of T there is a model ¯I of ¯T that has the same domain as I and agrees with I on the atomic concepts and roles in T .

Proof The ﬁrst claim holds because a model ¯I of ¯T satisﬁes A ¯I = ( ¯A ⊓C) ¯I = ¯A ¯I ∩C ¯I, which implies A ¯I ⊆C ¯I. Conversely, if I is a model of T , then the extension ¯I of I, deﬁned by ¯A ¯I = AI, is a model of ¯T , because AI ⊆CI implies AI = AI ∩CI = ¯A ¯I ∩C ¯I, and therefore ¯I satisﬁes A ≡¯A ⊓C.

Thus, in theory, inclusion axioms do not add to the expressivity of terminolo- gies. However, in practice, they are a convenient means to introduce terms into a terminology that cannot be deﬁned completely.

2.2.3 World descriptions

The second component of a knowledge base, in addition to the terminology or TBox, is the world description or ABox.

2.2.3.1 Assertions about individuals

In the ABox, one describes a speciﬁc state of affairs of an application domain in terms of concepts and roles. Some of the concept and role atoms in the ABox may be deﬁned names of the TBox. In the ABox, one introduces individuals, by giving them names, and one asserts properties of these individuals. We denote individual names by a, b, c. Using concepts C and roles R, one can make assertions of the following two kinds in an ABox:

C(a), R(b, c).

By the ﬁrst kind, called concept assertions, one states that a belongs to (the inter- pretation of) C. By the second kind, called role assertions, one states that c is a ﬁller of the role R for b. For instance, if PETER, PAUL, and MARY are individual

MotherWithoutDaughter(MARY) Father(PETER) hasChild(MARY, PETER) hasChild(PETER, HARRY) hasChild(MARY, PAUL)

Fig. 2.4. A world description (ABox).

names, then Father(PETER) means that Peter is a father, and hasChild(MARY, PAUL) means that Paul is a child of Mary. An ABox, denoted by A, is a ﬁnite set of such assertions. Figure 2.4 shows an example of an ABox. In a simpliﬁed view, an ABox can be seen as an instance of a relational databasewithonlyunaryorbinaryrelations.However,contrarytothe“closed-world semantics” of classical databases, the semantics of ABoxes is an “open-world se- mantics”,sincenormallyknowledgerepresentationsystemsareappliedinsituations where one cannot assume that the knowledge in the KB is complete.4 Moreover, the TBox imposes semantic relationships between the concepts and roles in the ABox that do not have counterparts in database semantics. We give a semantics to ABoxes by extending interpretations to individual names. From now on, an interpretation I = (I, ·I) not only maps atomic concepts and roles to sets and relations, but in addition maps each individual name a to an element aI ∈I. We assume that distinct individual names denote distinct objects. Therefore, this mapping has to respect the unique name assumption (UNA), that is, if a, b are distinct names, then aI ̸= bI. The interpretation I satisﬁes the concept assertion C(a) if aI ∈CI, and it satisﬁes the role assertion R(a, b) if (aI, bI) ∈RI. An interpretation satisﬁes the ABox A if it satisﬁes each assertion in A. In this case we say that I is a model of the assertion or of the ABox. Finally, I satisﬁes an assertion α or an ABox A with respect to a TBox T if in addition to being a model of α or of A, it is a model of T . Thus, a model of A and T is an abstraction of a concrete world where the concepts are interpreted as subsets of the domain as required by the TBox and where the membership of the individuals to concepts and their relationships with one another in terms of roles respect the assertions in the ABox.

2.2.3.2 Individual names in the description language

Sometimes, it is convenient to allow individual names (also called nominals) not only in the ABox, but also in the description language. Some concept constructors employing individuals occur in systems and have been investigated in the literature. The most basic one is the “set” (or one-of) constructor, written

{a1, . . . , an},

4 W di i li ti f thi diff i ti i S b ti 2 2 4 4

where a1, . . . , an are individual names. As one would expect, such a set concept is interpreted as

{a1, . . . , an}I = {aI 1 , . . . , aI n }. (2.8)

With sets in the description language one can for instance deﬁne the concept of permanent members of the UN security council as {CHINA, FRANCE, RUSSIA,

UK, USA}. In a language with the union constructor “⊔”, a constructor {a} for singleton sets alone adds sufﬁcient expressiveness to describe arbitrary ﬁnite sets since, according to the semantics of the set constructor in Equation (2.8), the concepts {a1, . . . , an} and {a1} ⊔· · · ⊔{an} are equivalent. Another constructor involving individual names is the “ﬁlls” constructor

R : a,

for a role R. The semantics of this constructor is deﬁned as

(R : a)I = {d ∈I | (d, aI) ∈RI}, (2.9)

that is, R : a stands for the set of those objects that have a as a ﬁller of the role R. To a description language with singleton sets and full existential quantiﬁcation, “ﬁlls” does not add anything new, since Equation (2.9) implies that R : a and ∃R.{a} are equivalent. We note, ﬁnally, that “ﬁlls” allows one to express role assertions through concept assertions: an interpretation satisﬁes R(a, b) iff it satisﬁes (∃R.{b})(a).

2.2.4 Inferences

A knowledge representation system based on Description Logics is able to perform speciﬁc kinds of reasoning. As said before, the purpose of a knowledge representa- tion system goes beyond storing concept deﬁnitions and assertions. A knowledge base – comprising TBox and ABox – has a semantics that makes it equivalent to a set of axioms in ﬁrst-order predicate logic. Thus, like any other set of axioms, it contains implicit knowledge that can be made explicit through inferences. For example, from the TBox in Figure 2.2 and the ABox in Figure 2.4 one can conclude that Mary is a grandmother, although this knowledge is not explicitly stated as an assertion. The different kinds of reasoning performed by a DL system (see Chapter 8) are deﬁned as logical inferences. In the following, we shall discuss these inferences, ﬁrst for concepts, then for TBoxes and ABoxes, and ﬁnally for TBoxes and ABoxes together. It will turn out that there is one main inference problem, namely the consistency check for ABoxes to which all other inferences can be reduced

2.2.4.1 Reasoning tasks for concepts

When modeling a domain, a knowledge engineer constructs a terminology, say T , by deﬁning new concepts, possibly in terms of others that have been deﬁned be- fore. During this process, it is important to ﬁnd out whether a newly deﬁned concept makes sense or whether it is contradictory. From a logical point of view, a concept makes sense for us if there is some interpretation that satisﬁes the axioms of T (that is, a model of T ) such that the concept denotes a nonempty set in that interpreta- tion. A concept with this property is said to be satisﬁable with respect to T and unsatisﬁable otherwise. Checking satisﬁability of concepts is a key inference. As we shall see, a number of other important inferences for concepts can be reduced to (un)satisﬁability. For instance, in order to check whether a domain model is correct, or to optimize queries that are formulated as concepts, we may want to know whether some concept is more general than another one: this is the subsumption problem. A concept C is subsumed by a concept D if in every model of T the set denoted by C is a subset of the set denoted by D. Algorithms that check subsumption are also employed to organize the concepts of a TBox in a taxonomy according to their generality. Further interesting relationships between concepts are equivalence and disjointness. These properties are formally deﬁned as follows. Let T be a TBox.

Satisﬁability A concept C is satisﬁable with respect to T if there exists a model I of T such that CI is nonempty. In this case we say also that I is a model of C. Subsumption A concept C is subsumed by a concept D with respect to T if CI ⊆ DI for every model I of T . In this case we write C ⊑T D or T |= C ⊑D. Equivalence Two concepts C and D are equivalent with respect to T if CI = DI

for every model I of T . In this case we write C ≡T D or T |= C ≡D. Disjointness Two concepts C and D are disjoint with respect to T if CI ∩DI = ∅ for every model I of T .

If the TBox T is clear from the context, we sometimes drop the qualiﬁcation “with respect to T ”. We also drop the qualiﬁcation in the special case where the TBox is empty, and we simply write |= C ⊑D if C is subsumed by D, and |= C ≡D if C and D are equivalent.

Example 2.11 With respect to the TBox in Figure 2.2, Person subsumes Woman, both Woman and Parent subsume Mother, and Mother subsumes Grandmother. Moreover, Woman and Man, and Father and Mother are disjoint. The subsumption relationships follow from the deﬁnitions because of the semantics of “⊓” and “⊔”. That Man is disjoint from Woman is due to the fact that Man is subsumed by the negation of Woman

Traditionally, the basic reasoning mechanism provided by DL systems checked the subsumption of concepts. This, in fact, is sufﬁcient to implement also the other inferences, as can be seen by the following reductions.

Proposition 2.12 (Reduction to Subsumption) For concepts C, D we have

(i) C is unsatisﬁable ⇔C is subsumed by ⊥; (ii) C and D are equivalent ⇔C is subsumed by D and D is subsumed by C; (iii) C and D are disjoint ⇔C ⊓D is subsumed by ⊥.

The statements also hold with respect to a TBox.

All description languages implemented in actual DL systems provide the inter- section operator “⊓” and almost all of them contain an unsatisﬁable concept. Thus, most DL systems that can check subsumption can perform all four inferences de- ﬁned above. If, in addition to intersection, a system allows one to form the negation of a description, one can reduce subsumption, equivalence, and disjointness of concepts to the satisﬁability problem (see also Smolka [1988]).

Proposition 2.13 (Reduction to Unsatisﬁability) For concepts C, D we have

(i) C is subsumed by D ⇔C ⊓¬D is unsatisﬁable; (ii) C and D are equivalent ⇔both (C ⊓¬D) and (¬C ⊓D) are unsatisﬁable; (iii) C and D are disjoint ⇔C ⊓D is unsatisﬁable.

The statements also hold with respect to a TBox.

The reduction of subsumption can easily be understood if one recalls that, for sets M, N, we have M ⊆N iff M \ N = ∅. The reduction of equivalence is correct because C and D are equivalent if, and only if, C is subsumed by D and D is subsumed by C. Finally, the reduction of disjointness is just a rephrasing of the deﬁnition. Because of the above proposition, in order to obtain decision procedures for any of the four inferences we have discussed, it is sufﬁcient to develop algorithms that decide the satisﬁability of concepts, provided the language for which we can decide satisﬁability supports conjunction as well as negation of arbitrary concepts. In fact, this observation motivated researchers to study description languages in which, for every concept, one can also form the negation of that con- cept [Smolka, 1988; Schmidt-Schauß and Smolka, 1991; Donini et al., 1991b; 1997a]. The approach that considers satisﬁability checking as the principal infer- ence gave rise to a new kind of algorithms for reasoning in Description Logics

which can be understood as specialized tableau calculi (see Section 2.3 in this chapter and Chapter 3). Also, the most recent generation of DL systems, like Kris [Baader and Hollunder, 1991b], Crack [Bresciani et al., 1995], Fact [Horrocks, 1998b], Dlp [Patel-Schneider, 1999], and Race [Haarslev and M¨oller, 2001e], are based on satisﬁability checking, and a considerable amount of research work is spent on the development of efﬁcient implementation techniques for this ap- proach [Baader et al., 1994; Horrocks, 1998b; Horrocks and Patel-Schneider, 1999; Haarslev and M¨oller, 2001c]. In an AL-language without full negation, subsumption and equivalence cannot be reduced to unsatisﬁability in the simple way shown in Proposition 2.13 and therefore these inferences may be of different complexity. As seen in Proposition 2.12, from the viewpoint of worst-case complexity, sub- sumption is the most general inference for any AL-language. The next proposition shows that unsatisﬁability is a special case of each of the other problems.

Proposition 2.14 (Reducing Unsatisﬁability) Let C be a concept. Then the fol- lowing are equivalent:

(i) C is unsatisﬁable; (ii) C is subsumed by ⊥; (iii) C and ⊥are equivalent; (iv) C and ⊤are disjoint.

The statements also hold with respect to a TBox.

From Propositions 2.12 and 2.14 we see that, in order to obtain upper and lower complexity bounds for inferences on concepts in AL-languages, it sufﬁces to as- sess lower bounds for unsatisﬁability and upper bounds for subsumption. More precisely, for each AL-language, an upper bound for the complexity of the sub- sumption problem is also an upper bound for the complexity of the unsatiﬁability, the equivalence, and the disjointness problem. Moreover, a lower bound for the complexity of the unsatiﬁability problem is also a lower bound for the complexity of the subsumption, the equivalence, and the disjointness problem.

2.2.4.2 Eliminating the TBox

In applications, concepts usually come in the context of a TBox. However, for developing reasoning procedures it is conceptually easier to abstract from the TBox or, what amounts to the same, to assume that it is empty. We show that, if T is an acyclic TBox, we can always reduce reasoning problems with respect to T to problems with respect to the empty TBox. As we have seen in Proposition 2.1, T is equivalent to its expansion T ′. Recall that in the expansion every deﬁnition is of the form A ≡D such that D contains only base symbols not

name symbols. Now, for each concept C we deﬁne the expansion of C with respect to T as the concept C′ that is obtained from C by replacing each occurrence of a name symbol A in C by the concept D, where A ≡D is the deﬁnition of A in T ′, the expansion of T . For example, we obtain the expansion of the concept

Woman ⊓Man (2.10)

with respect to the TBox in Figure 2.2 by considering the expanded TBox in Figure 2.3, and replacing Woman and Man by the right-hand sides of their deﬁni- tions in this expansion. This results in the concept

Person ⊓Female ⊓Person ⊓¬(Person ⊓Female). (2.11)

We can readily deduce a number of facts about expansions. Since the expansion C′

is obtained from C by replacing names by descriptions in such a way that both are interpreted in the same way in any model of T , it follows that

r C ≡T C′.

Hence, C is satisﬁable w.r.t. T iff C′ is satisﬁable w.r.t. T . However, C′ contains no deﬁned names, and thus C′ is satisﬁable w.r.t. T iff it is satisﬁable. This yields that

r C is satisﬁable w.r.t. T iff C′ is satisﬁable.

If D is another concept, then we have also D ≡T D′. Thus, C ⊑T D iff C′ ⊑T D′, and C ≡T D iff C′ ≡T D′. Again, since C′ and D′ contain only base symbols, this implies

r T |= C ⊑D iff |= C′ ⊑D′; r T |= C ≡D iff |= C′ ≡D′.

By similar arguments we can show that

r C and D are disjoint w.r.t. T iff C′ and D′ are disjoint.

Summing up, expanding concepts with respect to an acyclic TBox allows one to get rid of the TBox in reasoning problems. Going back to our example from above, this means that, in order to verify whether Man and Woman are disjoint with respect to the Family TBox, which amounts to checking whether Man ⊓Woman is unsatisﬁable, it sufﬁces to check that the concept (2.11) is unsatisﬁable. Expanding concepts may be computationally costly, since in the worst case the size of T ′ is exponential in the size of T , and therefore C′ may be larger than C by a factor that is exponential in the size of T . A complexity analysis of the difﬁculty of reasoning with respect to TBoxes shows that the expansion of deﬁnitions is a

source of complexity that cannot always be avoided (see Subsection 2.3.3 of this chapter and Chapter 3).

2.2.4.3 Reasoning tasks for ABoxes

After a knowledge engineer has designed a terminology and has used the reasoning services of the DL system to check that all concepts are satisﬁable and that the expected subsumption relationships hold, the ABox can be ﬁlled with assertions about individuals. We recall that an ABox contains two kinds of assertions, concept assertions of the form C(a) and role assertions of the form R(a, b). Of course, the representation of such knowledge has to be consistent, because otherwise – from the viewpoint of logic – one could draw arbitrary conclusions from it. If, for example, the ABox contains the assertions Mother(MARY) and Father(MARY), the system should be able to ﬁnd out that, together with the Family TBox, these statements are inconsistent. In terms of our model-theoretic semantics we can easily give a formal deﬁnition of consistency. An ABox A is consistent with respect to a TBox T , if there is an interpretation that is a model of both A and T . We simply say that A is consistent if it is consistent with respect to the empty TBox. For example, the set of assertions {Mother(MARY), Father(MARY)} is consistent (with respect to the empty TBox), because without any further restrictions on the interpretation of Mother and Father, the two concepts can be interpreted in such a way that they have a common element. However, the assertions are not consistent with respect to the Family TBox, since in every model of it, Mother and Father are interpreted as disjoint sets. Similarly as for concepts, checking the consistency of an ABox with respect to an acyclic TBox can be reduced to checking an expanded ABox. We deﬁne the expansion of A with respect to T as the ABox A′ that is obtained from A by replacing each concept assertion C(a) in A by the assertion C′(a), where C′ is the expansion of C with respect to T .5 In every model of T , a concept C and its expansion C′ are interpreted in the same way. Therefore, A′ is consistent w.r.t. T iff A is so. However, since A′ does not contain a name symbol deﬁned in T , it is consistent w.r.t. T iff it is consistent. We conclude:

r A is consistent w.r.t. T iff its expansion A′ is consistent.

A technique to check the consistency of ALCN-ABoxes is discussed in Subsec- tion 2.3.2.

5 We expand only concept assertions because the description language considered until now does not provide constructors for role descriptions and therefore we have not considered TBoxes with role deﬁnitions. If the description language is richer, and TBoxes contain also role deﬁnitions, then they clearly have to be taken into t i th d ﬁiti f i

Other inferences that we are going to introduce can also be deﬁned with respect to a TBox or for an ABox alone. As in the case of consistency, reasoning tasks for ABoxes with respect to acyclic TBoxes can be reduced to reasoning on expanded ABoxes. For the sake of simplicity, we shall give only deﬁnitions of inferences with ABoxes alone, and leave it to the reader to formulate the appropriate generalization to inferences with respect to TBoxes and to verify that they can be reduced to inferences about expansions, provided the TBox is acyclic. Over an ABox A, one can pose queries about the relationships between concepts, roles and individuals. The prototypical ABox inference on which such queries are based is instance checking, or the check whether an assertion is entailed by an ABox. We say that an assertion α is entailed by A and we write A |= α, if every interpretation that satisﬁes A, that is, every model of A, also satisﬁes α. If α is a role assertion, instance checking is easy, since our description language does not contain constructors to form complex roles. If α is of the form C(a), we can reduce instance checking to the consistency problem for ABoxes because there is the following connection:

r A |= C(a) iff A ∪{¬C(a)} is inconsistent.

Also reasoning about concepts can be reduced to consistency checking. We have seen in Proposition 2.13 that the important reasoning problems for concepts can be reduced to that of deciding whether a concept is (un)satisﬁable. Similarly, concept satisﬁability can be reduced to ABox consistency because for every concept C we have

r C is satisﬁable iff {C(a)} is consistent,

where a is an arbitrarily chosen individual name. Conversely, Schaerf [1994b] has shown that ABox consistency can be reduced to concept satisﬁability in languages with the “set” and the “ﬁlls” constructor. If these constructors are not available, however, then instance checking may be harder than the satisﬁability and the sub- sumption problem [Donini et al., 1994b]. For applications, more complex inferences than consistency and instance check- ing are usually required. If we consider a knowledge base as a means to store information about individuals, we may want to know all individuals that are in- stances of a given concept description C, that is, we use the description language to formulate queries. In our example, we may want to know from the system all parents that have at least two children – for instance, because they are entitled to a speciﬁc family tax break. The retrieval problem is, given an ABox A and a concept C, to ﬁnd all individuals a such that A |= C(a). A non-optimized algorithm for a retrieval query can be realized by testing for each individual occurring in the ABox whether it is an instance of the query concept C

The dual inference to retrieval is the realization problem: given an individual a and a set of concepts, ﬁnd the most speciﬁc concepts C from the set such that A |= C(a). Here, the most speciﬁc concepts are those that are minimal with respect to the subsumption ordering ⊑. Realization can, for instance, be used in systems that generate natural language if terms are indexed by concepts and if a term as precise as possible is to be found for an object occurring in a discourse.

2.2.4.4 Closed- vs. open-world semantics

Often, an analogy is established between databases on the one hand and DL knowl- edge bases on the other hand (see also Chapter 16). The schema of a database is compared to the TBox and the database instance with the actual data is compared to the ABox. However, the semantics of ABoxes differs from the usual semantics of database instances. While a database instance represents exactly one interpretation, namely the one where classes and relations in the schema are interpreted by the objects and tuples in the instance, an ABox represents many different interpreta- tions, namely all its models. As a consequence, absence of information in a database instance is interpreted as negative information, while absence of information in an ABox only indicates lack of knowledge. For example, if the only assertion about Peter is hasChild(PETER, HARRY), then in a database this is understood as a representation of the fact that Peter has only one child, Harry. In an ABox, the assertion only expresses that, in fact, Harry is a child of Peter. However, the ABox has several models, some in which Harry is the only child and others in which he has brothers or sisters. Consequently, even if one also knows (by an assertion) that Harry is male, one cannot deduce that all of Peter’s children are male. The only way of stating in an ABox that Harry is the only child is by doing so explicitly, that is by adding the assertion (⩽1 hasChild)(PETER). This means that, while the information in a database is always understood to be complete, the information in an ABox is in general viewed as being incomplete. The semantics of ABoxes is therefore sometimes characterized as an “open-world” semantics, while the traditional semantics of databases is characterized as a “closed-world” semantics. This view has consequences for the way queries are answered. Essentially, a query is a description of a class of objects. In our setting, we assume that queries are concept descriptions. A database (in the sense introduced above) is a listing of a single ﬁnite interpretation. A ﬁnite interpretation, say I, could be written up as a set of assertions of the form A(a) and R(b, c), where A is an atomic concept and R an atomic role. Such a set looks syntactically like an ABox, but is not an ABox because of the difference in semantics. Answering a query, represented by a complex concept C, over that database amounts to computing CI as it was deﬁned in Section 2 2 1 From a logical point of view this means that query evaluation in

hasChild(JOCASTA, hasChild(JOCASTA, hasChild(OEDIPUS, POLYNEIKES) hasChild(POLYNEIKES, THERSANDROS) Patricide(OEDIPUS) Patricide(THERSANDROS)

OEDIPUS) POLYNEIKES)

Fig. 2.5. The Oedipus ABox Aoe.

a database is not logical reasoning, but ﬁnite model checking (i.e., evaluation of a formula in a ﬁxed ﬁnite model). Since an ABox represents possibly inﬁnitely many interpretations, namely its models, query answering is more complex: it requires nontrivial reasoning. Here we are only concerned with semantical issues (algorithmic aspects will be treated in Section 2.3). To illustrate the difference between a semantics that identiﬁes a database with a single model, and the open-world semantics of ABoxes, we discusstheso-calledOedipusexample,whichhasstimulatedanumberoftheoretical developments in DL research.

Example 2.15 The example is based on the Oedipus story from ancient Greek mythology. In a nutshell, the story recounts how Oedipus killed his father, married his mother Jocasta, and had children with her, among them Polyneikes. Finally, Polyneikes also had children, among them Thersandros. We suppose the ABox Aoe in Figure 2.5 represents some rudimentary facts about these events. For the sake of the example, our ABox asserts that Oedipus is a patricide and that Thersandros is not, which is represented using the atomic concept Patricide. Suppose now that we want to know from the ABox whether Jocasta has a child that is a patricide and that itself has a child that is not a patricide. This can be expressed as the entailment problem

Aoe |= (∃hasChild.(Patricide ⊓∃hasChild.¬Patricide))(JOCASTA) ?

One may be tempted to reason as follows. Jocasta has two children in the ABox. One, Oedipus, is a patricide. He has one child, Polyneikes. But nothing tells us that Polyneikes is not a patricide. So, Oedipus is not the child we are looking for. The other child is Polyneikes, but again, nothing tells us that Polyneikes is a patricide. So, Polyneikes is also not the child we are looking for. Based on this reasoning, one would claim that the assertion about Jocasta is not entailed. However, the correct reasoning is different. All the models of Aoe can be divided into two classes, one in which Polyneikes is a patricide, and another one in which he is not. In a model of the ﬁrst kind, Polyneikes is the child of Jocasta that is a patricide and has a child, namely Thersandros, that isn’t. In a model of the second kind, Oedipus is the child of Jocasta that is a patricide and has a child, namely Polyneikes, that isn’t Thus in all models Jocasta has a child that is a patricide and that itself has

a child that is not a patricide (though this is not always the same child). This means that the assertion (∃hasChild.(Patricide ⊓∃hasChild.¬Patricide))(JOCASTA) is indeed entailed by Aoe.

As this example shows, open-world reasoning may require case analyses. As will be explained in more detail in Chapter 3, this is one of the reasons why inferences in Description Logics are often more complex than query answering in databases.

2.2.5 Rules

The knowledge bases we have discussed so far consist of a TBox T and an ABox A. We denote such a knowledge base as a pair K = (T , A). In some DL systems, such as Classic [Brachman et al., 1991] or Loom [MacGregor, 1991a], in addition to terminologies and world descriptions, one can also use rules to express knowledge. The simplest variant of such rules is an expression of the form

C ⇒D,

where C, D are concepts. The meaning of such a rule is “if an individual is proved to be an instance of C, then derive that it is also an instance of D”. Such rules are often called trigger rules. Operationally, the semantics of a ﬁnite set R of trigger rules can be described by a forward reasoning process. Starting with an initial knowledge base K, a series of knowledge bases K(0), K(1), . . . is constructed, where K(0) = K and K(i+1) is obtained from K(i) by adding a new assertion D(a) whenever R contains a rule C ⇒D such that K(i) |= C(a) holds, but K(i) does not contain D(a). This process eventually halts because the initial knowledge base contains only ﬁnitely many individuals and there are only ﬁnitely many rules. Hence, there are only ﬁnitely many assertions D(a) that can possibly be added. The result of the rule applications is a knowledge base K(n) that has the same TBox as K(0) and whose ABox is augmented by the membership assertions introduced by the rules. We call this ﬁnal knowledge base the procedural extension of K and denote it by ¯K. It is easy to see that this procedural extension is independent of the order of rule applications. Consequently, a set of trigger rules R uniquely speciﬁes how to generate, for each knowledge base K, an extended knowledge base ¯K. The semantics of a knowledge base K, augmented by a set of trigger rules, can thus be understood as the set of models of ¯K. This deﬁnes the semantics of trigger rules only operationally. It would be prefer- able to specify the semantics declaratively and then to prove that the extension computed with the trigger rules correctly represents this semantics. It might be tempting to use the declarative semantics of inclusion axioms as semantics for rules

However, this does not correctly reﬂect the operational semantics given above. An important difference between the trigger rule C ⇒D and the inclusion axiom C ⊑D is that the trigger rule is not equivalent to its contrapositive ¬D ⇒¬C. In addition, when applying trigger rules one does not make a case analysis. For example, the inclusions C ⊑D and ¬C ⊑D imply that every object belongs to D, whereas neither of the trigger rules C ⇒D and ¬C ⇒D applies to an individual a for which neither C(a) nor ¬C(a) can be proven. In order to capture the meaning of trigger rules in a declarative way, we must augment Description Logics by an operator K, which does not refer to objects in the domain, but to what the knowledge base knows about the domain. Therefore, K is an epistemic operator. More information on epistemic operators in Description Logics can be found in Chapter 6. To introduce the K operator, we enrich both the syntax and the semantics of de- scription languages. Originally, the K operator was deﬁned for ALC [Donini et al., 1992b; 1998a]. In this subsection, we discuss only how to extend the basic language AL. For other languages, one can proceed analogously (see also Chapter 6). First, we add one case to the syntax rule in Subsection 2.2.1.1 that allows us to construct epistemic concepts:

C, D −→ KC (epistemic concept).

Intuitively, the concept KC denotes those objects for which the knowledge base knows that they are instances of C. Next, using K, we translate trigger rules C ⇒D into inclusion axioms

KC ⊑D. (2.12)

Intuitively, the K operator in front of the concept C has the effect that the axiom is only applicable to individuals that appear in the ABox and for which ABox and TBox imply that they are instances of C. Such a restricted applicability prevents the inclusion axiom from inﬂuencing satisﬁability or subsumption relationships between concepts. In the sequel, we will deﬁne a formal semantics for the operator K that has exactly this effect. A rule knowledge base is a triple K = (T , A, R), where T is a TBox, A is an ABox, and R is a set of rules written as inclusion axioms of the form (2.12). The procedural extension of such a triple is the knowledge base ¯K = (T , ¯A) that is obtained from (T , A) by applying the trigger rules as described above. The semantics of epistemic inclusions will be deﬁned in such a way that it applies only to individuals in the knowledge base that provably are instances of C, but not to arbitrary domain elements, which would be the case if we dropped K. The semantics will go beyond ﬁrst-order logic because we not only have to interpret concepts, roles and individuals but also have to model the knowledge of a knowledge base The

fact that a knowledge base has knowledge about the domain can be understood in such a way that it considers only a subset W of the set of all interpretations as possible states of the world. Those individuals that are interpreted as elements of C under all interpretations in W are then “known” to be in C. To make this formal, we modify the deﬁnition of ordinary (ﬁrst-order) interpre- tations by assuming that:

(i) there is a ﬁxed countably inﬁnite set  that is the domain of every interpretation (common domain assumption); (ii) there is a mapping γ from the individuals to the domain elements that ﬁxes the way individuals are interpreted (rigid term assumption).

The common domain assumption guarantees that all interpretations speak about the same domain. The rigid term assumption allows us to identify each individual symbol with exactly one domain element. These assumptions do not essentially reduce the number of possible interpretations. As a consequence, properties like satisﬁability and subsumption of concepts are the same independently of whether we deﬁne them with respect to arbitrary interpretations or those that satisfy the above assumptions. Now, we deﬁne an epistemic interpretation as a pair (I, W), where I is a ﬁrst- order interpretation and W is a set of ﬁrst-order interpretations, all satisfying the above assumptions. Every epistemic interpretation gives rise to a unique map- ping ·I,W associating concepts and roles with subsets of  and  × , respec- tively. For ⊤, ⊥, atomic concepts, negated atomic concepts, and atomic roles, ·I,W

agrees with ·I. For intersections, value restrictions, and existential quantiﬁcations, the deﬁnition is similar to that of ·I:

(C ⊓D)I,W = CI,W ∩DI,W

(∀R.C)I,W = {a ∈ | ∀b. (a, b) ∈RI,W →b ∈CI,W} (∃R.⊤)I,W = {a ∈ | ∃b. (a, b) ∈RI,W}.

For other constructors, ·I,W can be deﬁned analogously. Note that for a concept C without an occurrence of K, the sets CI,W and CI are identical. The set of in- terpretations W comes into play when we deﬁne the semantics of the epistemic operator:

(KC)I,W = 

J ∈W CJ ,W.

It would also be possible to allow the operator K to occur in front of roles and to deﬁne the semantics of role expressions of the form KR analogously. However, since epistemic roles are not needed to explain the semantics of rules, we restrict ourselves to epistemic concepts

An epistemic interpretation (I, W) satisﬁes an inclusion C ⊑D if CI,W ⊆ DI,W, and an equality C ≡D if CI,W = DI,W. It satisﬁes an assertion C(a) if aI,W = γ (a) ∈CI,W, and an assertion R(a, b) if (aI,W, bI,W) = (γ (a), γ (b)) ∈ RI,W. It satisﬁes a rule knowledge base K = (T , A, R) if it satisﬁes every axiom in T , every assertion in A, and every rule in R. An epistemic model for a rule knowledge base K is a maximal nonempty set W of ﬁrst-order interpretations such that, for each I ∈W, the epistemic interpretation (I, W) satisﬁes K. Note that, if (T , A) is ﬁrst-order satisﬁable, then the set of all ﬁrst-order models of (T , A) is the only epistemic model of the rule knowledge base K = (T , A, ∅), whose rule set is empty. A similar statement holds for arbitrary rule knowledge bases. One can show that, if W1 and W2 are epistemic models, then the union W1 ∪W2 is one, too, which implies W1 = W2 because of the maximality of epis- temic models.

Proposition 2.16 Let K = (T , A, R) be a rule knowledge base such that (T , A) is ﬁrst-order satisﬁable. Then K has a unique epistemic model.

Example 2.17 Let R consist of the rule

KStudent ⊑∀eats.JunkFood. (2.13)

The rule states that “those individuals that are known to be students eat only junk food”. We consider the rule knowledge base K1 = (∅, A1, R), where

A1 = {Student(PETER)}.

Let us determine the epistemic model W of K1. Every ﬁrst-order interpretation I ∈W must satisfy A1. Therefore, in every such I, we have that Student(PETER) is true, and thus Peter is known to be a student. Since W satisﬁes Rule (2.13), the assertion ∀eats.JunkFood(PETER) also holds in every I. For any other domain element a ∈, there is at least one interpretation in W where a is not a student. Thus, Peter is the only domain element to which the rule applies. Summing up, the epistemic model of K1 consists exactly of the ﬁrst-order models of A1 ∪{∀eats.JunkFood(PETER)}. Next we demonstrate with this example that the epistemic semantics for rules disallows contrapositive reasoning. We consider the rule knowledge base K2 = (∅, A2, R), where

A2 = {¬∀eats.JunkFood(PETER)}.

In this case ∀eats JunkFood(PETER) is true in every ﬁrst order interpretation of

the epistemic model W. However, because of the maximality of W, there is at least one interpretation in W in which Peter is a student and another one where Peter is not a student. Therefore, Peter is not known to be a student. Thus, the epistemic model of K2 consists exactly of the ﬁrst-order models of A2. The rule is satisﬁed because the antecedent is false.

Clearly, the procedural extension of a rule knowledge base K contains only assertions that must be satisﬁed by the epistemic model of K. It can be shown that the assertions added to K by the rule applications are in fact, as stated in the following proposition, a ﬁrst-order representation of the information that is implicit in the rules (see [Donini et al., 1998a] for a proof).

Proposition 2.18 Let K = (T , A, R) be a rule knowledge base. If (T , A) is ﬁrst- order satisﬁable, then the epistemic model of K consists precisely of the ﬁrst-order models of the procedural extension ¯K = (T , ¯A).

2.3 Reasoning algorithms

In Subsection 2.2.4 we have seen that all the relevant inference problems can be reduced to the consistency problem for ABoxes, provided that the Description Logic at hand allows conjunction and negation. However, the description lan- guages of all the early and also of some of the present day DL systems do not allow negation. For such Description Logics, subsumption of concepts can usu- ally be computed by so-called structural subsumption algorithms, i.e., algorithms that compare the syntactic structure of (possibly normalized) concept descriptions. In the ﬁrst subsection, we will consider such algorithms in more detail. While they are usually very efﬁcient, they are only complete for rather simple languages with little expressivity. In particular, Description Logics with (full) negation and disjunction cannot be handled by structural subsumption algorithms. For such lan- guages, so-called tableau-based algorithms have turned out to be very useful. In the area of Description Logics, the ﬁrst tableau-based algorithm was presented by Schmidt-Schauß and Smolka [1991] for satisﬁability of ALC-concepts. Since then, this approach has been employed to obtain sound and complete satisﬁability (and thus also subsumption) algorithms for a great variety of Description Logics ex- tending ALC (see, e.g., [Hollunder et al., 1990; Hollunder and Baader, 1991a; Donini et al., 1997a; Baader and Sattler, 1999] for languages with number restrictions; [Baader, 1991] for transitive closure of roles and [Sattler, 1996; Horrocks and Sattler, 1999] for transitive roles; and [Baader and Hanschke, 1991a; Hanschke, 1992; Haarslev et al., 1999] for constructors that allow one to refer to concrete domains such as numbers) In addition it has been extended to the

consistency problem for ABoxes [Hollunder, 1990; Baader and Hollunder, 1991b; Donini et al., 1994b; Haarslev and M¨oller, 2000], and to TBoxes allowing general sets of inclusion axioms and more [Buchheit et al., 1993a; Baader et al., 1996]. In the second subsection, we will ﬁrst present a tableau-based satisﬁability algorithm for ALCN-concepts, then show how it can be extended to an algorithm for the consistency problem for ABoxes, and ﬁnally explain how general inclusion axioms can be taken into account. The third subsection is concerned with reasoning w.r.t. acyclic and cyclic terminologies. Instead of designing new algorithms for reasoning in Description Logics, one can also try to reduce the problem to a known inference problem in logics (see also Chapter 4). For example, decidability of the inference problems for ALC and many other Description Logics can be obtained as a consequence of the known decidability result for the two-variable fragment of ﬁrst-order predicate logic. The language L2 consists of all formulae of ﬁrst-order predicate logic that can be built with the help of predicate symbols (including equality) and constant symbols (but without function symbols) using only the variables x, y. Decidability of L2 has been shown in [Mortimer, 1975]. It is easy to see that, by appropriately re-using variable names, any concept description of the language ALC can be translated into an L2-formula with one free variable (see [Borgida, 1996] for details). A direct translation of the concept description ∀R.(∃R.A) yields the formula ∀y.(R(x, y) → (∃z.(R(y, z) ∧A(z)))). Since the subformula ∃z.(R(y, z) ∧A(z)) does not contain x, this variable can be re-used: renaming the bound variable z to x yields the equivalent formula ∀y.(R(x, y) →(∃x.(R(y, x) ∧A(x)))), which uses only two variables. This connection between ALC and L2 shows that any extension of ALC by constructors that can be expressed with the help of only two variables yields a decidable Description Logic. Number restrictions and composition of roles are examples of constructors that cannot be expressed within L2. Number restrictions can, however, be expressed in C2, the extension of L2 by counting quantiﬁers, which has recently been shown to be decidable [Gr¨adel et al., 1997b; Pacholski et al., 1997]. It should be noted, however, that the complexity of the decision procedures obtained this way is usually higher than necessary: for example, the satisﬁability problem for L2 is NExpTime-complete, whereas satisﬁability of ALC- concept descriptions is “only” PSpace-complete. Decision procedures with lower complexity can be obtained by using the con- nection between Description Logics and propositional modal logics. Schild [1991] was the ﬁrst to observe that the language ALC is a syntactic variant of the propo- sitional multi-modal logic K, and that the extension of ALC by transitive closure of roles [Baader, 1991] corresponds to Propositional Dynamic Logic (pdl). In particular, some of the algorithms used in propositional modal logics for decid- ing satisﬁability are very similar to the tableau based algorithms newly developed

for Description Logics. This connection between Description Logics and modal logics has been used to transfer decidability results from modal logics to Descrip- tion Logics [Schild, 1993; 1994; De Giacomo and Lenzerini, 1994a; 1994b] (see also Chapter 5). Instead of using tableau-based algorithms, decidability of certain propositional modal logics (and thus of the corresponding Description Logics) can also be shown by establishing the ﬁnite model property (see, e.g., [Fitting, 1993], Section 1.14) of the logic (i.e., showing that a formula or concept is satisﬁable iff it is satisﬁable in a ﬁnite interpretation) or by employing tree automata (see, e.g., [Vardi and Wolper, 1986]).

2.3.1 Structural subsumption algorithms

These algorithms usually proceed in two phases. First, the descriptions to be tested for subsumption are normalized, and then the syntactic structure of the normal forms is compared. For simplicity, we ﬁrst explain the ideas underlying this approach for the small language FL0, which allows conjunction (C ⊓D) and value restrictions (∀R.C).Subsequently,weshowhowthebottomconcept(⊥),atomicnegation(¬A), and number restrictions (⩽n R and ⩾n R) can be handled. Evidently, FL0 and its extension by bottom and atomic negation are sublanguages of AL, while adding number restrictions to the resulting language yields the Description Logic ALN. An FL0-concept description is in normal form iff it is of the form

A1 ⊓· · · ⊓Am ⊓∀R1.C1 ⊓· · · ⊓∀Rn.Cn,

where A1, . . . , Am are distinct concept names, R1, . . . , Rn are distinct role names, and C1, . . . , Cn are FL0-concept descriptions in normal form. It is easy to see that any description can be transformed into an equivalent one in normal form, using associativity, commutativity and idempotence of ⊓, and the fact that the descriptions ∀R.(C ⊓D) and (∀R.C) ⊓(∀R.D) are equivalent.

Proposition 2.19 Let

A1 ⊓· · · ⊓Am ⊓∀R1.C1 ⊓· · · ⊓∀Rn.Cn

be the normal form of the FL0-concept description C, and

B1 ⊓· · · ⊓Bk ⊓∀S1.D1 ⊓· · · ⊓∀Sl.Dl

the normal form of the FL0-concept description D. Then C ⊑D iff the following two conditions hold:

(i) for all i, 1 ≤i ≤k, there exists j, 1 ≤j ≤m such that Bi = A j. (ii) For all i, 1 ≤i ≤l, there exists j, 1 ≤j ≤n such that Si = R j and C j ⊑Di.

It is easy to see that this characterization of subsumption is sound (i.e., the “if” direction of the proposition holds) and complete (i.e., the “only if” direction of the proposition holds as well). This characterization yields an obvious recursive algo- rithm for computing subsumption, which can easily be shown to be of polynomial time complexity [Levesque and Brachman, 1987]. If we extend FL0 by language constructors that can express unsatisﬁable con- cepts, then we must, on the one hand, change the deﬁnition of the normal form. On the other hand, the structural comparison of the normal forms must take into account that an unsatisﬁable concept is subsumed by every concept. The simplest Description Logic where this occurs is FL⊥, the extension of FL0 by the bottom concept ⊥. An FL⊥-concept description is in normal form iff it is ⊥or of the form

A1 ⊓· · · ⊓Am ⊓∀R1.C1 ⊓· · · ⊓∀Rn.Cn,

where A1, . . . , Am are distinct concept names different from ⊥, R1, . . . , Rn are distinct role names, and C1, . . . , Cn are FL⊥-concept descriptions in normal form. Again, such a normal form can easily be computed. In principle, one just computes the FL0-normal form of the description (where ⊥is treated as an ordinary concept name): B1 ⊓· · · ⊓Bk ⊓∀R1.D1 ⊓· · · ⊓∀Rn.Dn. If one of the Bis is ⊥, then replace the whole description by ⊥. Otherwise, apply the same procedure recursively to the D js. For example, the FL0-normal form of ∀R.∀R.B ⊓A ⊓∀R.(A ⊓∀R.⊥) is

A ⊓∀R.(A ⊓∀R.(B ⊓⊥)),

which yields the FL⊥-normal form

A ⊓∀R.(A ⊓∀R.⊥).

The structural subsumption algorithm for FL⊥works just like the one for FL0, with the only difference that ⊥is subsumed by any description. For example, ∀R.∀R.B ⊓ A ⊓∀R.(A ⊓∀R.⊥) ⊑∀R.∀R.A ⊓A ⊓∀R.A since the recursive comparison of their FL⊥-normal forms A ⊓∀R.(A ⊓∀R.⊥) and A ⊓∀R.(A ⊓∀R.A) ﬁnally leads to the comparison of ⊥and A. The extension of FL⊥by atomic negation (i.e., negation applied to concept names only) can be treated similarly. During the computation of the normal form, negated concept names are just treated like concept names. If, however, a name and its negation occur on the same level of the normal form, then ⊥is added, which can then be treated as described above. For example, ∀R.¬A ⊓A ⊓∀R.(A ⊓∀R.B) is ﬁrst transformed into A ⊓∀R.(A ⊓¬A ⊓∀R.B), then into A ⊓∀R.(⊥⊓A ⊓¬A ⊓ ∀R.B), and ﬁnally into A ⊓∀R.⊥. The structural comparison of the normal forms treats negated concept names just like concept names.

Finally, if we consider the language ALN, the additional presence of number restrictions leads to a new type of conﬂict. On the one hand, as in the case of atomic negation, number restrictions may be in conﬂict with each other (e.g., ⩾2 R and ⩽1 R). On the other hand, at-least restrictions ⩾n R for n ≥1 are in conﬂict with value restrictions ∀R.⊥that prohibit role successors. When computing the normal form, one can again treat number restrictions like concept names, and then take care of the new types of conﬂicts by introducing ⊥and using it for normalization as described above. During the structural comparison of normal forms, one must also take into account inherent subsumption relationships between number restrictions (e.g., ⩾n R ⊑⩾m R iff n ≥m). A more detailed description of a structural subsumption algorithm working on a graph-like data structure for a language extending ALN can be found in [Borgida and Patel-Schneider, 1994]. For larger Description Logics, structural subsumption algorithms usually fail to be complete. In particular, they cannot treat disjunction, full negation, and full existential restriction ∃R.C. For languages including these constructors, the tableau approach to designing subsumption algorithms has turned out to be quite useful.

2.3.2 Tableau algorithms

Instead of directly testing subsumption of concept descriptions, these algorithms use negation to reduce subsumption to (un)satisﬁability of concept descriptions: as we have seen in Subsection 2.2.4, C ⊑D iff C ⊓¬D is unsatisﬁable. Before describing a tableau-based satisﬁability algorithm for ALCN in more detail, we illustrate the underlying ideas by two simple examples. Let A, B be concept names, and let R be a role name. As a ﬁrst example, assume that we want to know whether (∃R.A) ⊓(∃R.B) is subsumed by ∃R.(A ⊓B). This means that we must check whether the concept description

C = (∃R.A) ⊓(∃R.B) ⊓¬(∃R.(A ⊓B))

is unsatisﬁable. First, we push all negation signs as far as possible into the description, using De Morgan’s rules and the usual rules for quantiﬁers. As a result, we obtain the description

C0 = (∃R.A) ⊓(∃R.B) ⊓∀R.(¬A ⊔¬B),

which is in negation normal form, i.e., negation occurs only in front of concept names. Then, we try to construct a ﬁnite interpretation I such that CI 0 ̸= ∅. This means that there must exist an individual in I that is an element of CI

The algorithm just generates such an individual, say b, and imposes the constraint b ∈CI 0 on it. Since C0 is the conjunction of three concept descriptions, this means that b must satisfy the following three constraints: b ∈(∃R.A)I, b ∈(∃R.B)I, and b ∈(∀R.(¬A ⊔¬B))I. From b ∈(∃R.A)I we can deduce that there must exist an individual c such that (b, c) ∈RI and c ∈AI. Analogously, b ∈(∃R.B)I implies the existence of an individual d with (b, d) ∈RI and d ∈BI. In this situation, one should not assume that c = d since this would possibly impose too many constraints on the individuals newly introduced to satisfy the existential restrictions on b. Thus:

r For any existential restriction the algorithm introduces a new individual as role ﬁller, and this individual must satisfy the constraints expressed by the restriction.

Since b must also satisfy the value restriction ∀R.(¬A ⊔¬B), and c, d were introduced as R-ﬁllers of b, we obtain the additional constraints c ∈(¬A ⊔¬B)I

and d ∈(¬A ⊔¬B)I. Thus:

r The algorithm uses value restrictions in interaction with already deﬁned role relationships to impose new constraints on individuals.

Now c ∈(¬A ⊔¬B)I means that c ∈(¬A)I or c ∈(¬B)I, and we must choose one of these possibilities. If we assume c ∈(¬A)I, this clashes with the other constraint c ∈AI, which means that this search path leads to an obvious contradic- tion. Thus we must choose c ∈(¬B)I. Analogously, we must choose d ∈(¬A)I in order to satisfy the constraint d ∈(¬A ⊔¬B)I without creating a contradiction to d ∈BI. Thus:

r For disjunctive constraints, the algorithm tries both possibilities in successive attempts. It must backtrack if it reaches an obvious contradiction, i.e., if the same individual must satisfy constraints that are obviously conﬂicting.

In the example, we have now satisﬁed all the constraints without encountering an obvious contradiction. This shows that C0 is satisﬁable, and thus (∃R.A) ⊓(∃R.B) is not subsumed by ∃R.(A ⊓B). The algorithm has generated an interpretation I as witness for this fact: I = {b, c, d}; RI = {(b, c), (b, d)}; AI = {c} and BI = {d}. For this interpretation, b ∈CI 0 . This means that b ∈((∃R.A) ⊓(∃R.B))I, but b ̸∈(∃R.(A ⊓B))I. In our second example, we add a number restriction to the ﬁrst concept of the above example, i.e., we now want to know whether (∃R.A) ⊓(∃R.B) ⊓⩽1 R is subsumed by ∃R.(A ⊓B). Intuitively, the answer should now be “yes” since ⩽1 R in the ﬁrst concept ensures that the R-ﬁller in A coincides with the R-ﬁller in B, and thus there is an R-ﬁller in A ⊓B. The tableau-based satisﬁability algorithm ﬁrst proceeds as above with the only difference that there is the additional constraint

b ∈(⩽1 R)I. In order to satisfy this constraint, the two R-ﬁllers c, d of b must be identiﬁed with each other. Thus:

r If an at-most number restriction is violated then the algorithm must identify different role ﬁllers.

In the example, the individual c = d must belong to both AI and BI, which together with c = d ∈(¬A ⊔¬B)I always leads to a clash. Thus, the search for a counterexample to the subsumption relationship fails, and the algorithm concludes that (∃R.A) ⊓(∃R.B) ⊓⩽1 R ⊑∃R.(A ⊓B).

2.3.2.1 A tableau-based satisﬁability algorithm for ALCN

Before we can describe the algorithm more formally, we need to introduce an appropriate data structure in which to represent constraints like “a belongs to (the interpretation of) C” and “b is an R-ﬁller of a”. The original paper by Schmidt- Schauß and Smolka [1991], and also many other papers on tableau algorithms for Description Logics, introduce the new notion of a constraint system for this purpose. However, if we look at the types of constraints that must be expressed, we see that they can actually be represented by ABox assertions. As we have seen in the second example above, the presence of at-most number restrictions may lead to the identiﬁcation of different individual names. For this reason, we will not impose the unique name assumption on the ABoxes considered by the algorithm. Instead, we allow explicit inequality assertions of the form x ̸ .= y for individual names x, y, with the obvious semantics that an interpretation I satisﬁes x ̸ .= y iff xI ̸= yI. These assertions are assumed to be symmetric, i.e., saying that x ̸ .= y belongs to an ABox A is the same as saying that y ̸ .= x belongs to A. Let C0 by an ALCN-concept in negation normal form. In order to test sat- isﬁability of C0, the algorithm starts with the ABox A0 = {C0(x0)}, and applies consistency-preserving transformation rules (see Figure 2.6) to the ABox until no more rules apply. If the “complete” ABox obtained this way does not contain an obvious contradiction (called clash), then A0 is consistent (and thus C0 is satis- ﬁable), and inconsistent (unsatisﬁable) otherwise. The transformation rules that handle disjunction and at-most restrictions are non-deterministic in the sense that a given ABox is transformed into ﬁnitely many new ABoxes such that the origi- nal ABox is consistent iff one of the new ABoxes is so. For this reason we will consider ﬁnite sets of ABoxes S = {A1, . . . , Ak} instead of single ABoxes. Such a set is consistent iff there is some i, 1 ≤i ≤k, such that Ai is consistent. A rule of Figure 2.6 is applied to a given ﬁnite set of ABoxes S as follows: it takes an element A of S, and replaces it by one ABox A′, by two ABoxes A′ and A′′, or by ﬁnitely many ABoxes Ai, j. The following lemma is an easy consequence of the deﬁnition of the transfor

The →⊓-rule Condition A contains (C1 ⊓C2)(x), but it does not contain both C1(x) and C2(x). Action A′ = A ∪{C1(x), C2(x)}.

The →⊔-rule Condition A contains (C1 ⊔C2)(x), but neither C1(x) nor C2(x). Action A′ = A ∪{C1(x)}, A′′ = A ∪{C2(x)}.

The →∃-rule Condition A contains (∃R.C)(x), but there is no individual name z such that C(z) and R(x, z) are in A. Action A′ = A ∪{C(y), R(x, y)} where y is an individual name not occurring in A.

The →∀-rule Condition A contains (∀R.C)(x) and R(x, y), but it does not contain C(y). Action A′ = A ∪{C(y)}.

The →≥-rule Condition A contains (⩾n R)(x), and there are no individual names z1, . . . , zn such that R(x, zi) (1 ≤i ≤n) and zi ̸ .= zj (1 ≤i < j ≤n) are contained in A. Action A′ = A ∪{R(x, yi) | 1 ≤i ≤n} ∪{yi ̸ .= yj | 1 ≤i < j ≤n}, where y1, . . . , yn are distinct individual names not occurring in A.

The →≤-rule Condition A contains distinct individual names y1, . . . , yn+1 such that (⩽n R)(x) and R(x, y1), . . . , R(x, yn+1) are in A, and yi ̸ .= yj is not in A for some i ̸= j. Action For each pair yi, yj such that i > j and yi ̸ .= yj is not in A, the ABox Ai,j = [yi/yj]A is obtained from A by replacing each occurrence of yi by yj.

Fig. 2.6. Transformation rules of the satisﬁability algorithm.

Lemma 2.20 (Soundness) Assume that S′ is obtained from the ﬁnite set of ABoxes S by application of a transformation rule. Then S is consistent iff S′ is consistent.

The second important property of the set of transformation rules is that the transformation process always terminates:

Lemma 2.21 (Termination) Let C0 be an ALCN-concept description in negation normal form. There cannot be an inﬁnite sequence of rule applications

{{C0(x0)}} →S1 →S2 →· · · .

The main reasons for this lemma to hold are the following.6

Lemma 2.22 Let A be an ABox contained in Si for some i ≥1.

r For every individual x ̸= x0 occurring in A, there is a unique sequence R1, . . . , Rl (l ≥1) of role names and a unique sequence x1, . . . , xl−1 of individual names such that {R1(x0, x1), R2(x1, x2), . . . , Rl(xl−1, x)} ⊆A. In this case, we say that x occurs on level l in A.

r If C(x) ∈A for an individual name x on level l, then the maximal role depth of C (i.e., the maximal nesting of constructors involving roles) is bounded by the maximal role depth of C0 minus l. Consequently, the level of any individual in A is bounded by the maximal role depth of C0. r If C(x) ∈A, then C is a subdescription of C0. Consequently, the number of different concept assertions on x is bounded by the size of C0. r The number of different role successors of x in A (i.e., individuals y such that R(x, y) ∈A for a role name R) is bounded by the sum of the numbers occurring in at-least restrictions in C0 plus the number of different existential restrictions in C0.

Starting with {{C0(x0)}}, we thus obtain after a ﬁnite number of rule applications a set of ABoxes S to which no more rules apply. An ABox A is called complete iff none of the transformation rules applies to it. Consistency of a set of complete ABoxes can be decided by looking for obvious contradictions, called clashes. The ABox A contains a clash iff one of the following three situations occurs:

(i) {⊥(x)} ⊆A for some individual name x; (ii) {A(x), ¬A(x)} ⊆A for some individual name x and some concept name A; (iii) {(⩽n R)(x)} ∪{R(x, yi) | 1 ≤i ≤n + 1} ∪{yi ̸ .= y j | 1 ≤i < j ≤n + 1} ⊆A for individual names x, y1, . . . , yn+1, a nonnegative integer n, and a role name R.

Obviously, an ABox that contains a clash cannot be consistent. Hence, if all the ABoxesin S containaclash,then S isinconsistent,andthusbythesoundnesslemma {C0(x0)} is inconsistent as well. Consequently, C0 is unsatisﬁable. If, however, one of the complete ABoxes in S is clash-free, then S is consistent. By soundness of the rules, this implies consistency of {C0(x0)}, and thus satisﬁability of C0.

Lemma 2.23 (Completeness) Any complete and clash-free ABox A has a model.

This lemma can be proved by deﬁning the canonical interpretation IA induced by A:

(i) the domain IA of IA consists of all the individual names occurring in A; (ii) for all atomic concepts A we deﬁne AIA = {x | A(x) ∈A}; (iii) for all atomic roles R we deﬁne RIA = {(x, y) | R(x, y) ∈A}.

By deﬁnition, IA satisﬁes all the role assertions in A. By induction on the structure of concept descriptions, it is easy to show that it satisﬁes the concept assertions as well. The inequality assertions are satisﬁed since x ̸ .= y ∈A only if x, y are different individual names. The facts stated in Lemma 2.22 imply that the canonical interpretation has the shape of a ﬁnite tree whose depth is linearly bounded by the size of C0 and whose branching factor is bounded by the sum of the numbers occurring in at least

restrictions in C0 plus the number of different existential restrictions in C0. Con- sequently, ALCN has the ﬁnite tree model property, i.e., any satisﬁable concept C0 is satisﬁable in a ﬁnite interpretation I that has the shape of a tree whose root belongs to C0. To sum up, we have seen that the transformation rules of Figure 2.6 reduce satisﬁability of an ALCN-concept C0 (in negation normal form) to consistency of a ﬁnite set S of complete ABoxes. In addition, consistency of S can be decided by looking for obvious contradictions (clashes).

Theorem 2.24 It is decidable whether or not an ALCN-concept is satisﬁable.

2.3.2.2 Complexity issues

The tableau-based satisﬁability algorithm for ALCN presented above may need exponential time and space. In fact, the size of the canonical interpretation built by thealgorithmmaybeexponentialinthesizeoftheconceptdescription.Forexample, consider the descriptions Cn (n ≥1), which are inductively deﬁned as follows:

C1 = ∃R.A ⊓∃R.B, Cn+1 = ∃R.A ⊓∃R.B ⊓∀R.Cn.

Obviously, the size of Cn grows linearly in n. However, given the input description Cn, the satisﬁability algorithm introduced above generates a complete and clash-free ABox whose canonical model is the full binary tree of depth n, and thus consists of 2n+1 −1 individuals. Nevertheless, the satisﬁability algorithm can be modiﬁed such that it needs only polynomial space. The main reason is that different branches of the tree model to be generated by the algorithm can be investigated separately. Since the complexity class NPSpace coincides with PSpace [Savitch, 1970], it is sufﬁcient to describe a non-deterministic algorithm using only polynomial space, i.e., for every non-deterministic rule we may simply assume that the algorithm chooses the correct alternative. In principle, the modiﬁed algorithm works as follows: it starts with {C0(x0)} and

(i) applies the →⊓- and →⊔-rules as long as possible, and checks for clashes of the form A(x0), ¬A(x0) and ⊥(x0); (ii) generates all the necessary direct successors of x0 using the →∃- and the →≥-rule; (iii) generates the necessary identiﬁcations of these direct successors using the →≤-rule, and checks for clashes caused by at-most restrictions; (iv) successively handles the successors in the same way.

Since after identiﬁcation the remaining successors can be treated separately, the algorithm needs to store only one path of the tree model to be generated together

with the direct successors of the individuals on this path and the information which of these successors must be investigated next. We already know that the length of the path is linear in the size of the input description C0. Thus, the only remaining obstacle on our way to a PSpace-algorithm is the fact that the number of direct successors of an individual on the path also depends on the numbers in the at-least restrictions. If we assumed these numbers to be written in base 1 representation (where the size of the representation coincides with the number represented), this would not be a problem. However, for bases larger than 1 (e.g., numbers in decimal notation), the number represented may be exponential in the size of the representation. For example, the representation of 10n −1 requires only n digits in base 10 representation. Thus, we cannot introduce all the successors required by at-least restrictions while only using polynomial space in the size of the concept description if the numbers in this description are written in decimal notation. It turns out, however, that most of the successors required by the at-least restric- tions need not be introduced at all. If an individual x obtains at least one R-successor due to the application of the →∃-rule, then the →≥-rule need not be applied to x for the role R. Otherwise, we simply introduce one R-successor as representative. In order to detect inconsistencies due to conﬂicting number restrictions, we need to add a new type of clash: {(⩽n R)(x), (⩾m R)(x)} ⊆A for nonnegative inte- gers n < m. The canonical interpretation obtained by this modiﬁed algorithm need not satisfy the at-least restrictions in C0. However, it can easily be modiﬁed to an interpretation that does, by duplicating R-successors (more precisely, the whole subtrees starting at these successors).

Theorem 2.25 Satisﬁability of ALCN-concept descriptions is PSpace-complete.

The above argument shows that the problem is in PSpace. The hardness result follows from the fact that the satisﬁability problem is already PSpace-hard for the sublanguage ALC, which can be shown by a reduction from validity of Quantiﬁed Boolean Formulae [Schmidt-Schauß and Smolka, 1991]. Since subsumption and satisﬁability of ALCN-concept descriptions can be reduced to each other in linear time, this also shows that subsumption of ALCN-concept descriptions is PSpace- complete.

2.3.2.3 Extension to the consistency problem for ABoxes

The tableau-based satisﬁability algorithm described in Subsection 2.3.2.1 can easily be extended to an algorithm that decides consistency of ALCN-ABoxes. Let A be an ALCN-ABox such that (w.l.o.g.) all concept descriptions in A are in negation normal form To test A for consistency we ﬁrst add inequality assertions a ̸ . b for

every pair of distinct individual names a, b occurring in A.7 Let A0 be the ABox obtained this way. The consistency algorithm applies the rules of Figure 2.6 to the singleton set {A0}. Soundness and completeness of the rule set can be shown as before. Unfortu- nately, the algorithm need not terminate, unless one imposes a speciﬁc strategy on the order of rule applications. For example, consider the ABox

A0 = {R(a, a), (∃R.A)(a), (⩽1 R)(a), (∀R.∃R.A)(a)}.

By applying the →∃-rule to a, we can introduce a new R-successor x of a:

A1 = A0 ∪{R(a, x), A(x)}.

The →∀-rule adds the assertion (∃R.A)(x), which triggers an application of the →∃-rule to x. Thus, we obtain the new ABox

A2 = A1 ∪{(∃R.A)(x), R(x, y), A(y)}.

Since a has two R-successors in A2, the →≤-rule is applicable to a. By replacing every occurrence of x by a, we obtain the ABox

A3 = A0 ∪{A(a), R(a, y), A(y)}.

Except for the individual names (and the assertion A(a), which is, however, irrele- vant), A3 is identical to A1. For this reason, we can continue as above to obtain an inﬁnite chain of rule applications. We can easily regain termination by requiring that generating rules (i.e., the rules →∃and →≥) may only be applied if none of the other rules is applicable. In the above example, this strategy would prevent the application of the →∃-rule to x in the ABox A1 ∪{(∃R.A)(x)} since the →≤-rule is also applicable. After applying the →≤-rule (which replaces x by a), the →∃-rule is no longer applicable since a already has an R-successor that belongs to A. Using a similar idea, one can reduce the consistency problem for ALCN-ABoxes to satisﬁability of ALCN-concept descriptions [Hollunder, 1996]. In principle, this reduction works as follows: In a preprocessing step, one applies the transformation rules only to old individuals (i.e., individuals present in the original ABox). Subse- quently, one can forget about the role assertions, i.e., for each individual name in the preprocessed ABox, the satisﬁability algorithm is applied to the conjunction of its concept assertions (see [Hollunder, 1996] for details).

Theorem 2.26 Consistency of ALCN-ABoxes is PSpace-complete.

7 Thi t k f th UNA

2.3.2.4 Extension to general inclusion axioms

In the above subsections, we have considered the satisﬁability problem for con- cept descriptions and the consistency problem for ABoxes without an underlying TBox. In fact, for acyclic TBoxes one can simply expand the deﬁnitions (see Sub- section 2.2.4). Expansion is, however, no longer possible if one allows general inclusion axioms of the form C ⊑D, where C and D may be complex descrip- tions. Instead of considering ﬁnitely many such axioms C1 ⊑D1, . . . , Cn ⊑Dn, it is sufﬁcient to consider the single axiom ⊤⊑ C, where

C = (¬C1 ⊔D1) ⊓· · · ⊓(¬Cn ⊔Dn).

The axiom ⊤⊑ C simply says that any individual must belong to the concept C. The tableau algorithm introduced above can easily be modiﬁed such that it takes this axiom into account: all individuals (both the original individuals and the ones newly generated by the →∃-rule and the →≥-rule) are simply asserted to belong to C. However, this modiﬁcation may obviously lead to nontermination of the algorithm. For example, consider what happens if this algorithm is applied to test consistency of the ABox A0 = {A(x0), (∃R.A)(x0)} w.r.t. the axiom ⊤⊑∃R.A: the algorithm generates an inﬁnite sequence of ABoxes A1, A2, . . . and individuals x1, x2, . . . such that Ai+1 = Ai ∪{R(xi, xi+1), A(xi+1), (∃R.A)(xi+1)}. Since all individuals xi receive the same concept assertions as x0, we may say that the algorithms has run into a cycle. Termination can be regained by trying to detect such cyclic computations, and thenblockingtheapplicationofgeneratingrules:theapplicationoftherules→∃and →≥to an individual x is blocked by an individual y in an ABox A iff {D | D(x) ∈ A} ⊆{D′ | D′(y) ∈A}. The main idea underlying blocking is that the blocked individual x can use the role successors of y instead of generating new ones. For example, instead of generating a new R-successor for x1 in the above example, one can simply use the R-successor of x0. This yields an interpretation I with I = {x0, x1}, AI = I, and RI = {(x0, x1), (x1, x1)}. Obviously, I is a model of A0 and of the axiom ⊤⊑∃R.A. To avoid cyclic blocking (of x by y and vice versa), we consider an enumeration of all individual names, and deﬁne that an individual x may only be blocked by individuals y that occur before x in this enumeration. This, together with some other technical assumptions, makes sure that an algorithm using this notion of blocking is sound and complete as well as terminating (see [Buchheit et al., 1993a; Baader et al., 1996] for details). Thus, consistency of ALCN-ABoxes w.r.t. general inclusion axioms is decidable. It should be noted that the algorithm is no longer in PSpace since it may generate role paths of exponential length before blocking occurs In fact even for the language ALC satisﬁability w r t a single general

inclusion axiom is known to be ExpTime-hard [Schild, 1994] (see also Chapter 3). The tableau-based algorithm sketched above is a NExpTime algorithm. However, using the translation technique mentioned at the beginning of this section, it can be shown [De Giacomo, 1995] that ALCN-ABoxes and general inclusion axioms can be translated into pdl, for which satisﬁability can be decided in exponential time. An ExpTime tableau algorithm for ALC with general inclusion axioms was described by Donini and Massacci [2000].

Theorem 2.27 Consistency of ALCN-ABoxes w.r.t. general inclusion axioms is ExpTime-complete.

2.3.2.5 Extension to other language constructors

The tableau-based approach to designing concept satisﬁability and ABox consis- tency algorithms can also be employed for languages with other concept and/or role constructors. In principle, each new constructor requires a new rule, and this rule can usually be obtained by simply considering the semantics of the construc- tor. Soundness of such a rule is often very easy to show. More problematic are completeness and termination since they must also take interactions between dif- ferent rules into account. As we have seen above, termination can sometimes only be obtained if the application of rules is restricted by an appropriate strategy. Of course, one may only impose such a strategy if one can show that it does not destroy completeness.

2.3.3 Reasoning w.r.t. terminologies

Recall that terminologies (TBoxes) are sets of concept deﬁnitions (i.e., equalities of the form A ≡C where A is atomic) such that every atomic concept occurs at most once as a left-hand side. We will ﬁrst comment brieﬂy on the complexity of reasoning w.r.t. acyclic terminologies, and then consider in more detail reasoning w.r.t. cyclic terminologies.

2.3.3.1 Acyclic terminologies

As shown in Subsection 2.2.4, reasoning w.r.t. acyclic terminologies can be reduced to reasoning without terminologies by ﬁrst expanding the TBox, and then replac- ing name symbols by their deﬁnitions in the terminology. Unfortunately, since the expanded TBox may be exponentially larger than the original one [Nebel, 1990b], this increases the complexity of reasoning. Nebel [1990b] also shows that this complexity can, in general, not be avoided: for the language FL0, subsumption be- tween concept descriptions can be tested in polynomial time (see Subsection 2 3 1)

whereas subsumption w.r.t. acyclic terminologies is conp-complete (see also Sub- section 2.3.3.2 below). For more expressive languages, the presence of acyclic TBoxes may or may not increase the complexity of the subsumption problem. For example, subsumption of concept descriptions in the language ALC is PSpace-complete, and so is sub- sumption w.r.t. acyclic terminologies [Lutz, 1999a]. Of course, in order to obtain a PSpace-algorithm for subsumption in ALC w.r.t. acyclic TBoxes, one cannot ﬁrst expand the TBox completely since this might need exponential space. The main idea is that one uses a tableau-based algorithm like the one described in Subsec- tion 2.3.2, with the difference that it receives concept descriptions containing name symbols as input. Expansion is then done on demand: if the tableau-based algo- rithm encounters an assertion of the form A(x), where A is a name occurring on the left-hand side of a deﬁnition A ≡C in the TBox, then it adds the assertion C(x). However, it does not further expand C at this stage. It is not hard to show that this really yields a PSpace-algorithm for satisﬁability (and thus also for subsumption) of concepts w.r.t. acyclic TBoxes in ALC [Lutz, 1999a]. There are, however, extensions of ALC for which this technique no longer works. One such example is the language ALCF, which extends ALC by functional roles as well as agreements and disagreements on chains of functional roles (see Sec- tion 2.4 below). Satisﬁability of concepts is PSpace-complete for this language [Hollunder and Nutt, 1990], but satisﬁability of concepts w.r.t. acyclic terminolo- gies is NExpTime-complete [Lutz, 1999a].

2.3.3.2 Cyclic terminologies

For cyclic terminologies, expansion is no longer possible since it would not termi- nate. If we use descriptive semantics, then cyclic terminologies are a special case of terminologies with general inclusion axioms. Thus, the tableau-based algorithm for handling general inclusion axioms introduced in Subsection 2.3.2.4 can also be usedforcyclicALCN-TBoxeswithdescriptivesemantics.ForcyclicALC-TBoxes with ﬁxpoint semantics, the connection between Description Logics and proposi- tional modal logics turns out to be useful. In fact, syntactically monotone ALC- TBoxes with least or greatest ﬁxpoint semantics can be expressed within the propo- sitional µ-calculus, which is an extension of the propositional multi-modal logic Km by ﬁxpoint operators (see [Schild, 1994; De Giacomo and Lenzerini, 1994b; 1997] and Chapter 5 for details). Since reasoning w.r.t. general inclusion axioms in ALC and reasoning in the propositional µ-calculus are both ExpTime-complete, these reductions yield an ExpTime upper bound for reasoning w.r.t. cyclic termi- nologies in sublanguages of ALC. For less expressive Description Logics, more efﬁcient algorithms can, however, be obtained with the help of techniques based on ﬁnite automata Following [Baader

1996b], we will sketch these techniques for the small language FL0. The results can, however, be extended to the language ALN [K¨usters, 1998]. We will develop the results for FL0 in two steps, starting with an alternative characterization of subsumption between FL0-concept descriptions, and then extending this charac- terization to cyclic TBoxes with greatest ﬁxpoint semantics. Baader [1996b] also considers cyclic FL0-TBoxes with descriptive and with least ﬁxpoint semantics. For these semantics, the characterization of subsumption is more involved; in par- ticular, the characterization of subsumption w.r.t. descriptive semantics depends on ﬁnite automata working on inﬁnite words, so-called B¨uchi automata. Acyclic TBoxes can be seen as a special case of cyclic TBoxes, where all three types of semantics coincide. In Subsection 2.3.1, the equivalence (∀R.C) ⊓(∀R.D) ≡∀R.(C ⊓D) was used as a rewrite rule from left to right in order to compute the structural subsumption normal form of FL0-concept descriptions. If we use this rule in the opposite di- rection, we obtain a different normal form, which we call concept-centered normal form since it groups the concept description w.r.t. concept names (and not w.r.t. role names, as the structural subsumption normal form does). Using this rule, any FL0-concept description can be transformed into an equivalent description that is a conjunction of descriptions of the form ∀R1. · · · ∀Rm.A for m ≥0 (not nec- essarily distinct) role names R1, . . . , Rm and a concept name A. We abbreviate ∀R1. · · · ∀Rm.A by ∀R1 · · · Rm.A, where R1 · · · Rm is viewed as a word over the alphabet of all role names. In addition, instead of ∀w1.A ⊓· · · ⊓∀wl.A we write ∀L.A where L = {w1, . . . , wl} is a ﬁnite set of words over . The term ∀∅.A is considered to be equivalent to the top concept ⊤, which means that it can be added to a conjunction without changing the meaning of the concept. Using these abbre- viations, any pair of FL0-concept descriptions C, D containing the concept names A1, . . . , Ak can be rewritten as

C ≡∀U1.A1 ⊓· · · ⊓∀Uk.Ak and D ≡∀V1.A1 ⊓· · · ⊓∀Vk.Ak,

where Ui, Vi are ﬁnite sets of words over the alphabet of all role names. This normal form provides us with the following characterization of subsumption of FL0-concept descriptions [Baader and Narendran, 1998]:

C ⊑D iff Ui ⊇Vi for all i, 1 ≤i ≤k.

Since the size of the concept-based normal forms is polynomial in the size of the original descriptions, and since the inclusion tests Ui ⊇Vi can also be realized in polynomial time, this yields a polynomial-time decision procedure for subsump- tion in FL0. In fact, as shown in [Baader et al., 1998a], the structural subsumption algorithm for FL0 can be seen as a special implementation of these inclusion tests

S R

S

ε

A C P

A ≡ ∀R.A ⊓∀S.C B ≡ ∀R.∀S.C C ≡ P ⊓∀S.C

RS

B

Fig. 2.7. A TBox and the corresponding automaton.

This characterization of subsumption via inclusion of ﬁnite sets of words can be extended to cyclic TBoxes with greatest ﬁxpoint semantics as follows. A given TBox T can be translated into a ﬁnite automaton8 AT whose states are the concept names occurring in T and whose transitions are induced by the value restrictions occurring in T (see Figure 2.7 for an example and [Baader, 1996b] for the formal deﬁnition). For a name symbol A and a base symbol P in T , the language LAT (A, P) is the set of all words labeling paths in AT from A to P. The languages LAT (A, P) represent all the value restrictions that must be satisﬁed by instances of the concept A. With this intuition in mind, the following characterization of subsumption w.r.t. cyclic FL0-TBoxes with greatest ﬁxpoint semantics should not be surprising:

A ⊑T B iff LAT (A, P) ⊇LAT (B, P) for all base symbols P.

In the example of Fig. 2.7, we have LAT (A, P) = R∗SS∗⊃RSS∗= LAT (B, P), and thus A ⊑T B, but not B ⊑T A. Obviously, the languages LAT (A, P) are regular, and any regular language can be obtained as such a language. Since inclusion of regular languages is a PSpace- complete problem [Garey and Johnson, 1979], this shows that subsumption w.r.t. cyclic FL0-TBoxes with greatest ﬁxpoint semantics is PSpace-complete [Baader, 1996b]. For an acyclic terminology T , the automaton AT is acyclic as well. Since inclusion of languages accepted by acyclic ﬁnite automata is conp-complete, this proves Nebel’s result that subsumption w.r.t. acyclic FL0-TBoxes is conp-complete [Nebel, 1990b].

2.4 Language extensions

In Section 2.2 we have introduced the language ALCN as a prototypical Descrip- tion Logic. For many applications, the expressive power of ALCN is not sufﬁcient. For this reason, various other language constructors have been introduced in the literature and are employed by systems. Roughly, these language extensions can be put into two categories, which (for lack of a better name) we will call “classical”

8 Strictly speaking, we obtain a ﬁnite automaton with word transitions, i.e., transitions that may be labeled by a d th th l tt f

and “nonclassical” extensions. Intuitively, a classical extension is one whose se- mantics can easily be deﬁned within the model-theoretic framework introduced in Section 2.2, whereas deﬁning the semantics of a nonclassical constructor is more problematic and requires an extension of the model-theoretic framework (such as the semantics of the epistemic operator K introduced in Subsection 2.2.5). In this section, we brieﬂy introduce the most important classical extensions of Description Logics. Inference procedures for such expressive Description Logics are discussed in Chapter 5. Nonclassical extensions are the subject of Chapter 6. In addition to constructors that can be used to build complex roles, we will introduce more expressive number restrictions, and constructors that allow one to express relationships between the role-ﬁller sets of different (complex) roles.

2.4.1 Role constructors

Since roles are interpreted as binary relations, it is quite natural to employ the usual operations on binary relations (such as Boolean operators, composition, inverse, and transitive closure) as role-forming constructors. Syntax and semantics of these constructors can be deﬁned as follows:

Deﬁnition 2.28 (Role constructors) Every role name is a role description (atomic role), and if R, S are role descriptions, then R ⊓S (intersection), R ⊔S (union), ¬R (complement), R ◦S (composition), R+ (transitive closure), R−(inverse) are also role descriptions. A given interpretation I is extended to (complex) role descriptions as follows:

(i) (R ⊓S)I = RI ∩SI, (R ⊔S)I = RI ∪SI, (¬R)I = I × I \ RI; (ii) (R ◦S)I = {(a, c) ∈I × I | ∃b. (a, b) ∈RI ∧(b, c) ∈SI}; (iii) (R+)I =  i≥1(RI)i, i.e., (R+)I is the transitive closure of (RI); (iv) (R−)I = {(b, a) ∈I × I | (a, b) ∈RI}.

For example, the union of the roles hasSon and hasDaughter can be used to deﬁne the role hasChild, and the transitive closure of hasChild expresses the role hasDescendants. The inverse of hasChild yields the role hasParent. The complexity of satisﬁability and subsumption of concepts in the language ALCN ⊓(also called ALCNR in the literature), which extends ALCN by in- tersection of roles, has been investigated in [Donini et al., 1997a]. It is shown that these problems are still PSpace-complete, provided that the numbers occur- ring in number restrictions are written in base 1 representation (where the size of the representation coincides with the number represented). Tobies [2001b] shows that this result also holds for non unary coding of numbers Decidability of the

extension of ALCN by the three Boolean operators and the inverse operator is an immediate consequence of the fact that concepts of the extended language can be expressed in C2, i.e., ﬁrst-order predicate logic with two variables and counting quantiﬁers, which is known to be decidable in NExpTime [Gr¨adel et al., 1997b; Pacholski et al., 1997]. Lutz and Sattler [2000a] show that ALC extended by role complement is ExpTime-complete, whereas ALC extended by role intersection and (atomic) role complement is NExpTime-complete. In [Baader, 1991], the Description Logic ALCtrans, which extends ALC by transi- tive closure, composition, and union of roles, has been introduced, and subsumption and satisﬁability of ALCtrans-concepts has been shown to be decidable. Schild’s ob- servation [Schild, 1991] that ALCtrans is just a syntactic variant of Propositional Dynamic Logic (pdl) [Fischer and Ladner, 1979] yields the exact complexity of subsumption and satisﬁability in ALCtrans: they are ExpTime-complete [Fischer and Ladner, 1979; Pratt, 1979; 1980]. The extension of ALCtrans by the inverse con- structor corresponds to converse pdl [Fischer and Ladner, 1979], which can also be shown to be decidable in deterministic exponential time [Vardi, 1985]. Whereas this extension of ALCtrans does not change the properties of the obtained Description Logic in a signiﬁcant way, things become more complex if both number restric- tions and the inverse of roles are added to ALCtrans. Whereas ALCtrans and ALCtrans with inverse still have the ﬁnite model property, ALCtrans extended by inverse and number restrictions does not. Indeed, it is easy to see that the concept

¬A ⊓∃R−.A ⊓(⩽1 R) ⊓∀(R−)+.(∃R−.A ⊓(⩽1 R))

is satisﬁable in an inﬁnite interpretation, but not in a ﬁnite one. Nevertheless, this Description Logic still has an ExpTime-complete subsumption and satisﬁability problem. In fact, in [De Giacomo, 1995], number restrictions, the inverse of roles, and Boolean operators on roles are added to ALCtrans, and ExpTime-decidability is shown by a rather ingenious reduction to the decision problem for ALCtrans. It should be noted, however, that in this work only atomic roles and their inverse may occur in number restrictions, and that the complement of roles is built with respect to a ﬁxed role any, which must contain all other roles, but need not be interpreted as the universal role (i.e., I × I). As we shall see below, allowing more complex roles inside number restrictions may easily cause undecidability.

2.4.2 Expressive number restrictions

There are three different ways in which the expressive power of number restrictions can be enhanced. First, one can consider so-called qualiﬁed number restrictions, where the num- ber restrictions are concerned with role ﬁllers belonging to a certain concept For

example, given the role hasChild, the simple number restrictions introduced above can only state that the number of all children is within certain limits, such as in the concept ⩾2 hasChild ⊓⩽5 hasChild. Qualiﬁed number restrictions can also express that there are at least 2 sons and at most 5 daughters:

⩾2 hasChild.Male ⊓⩽5 hasChild.Female.

Adding qualiﬁed number restrictions to ALC leaves the important inference prob- lems (like subsumption and satisﬁability of concepts, and consistency of ABoxes) decidable: the worst-case complexity is still PSpace-complete. Membership in PSpace was ﬁrst shown for the case where numbers occurring in number re- strictions are written in base 1 representation [Hollunder and Baader, 1991a; Hollunder, 1996]. More recently, this has been proved even for the case of binary (or, equivalently, decimal) representation of numbers [Tobies, 1999c; 2001b]. The language stays decidable if general sets of inclusion axioms are allowed [Buchheit et al., 1993a]. Second, one can allow complex role expressions inside number restrictions. As already mentioned above, allowing the three Boolean operators and the inverse operator in number restrictions of ALCN leaves us within C2, which is known to be decidable. In [Baader and Sattler, 1996b; 1999], languages that allow com- position of roles in number restrictions have been considered.9 The extension of ALC by number restrictions involving composition has a decidable satisﬁability and subsumption problem. On the other hand, if either number restrictions involv- ing composition, union and inverse, or number restrictions involving composition and intersection are added, then satisﬁability and subsumption become undecidable [Baader and Sattler, 1996b; 1999]. For ALCtrans, the extension by number restric- tions involving composition is already undecidable [Baader and Sattler, 1999]. Third,onecanreplacetheexplicitnumbersn innumberrestrictionsbyvariablesα that stand for arbitrary nonnegative integers [Baader and Sattler, 1996a; 1999]. This allows one, for example, to deﬁne the concept of all persons having at least as many daughters as sons, without explicitly saying how many sons and daughters the person has:

Person ⊓⩾α hasDaughter ⊓⩽α hasSon.

The expressive power of this language can further be increased by introducing explicit quantiﬁcation of the numeric variables. For example, it is important to know whether the numeric variables are introduced before or after a value restriction. This is illustrated by the following concept

Person ⊓↓α.(∀hasChild.(⩾α hasChild ⊓⩽α hasChild)),

9 N t th t iti t b d ithi C2

in which introducing the numerical variable before the universal value restriction makes sure that all the children of the person have the same number of children. Here, ↓α stands for an existential quantiﬁcation of α. Universal quantiﬁcation of numerical variables comes in via negation. In [Baader and Sattler, 1996a; 1999] it is shown that ALCN extended by such symbolic number restrictions with universal andexistentialquantiﬁcationofnumericalvariableshasanundecidablesatisﬁability and subsumption problem. If one restricts this language to existential quantiﬁcation of numerical variables and negation on atomic concepts, then satisﬁability becomes decidable, but subsumption remains undecidable.

2.4.3 Role-value-maps

Role-value-maps are a family of very expressive concept constructors, which were, however, available in the original Kl-One system. They allow one to relate the sets of role ﬁllers of role chains.

Deﬁnition 2.29 (Role-value-maps) A role chain is a composition R1 ◦· · · ◦Rn of role names. If R, S are role chains, then R ⊆S and R = S are concepts (role- value-maps). The former is called a containment role-value-map, while the latter is called an equality role-value-map. A given interpretation I is extended to role-value-maps as follows:

(i) (R ⊆S)I = {a ∈I | ∀b. (a, b) ∈RI →(a, b) ∈SI}, (ii) (R = S)I = {a ∈I | ∀b. (a, b) ∈RI ↔(a, b) ∈SI}.

For example, the concept

Person ⊓(hasChild ◦hasFriend ⊆knows)

describes the persons knowing all the friends of their children, and

Person ⊓(marriedTo ◦likesToEat = likesToEat)

describes persons having the same favorite foods as their spouse. Unfortunately, in the presence of role-value-maps, the subsumption problem is undecidable, even if the language allows only conjunction and value restriction as additional constructors [Schmidt-Schauß, 1989] (see also Chapter 3). To avoid this problem, one may restrict attention to role chains of functional roles, also called attributes or features in the literature. An interpretation I interprets the role R as a functional role iff {(a, b), (a, c)} ⊆RI implies b = c. In the following, we assume that the set of role names is partitioned into the set of functional roles and the set of ordinary roles Any interpretation must interpret the functional roles

as such. Usually, we write functional roles with small letters f, g, possibly with index.

Deﬁnition 2.30 (Agreements) If f , g are role chains of functional roles, then f .= g and f ̸ .= g are concepts (agreement and disagreement). A given interpretation I is extended to agreements and disagreements as follows:

(i) ( f .= g)I = {a ∈I | ∃b. (a, b) ∈f I ∧(a, b) ∈gI}, (ii) ( f ̸ .= g)I = {a ∈I | ∃b1, b2. b1 ̸= b2 ∧(a, b1) ∈f I ∧(a, b2) ∈gI}.

In the literature, the agreement constructor is sometimes also called the same-as constructor. Note that, since f , g are role chains between functional roles, there can be at most one role ﬁller for a w.r.t. the respective role chain. Also note that the semantics of agreements and disagreements requires these role ﬁllers to exist (and be equal or distinct) for a to belong to the concept. For example, hasMother, hasFather, and hasLastName with their usual interpre- tation are functional roles, whereas hasParent and hasChild are not. The concept

Person ⊓(hasLastName .= hasMother ◦hasLastName) ⊓(hasLastName ̸ .= hasFather ◦hasLastName)

describes persons whose last name coincides with the last name of their mother, but not with the last name of their father. The restriction to functional roles makes reasoning in ALC extended by agree- ments and disagreements decidable [Hollunder and Nutt, 1990]. A structural sub- sumption algorithm for the language provided by the Classic system, which in- cludes the same-as constructor, can be found in [Borgida and Patel-Schneider, 1994]. However, if general inclusion axioms (or transitive closure of functional roles or cyclic deﬁnitions) are allowed, then agreements and disagreements be- tween chains of functional roles again cause subsumption to become undecidable [Nebel, 1991; Baader et al., 1993]. Additional types of role interaction constructors similar to agreements and role-value-maps are investigated in [Hanschke, 1992].

Acknowledgement

We would like to thank Maarten de Rijke for his pointers to the literature on Beth deﬁnability in modal logics.

3

Complexity of Reasoning

FRANCESCO M. DONINI

Abstract

We present lower bounds on the computational complexity of satisﬁability and subsumption in several Description Logics. We interpret these lower bounds as coming from different “sources of complexity”, which we isolate one by one. We consider both reasoning with simple concept expressions and reasoning with an underlying TBox. We discuss also complexity of instance checking in simple ABoxes. We have tried to enhance clarity and ease of presentation, sometimes sacriﬁcing exhaustiveness for lack of space.

3.1 Introduction

Complexity of reasoning has been one of the major issues in the development of Description Logics. This is because such logics are conceived [Brachman and Levesque, 1984] as the formal speciﬁcation of subsystems for representing knowl- edge, to be used in larger knowledge-based systems. Since using knowledge also means deriving implicit facts from the given ones, the implementation of derivation procedures should take into account the optimality of reasoning algorithms. The studyofoptimalalgorithmsstartsfromtheelicitationofthecomputationalcomplex- ity of the problem the algorithm should solve. Initially, studies about the complexity of reasoning problems in Description Logics were more focused on polynomial- time versus intractable (np- or conp-hard) problems. The idea was that a knowledge representation system based on a Description Logic with polynomial-time infer- ence problems would guarantee timely answers to the rest of the system. However, once systems based on very expressive Description Logics with exponential-time reasoning problems were implemented [Horrocks, 1998b], it was recognized that knowledge bases of realistic size could be processed in reasonable time. This shifted most of the complexity analysis to Description Logics whose reasoning problems are ExpTime hard or worse

This chapter presents some lower bounds on the complexity of basic reasoning tasks in simple Description Logics. The reasoning services taken into account are: ﬁrst, satisﬁability and subsumption of concept expressions alone (no TBox), then the same reasoning services considering a TBox also, and in the last part of the chapter, instance checking w.r.t. an ABox. We show in detail some reductions from problems that are hard for complexity classes np, conp, PSpace, ExpTime, and from semidecidable problems to satis- ﬁability/subsumption in various Description Logics. Then, we show how these reductions can be adapted to other Description Logics as well. In several reductions, we use tableau expansions to prove the correctness of the reduction. Thus, a secondary aim in this chapter is to show how tableaux are useful not only in devising reasoning algorithms and complexity upper bounds – as seen in Chapter 2 – but also in ﬁnding complexity lower bounds. This is because tableaux untangle two different aspects of the computational complexity of reasoning in Description Logics:

r The ﬁrst aspect is the structure of possible models of a concept. Such a structure is – in many Description Logics – a tree of individual names, linked by arcs labeled by roles. We consider such a tree an AND-tree, in the sense that all branches must be followed to obtain a candidate model. Following [Schmidt-Schauß and Smolka, 1991], we call each branch of such a tree a trace. Readers familiar with tableaux terminology should observe that traces are not tableau branches; in fact, they form a structure inside a single tableau branch. r The second aspect is the structure of proofs or refutations. Clearly, if a trace contains an inconsistency – a clash in the terminology set up in Chapter 2—the candidate models containing this trace can be discarded. When all candidate models are discarded this way, we obtain a proof of subsumption, or unsatisﬁability. Hence, the structure of refutations is often best viewed as an OR-tree of traces containing clashes.

Here we have chosen to mark the nodes with AND, OR when considering a sat- isﬁability problem; if either unsatisﬁability or subsumption is considered, AND and OR labels should be exchanged. Before starting with the various results, we elaborate on this subject in the next subsection.

3.1.1 Intuition: sources of complexity

The deterministic version of the calculus for ALCN in Chapter 2 can be seen as exploring an AND–OR tree, where an AND-branching corresponds to the (indepen- dent) check of all successors of an individual, while an OR-branching corresponds to the different choices of application of a nondeterministic rule. Realizing that, one can see that the exponential-time behavior of the calcu- lus is due to two independent origins: the AND branching responsible for the

exponential size of a single candidate model, and the OR-branching, responsible for the exponential number of different candidate models. We call these two differ- ent combinatorial explosions sources of complexity.

3.1.1.1 OR-branching

The OR-branching is due to the presence of disjunctive constructors, which make a concept satisﬁable by more than one model. The obvious disjunctive constructor is ⊔; hence ALU is a good sublanguage to see this source of complexity. Recall that ALU allows one to form concepts using negation of concept names, conjunction ⊓, disjunction ⊔, universal role quantiﬁcation ∀R.C, and unqualiﬁed existential role quantiﬁcation ∃R. This source of complexity is the same that makes propositional satisﬁability np-hard: in fact, satisﬁability in ALU can be trivially proved np-hard by rewriting propositional letters as atomic concepts, ∧as ⊓, and ∨as ⊔. Many proofs of conp-hardness of subsumption were found by exploiting this source of complexity ([Levesque and Brachman, 1987; Nebel, 1988]), by reducing an np- hard problem to non-subsumption. In Subsection 3.2.1, we show how disjunction can also be introduced by combining role restrictions and universal quantiﬁcation, and in Subsection 3.2.2 by combining number restrictions and role intersection.

3.1.1.2 AND-branching

The AND-branching is more subtle. Its exponential behaviour is due to the inter- play of qualiﬁed existential and universal quantiﬁers; hence ALE is now a min- imal sublanguage of ALCN with these features. As mentioned in Chapter 2 one can see the effects of this source of complexity by expanding the tableau {D(x)}, when D is the following concept (whose pattern appears in many papers, from [Schmidt-Schauß and Smolka, 1991], to [Hemaspaandra, 1999]) – see Chapter 2 for its general form:

∃P1.∀P2.∀P3.C11 ⊓ ∃P1.∀P2.∀P3.C12 ⊓ ∀P1.(∃P2.∀P3.C21 ⊓ ∃P2.∀P3.C22 ⊓ ∀P2.(∃P3.C31 ⊓ ∃P3.C32)).

For each level l of nested quantiﬁers, we use a different role Pl (but using the same role R would produce the same results). The structure of the tableau for {D(x)}, which is the candidate model for D, is a binary tree of height 3: the nodes are the individual names, the arcs are given by the Pl-successor relation, and the branches are the traces in the tableau

Each trace ends with an individual that belongs to C1i, C2 j, C3k, for i, j, k ∈ {1, 2}. Hence, a clash may be found independently in each trace, i.e., in each branch of the tree. To verify that this structure is indeed a model, one has to check every AND-branch of it; and branches can be exponentially many in the nesting of quantiﬁers. This source of complexity causes an exponential number of possible refutations to be searched through (each refutation being a trace containing a clash). This second source of complexity is not evident in propositional calculus, but a similar problem appears in predicate calculus – where the interplay of existential and universal quantiﬁers may lead to large models – and in Quantiﬁed Boolean Formulae.

Remark 3.1 For Description Logics that are not closed under negation, a source of complexity could be absent in satisﬁability while it might appear in subsumption. This is because C is subsumed by D iff C ⊓¬D is unsatisﬁable, where ¬D could belong a Description Logic which is more expressive than the DL of C and D.

3.1.2 Overview of the chapter

We ﬁrst present separately the effect of each source of complexity. In the next section, we discuss intractability results stemming from disjunction (OR- branching), which lead to conp-hard lower bounds. We discuss both the case of plain logical disjunction (as the Description Logic FL), and the case of dis- junction arising from alternative identiﬁcation of individuals (ALEN). Then in Section 3.3 we present an np lower bound stemming from AND-branching, namely a Description Logic in which concepts have one candidate model of exponential size. A PSpace lower bound combining the two sources of complexity is pre- sented in Section 3.4, and then in Section 3.5 we show how axioms can com- bine in a succinct way the sources of complexity, leading to ExpTime-hardness of satisﬁability. In Section 3.6 we examine one of the ﬁrst undecidability results found for a Description Logic, using the powerful construct of role-value-maps – now recog- nized as very expressive, because of this result. Finally, we analyze intractability arising from reasoning with individuals in ABoxes (Section 3.7), and add a ﬁnal discussion (Section 3.8) about the signiﬁcance of these results – beyond the initial study of theoretical complexity of reasoning – also for benchmark testing of implemented procedures. Section 3.9, with a list of complexity results for satisﬁability and subsumption, closes the chapter

Table 3.1. Syntax and semantics of the Description Logic FL. For FL−, omit role restriction.

concept expressions semantics

concept name A ⊆I

concept intersection C ⊓D CI ∩DI

limited exist. quant. ∃R {x ∈I | ∃y. (x, y) ∈RI} value restriction ∀R.C {x ∈I | ∀y. (x, y) ∈RI →y ∈CI}

role expressions semantics

role name P ⊆I × I

role restriction R|C {(x, y) ∈I × I | (x, y) ∈RI ∧y ∈CI}

3.2 OR-branching: ﬁnding a model

When the number of candidate models is exponential in the size of the concepts involved, it is a combinatorial problem to ﬁnd the right candidate model to check. In Description Logics, this may lead to np-hardness of satisﬁability, and conp- hardness of subsumption.

3.2.1 Intractability in FL

Brachman and Levesque [1984] (see also [Levesque and Brachman, 1987]) were the ﬁrst to point out that a slight increase in the expressiveness of a Description Logic may result in a drastic change in the complexity of reasoning. They called this effect a “computational cliff” of structured knowledge representation languages. They considered the language FL, which admits concept conjunction, universal role quantiﬁcation, unqualiﬁed existential quantiﬁcation, and role restriction. For readability, the syntax and semantics of FL are recalled in Table 3.1. Role restriction allows one to construct a subrole of a role R, i.e., a role whose extension is a subset of the extension of R. For example, the role child|male may be used for the “son-of ” relation. Observe two properties of role restriction, whose proofs easily follow from the semantics in Table 3.1:

(i) for every role R, the role R|⊤is equivalent to R; (ii) for every role R, and concepts A, C, D, the concept (∀(R|C).A) ⊓(∀(R|D).A) is equiv- alent to ∀(R|(C⊔D)).A.

The second property highlights that disjunction – although not explicitly present in the syntax of the language – arises from semantics. Brachman and Levesque deﬁned also the language FL−, derived from FL by omitting role restriction They ﬁrst showed that for FL−subsumption can be

decided by a structural algorithm, with polynomial-time complexity, similar to the one shown in Chapter 2. Then they showed that subsumption in FL is conp-hard, exhibiting the ﬁrst “computational cliff ” in Description Logics. Since the original proof of conp-hardness is somewhat complex, we give here a simpler proof, found by Calvanese [1990]. The proof is based on the observation that if C1 ⊔· · · ⊔Cn ≡⊤, then, given a role R and a concept A, we have

(∀(R|C1).A) ⊓· · · ⊓(∀(R|Cn).A) ≡ (from (ii)) (3.1) ∀R|(C1⊔···⊔Cn).A ≡ (3.2) ∀R|⊤.A ≡ (from (i)) (3.3) ∀R.A.

Moreover, observe that, for every role Q and every concept C, the disjunction ∃Q ⊔∀Q.C is equivalent to the concept ⊤. Hence ∀(R|∃Q).A ⊓∀(R|∀Q.C).A is equivalent to ∀R.A. These observations are the key to the reduction from tautology checking of propositional 3DNF formulae to subsumption in FL.

Theorem 3.2 Subsumption in FL is conp-hard.

Proof Given an alphabet of propositional variables L = {p1, . . . , pk}, deﬁne a propositional formula F = G1 ∨· · · ∨Gn in 3DNF over L, where each disjunct Gi is made of three literals l1 i ∧l2 i ∧l3 i , and for every i ∈{1, . . . , n}, and j ∈{1, 2, 3}, each literal l j i is either a variable p ∈L, or its negation p. Given a set of role names {R, P1, . . . , Pk} (one role Pi for each variable pi) and a concept name A, deﬁne the concept CF = (∀R|C1.A) ⊓· · · ⊓(∀R|Cn.A) where, for each i ∈{1, . . . , n}, Ci is the conjunction of three concepts D1 i ⊓D2 i ⊓D3 i , and each D j i is

D j i = ∀Ph.A, if l j i = ph ∃Ph, if l j i = ph for j ∈{1, 2, 3}, i ∈{1, . . . , n}.

Then the claim follows from the following lemma.

Lemma 3.3 F is a tautology if and only if CF ≡∀R.A.

Proof The proof of the claim is straightforward; however, since it appears only in Calvanese’s Master thesis (in Italian), we present it here in full. Only if If F is a tautology, then C1 ⊔· · · ⊔Cn ≡⊤. This can be shown by contradiction: suppose C1 ⊔· · · ⊔Cn is not equivalent to ⊤. Then, there exists an interpretation I in which there is an element x ̸∈CI i , for every i ∈{1, . . . , n}. Since each Ci = D1 i ⊓D2 i ⊓D3 i , it follows that for each i there is a j ∈{1, 2, 3} such that x ̸∈D j Deﬁne a truth assignment τ to L as follows For each h ∈{1 k}

r τ(ph) = false iff l j i = ph, and x ̸∈D j i r τ(ph) = true iff l j i = ph, and x ̸∈D j i .

Observe that we cannot have both τ(ph) = false and τ(ph) = true at the same time, since this would imply both x ̸∈∃Ph and x ̸∈∀Ph.A, which is impossi- ble since ∃Ph ⊔∀Ph.A ≡⊤. Evidently, τ assigns false to at least one literal for each disjunct of F, contradicting the hypothesis that F is a tautology. Therefore C1 ⊔· · · ⊔Cn ≡⊤. The claim is now implied by equivalences (3.1)–(3.3). If Suppose F is not a tautology. Then, there exists a truth assignment τ such that for each i ∈{1, . . . , n}, there exists a j ∈{1, 2, 3} such that τ(l j i ) = false. Deﬁne an interpretation (I, ·I), with I containing three elements x, y, z, such that PI h = (y, z) if τ(ph) = false, and PI h = ∅otherwise. Moreover, let AI = ∅, and RI = {x, y}. Observe that in this way, y ∈(∃Ph)I iff τ(ph) = false, and y ∈(∀Ph.A)I iff τ(ph) = true. This implies that x ̸∈(∀R.A)I. To prove the claim, we now show that x ∈CI F. Observe that, for each i ∈{1, . . . , n}, there exists a j ∈{1, 2, 3} such that τ(l j i ) = false. For such a j, we show by case analysis that y ̸∈(D j i )I:

r if l j i = ph then D j i = ∀Ph.A, and in this case, τ(ph) = false, hence y ̸∈(∀Ph.A)I; r if l j i = ph then D j i = ∃Ph, and in this case, τ(ph) = true, hence y ̸∈(∃Ph)I.

Therefore, for every i ∈{1, . . . , n} we have y ̸∈CI i . This implies that (x, y) ̸∈ R|I (C1⊔···⊔Cn), hence x ∈(∀R|(C1⊔···⊔Cn).A)I, which is a concept equivalent to CF.

The above proof shows only that subsumption in FL is conp-hard. However, role restrictions could also be used to obtain qualiﬁed existential quantiﬁcation, since ∃R.C = ∃R|C. Hence, FL contains also the AND-branching source of complexity. Combining the two sources of complexity, Donini et al. [1997a] proved a PSpace lower bound for subsumption in FL, matching the upper bound found by Schmidt- Schauß and Smolka [1991].

3.2.2 Intractability in FL−plus qualiﬁed existential quantiﬁcation and number restrictions

As shown in Chapter 2, disjunction arises also from qualiﬁed existential quantiﬁ- cation and number restrictions. This can be easily seen examining the construction of the tableau checking the satisﬁability of the concept

(∃R A) ⊓(∃R ( A ⊓ B)) ⊓(∃R B) ⊓⩽2 R

in which, once three objects are introduced to satisfy the existentials, one has to choose between three non-equivalent identiﬁcations of pairs of objects, where only one identiﬁcation leads to a consistent tableau branch.

Remark 3.4 When a Description Logic includes number restrictions, then negation of concept names is included for free, at least from a computational viewpoint. In fact, a concept name A and its negation ¬A can be coded as, say, ⩾4 RA and ⩽3 RA where RA is a new role name introduced for A. Now these two concepts obey the same axioms as A and ¬A – namely, their conjunction is ⊥and their union is ⊤. Hence, everything we say about computational properties of Description Logics including FL−plus number restrictions holds also for AL plus number restrictions.

We now present a proof of intractability based on this property. The reduction was ﬁrst published by Nebel [1988], who reduced the np-complete problem of set splitting [Garey and Johnson, 1979, p. 221] to non-subsumption in the Description Logic of the Back system, which included the basic FL−plus intersection of roles and number restrictions. set splitting is the following problem:

Deﬁnition 3.5 (Set splitting) Given a collection C of subsets of a basic set S, decide if there exists a partition of S into two subsets S1 and S2 such that no subset of C is entirely contained in either S1 or S2.

We simplify the original reduction. We start from a variant of set splitting (still np-complete) in which all c ∈C have exactly three elements, and reduce it to satisﬁability in FL−plus qualiﬁed existential role quantiﬁcation and number restrictions.1 Since role intersection can simulate qualiﬁed existential role quantiﬁ- cation (see next Subsection 3.2.2.1) this result implies the original one.

Theorem 3.6 Satisﬁability in FL−EN is np-hard.

Proof Let S = {1, . . . , n}, and let c1, . . . , ck be the subsets of S. There exists a splitting of S iff the concept D1 ⊓D2 ⊓D3 is satisﬁable, where D1, D2, D3 are deﬁned as follows:

D1 = ∃R.B1 ⊓· · · ⊓∃R.Bn (3.5) D2 = ∀R.(⩽2 Q1 ⊓· · · ⊓⩽2 Qk) (3.6) D3 = ⩽2 R (3.7)

where each concept Bi codes which subsets element i appears in, as follows:

Bi = ⊓j | i∈cj∃Q j.Ai

1 F R k 3 4 thi DL h th t ti l ti f ALEN [D i i l 1997 ]

x

R · · ·

R

y1 yn yi

Qj1 Qjk · · ·

Qj2

· · ·

zijk zij1 zij2

Fig. 3.1. The AND-tree structure of the tableau obtained by applying rules for ⊓and ∃R.C to D1 ⊓D2 ⊓D3(x). Applying the rule for ⩽2 R(x) would lead to several OR-branches (as many as the possible identiﬁcations of ys).

and concepts A1, . . . , An are deﬁned in such a way that they are pairwise disjoint – say, for i ∈{1, . . . , n} let Ai = ⩾i R ⊓⩽i R. Intuitively, when tableau rules deal- ing with ⊓and qualiﬁed existential quantiﬁcation are applied to D1 ⊓D2 ⊓D3(x), one obtains a tableau whose tree structure of individual names can be visualized as in Figure 3.1. The rest of the proof strictly follows the original one [Nebel, 1988], hence we do not present it here. The intuition is that D3 forces every ys generated by D1 to be identiﬁed with one of only two successors of the root individual name x. Such identiﬁcations correspond to the sets S1 and S2. Then D2 forces the split of each 3-subset, since it makes sure that neither of these successors has more than two Q j-successors, and thus both have at least one Q j-successor (since there are three of them).

We clarify the construction and show its relevant properties by an example.

Example 3.7 Suppose S = {1, 2, 3, 4}, and let c1 = {1, 2, 4}, c2 = {2, 3, 4}, c3 = {1, 3, 4}. Applying the tableau rules of Chapter 2 to D1, one obtains the following tree of individual names (deﬁnitions of each Bi are expanded):

 

R(x, y1) B1(y1) Q1(y1, z11) A1(z11) Q3(y1, z13) A1(z13)

R(x, y2) B2(y1) Q1(y2, z21) A2(z21) Q2(y2, z22) A2(z22)

R(x, y3) B3(y1) Q2(y3, z32) A3(z32) Q3(y3, z33) A3(z33)

D1(x)



 

Q1(y4, z41) A4(z41) Q2(y4, z42) A4(z42) Q3(y4, z43) A4(z43)

R(x, y4) B4(y1)



where the individual names y1, . . . , y4 stand for the four elements of S, and each z codes the fact that element i appears in subset c Because of assertions A (z )

no two z’s disagreeing on the ﬁrst index – e.g., z32 and z42 – can be safely identiﬁed, since they must satisfy assertions on incompatible A’s. This is the same as if the constraints zi j ̸= zhj, for all i, h ∈{1, . . . , |S|} with i ̸= h, and all j ∈{1, . . . , |C|}, were present. Now D3 states that y1, . . . , y4 must be identiﬁed into only two individual names. Observe that identifying y2, y3, y4 leads to an individual name (say, y2) having among others, three unidentiﬁable Q2-ﬁllers z22, z32, z42. But D2 states that all R-ﬁllers of x, including y2, have no more than 2 ﬁllers for Q2. This rules out the identiﬁcation of y2, y3, y4 in the tableau. Observe that this identiﬁcation cor- responds to a partition of S into {1} and {2, 3, 4}, which is not a solution of set splitting because the subset c2 is not split. Following the same line of reason- ing, one could prove that the only identiﬁcations of all R-ﬁllers into two indi- vidual names, leading to a satisﬁable tableau, are one-to-one with solutions of set splitting.

The same reduction works for non-subsumption, since D1 ⊓D2 ⊓D3 is satisﬁable iff D1 ⊓D2 is not subsumed by ¬D3 ≡⩾3 R. This type of reduction has also been applied (see [Donini et al., 1999]) to prove that subsumption in ALNI is conp-hard, where ALNI is the Description Logic including AL, number restrictions and inverse roles. Observe that also FL−EN contains the AND-branching source of complexity, since qualiﬁed existential restriction is present. With a more complex reduction from Quantiﬁed Boolean Formulae, combining the two sources of complexity, satisﬁability and non-subsumption in ALEN has been proved PSpace-complete by Hemaspaandra [1999]. Note that in the above proof of intractability, pairwise disjointness of A1, . . . , An could be also expressed by conjoining log n concept names and their negations in all possible ways. Hence, the proof needs only the concept ⩽2 R, and when qualiﬁed existentials are simulated by subroles, only ⩾1 R is used. This shows that the above proof of intractability is quite sharp: intractability arises indepen- dently of the size of the numbers involved. The computational cliff is evident if one moves to having 0 and 1 only in number restrictions, which leads to so- called functional roles – since the assertion ⩽1 R(x) forces R to be a partial function of x. In that case, the tractability of a Description Logic can usually be established, e.g., the Description Logic of the system Classic [Borgida and Patel-Schneider, 1994]. The intuitive reason for tractability of functional roles can be found in the corresponding tableau rules, which for number restrictions of the form ⩽1 R(x) become deterministic: there is no choice in identifying individuals names y1, . . . , yk which are all R-ﬁllers for x, but to collapse them all into one individual

3.2.2.1 Simulating ∃R.C with role conjunction

Donini et al. [1997a] showed that a concept D containing qualiﬁed existential role quantiﬁcations ∃R.C is satisﬁable iff the concept D is satisﬁable, where in D each occurrence of a concept ∃R.C is replaced by the concept ∃(R ⊓QC) ⊓∀(R ⊓ QC).C, adding QC as a new role name (a different QC for each occurrence of ∃R.C, to be used nowhere else). We call D an ⊓-simulation of D in the rest of the chapter. The proof that the simulation is correct can be easily given by referring to tableaux.

Example 3.8 Considering the concept D below on the left, and simulating qualiﬁed existential quantiﬁcations in D by role intersections, one obtains the concept D on the right,

 

 

∃(R ⊓Q A) ⊓∀(R ⊓Q A).A ⊓ ∃(R ⊓Q B) ⊓∀(R ⊓Q B).B ⊓ ∀R.C

∃R.A ⊓ ∃R.B ⊓ ∀R.C

D =

D =





where subscripts on new role names help to identify which existential they simulate. Applying the tableau rules of Chapter 2 to D(x), one obtains the model

R(x, y) A(y) Q A(x, y) C(y) R(x, z) B(z) Q B(x, z) C(z)

which satisﬁes both concepts.

Proposition 3.9 A concept D is satisﬁable iff D is satisﬁable.

Proof The proof of the proposition follows the example. Namely, an open tableau branch for D is also an open tableau branch for D (ignoring assertions on new role names), and an open tableau branch for D can be transformed to an open tableau branch for D just by adding the assertions about new role names.

As observed by Nebel [1990a], an acyclic role hierarchy in a Description Logic can be always simulated by conjunctions of existing roles and new role names. In the above example, using two role names Q A, Q B and the inclusions Q A ⊑R, Q B ⊑R yields the same simulation. Applying ⊓-simulation, one could obtain from the reduction in Theorem 3.6 the original reduction by Nebel, proving that satisﬁability (and non-subsumption) in ALN(⊓) is np-hard. Using a more complex reduction, Donini et al. [1997a] proved that satisﬁability in ALN(⊓) is in fact PSpace complete

3.3 AND-branching: ﬁnding a clash

Whencandidatemodelsofaconcepthaveexponentialsize–asfortheALE-concept of Subsection 3.1.1.2 – models cannot be guessed and checked in polynomial time. In this case, it is a combinatorial problem to ﬁnd the clash – if any – in the candidate model. This leads to np-hardness of unsatisﬁability and subsumption. However, for many Description Logics the AND-tree structure of a model is such that its traces (branches of the AND-tree) have polynomial size. A concept C is satisﬁable iff there is no trace containing a clash; hence it is sufﬁcient to guess such a trace to show that C is unsatisﬁable. From this argument,Schmidt-Schauß and Smolka [1991] proved that satisﬁability in ALE is in conp.

3.3.1 Intractability of satisﬁability in ALE

We now report a proof that satisﬁability in ALE is conp-complete. The original proof was based on a polynomial-time reduction from a variant of the np-complete problem one-in-three 3sat [Garey and Johnson, 1979, p. 259]. Here we present a proof based on the same idea, but with a slightly different construction, relying on a reduction from the np-complete problem exact cover (xc) [Garey and Johnson, 1979, p. 221]. Such a problem is deﬁned as follows.

Deﬁnition3.10(Exactcoverxc) LetU = {u1, . . . , un}beaﬁniteset,andletMbe a family M1, . . . , Mm of subsets ofU. Decide if there are q mutually disjoint subsets Mi1, . . . , Miq suchthattheirunionequalsU,i.e., Mih ∩Mik = ∅for1 ≤h < k ≤q, and q k=1 Mik = U.

The reduction consists in associating every instance of xc with an ALE-concept CM, such that M has an exact cover if and only if CM is unsatisﬁable. It is important to note that, differently from the previous sections, here a solution of the np-complete source problem is related to a proof of the absence of a model. In fact, exact covers of M are related to those traces of {CM(x)} that contain a clash; hence proving the existence of a solution of an np-complete problem is related to a refutation in the target Description Logic. In the following we assume R to be a role name. We translate M into the concept

CM = C1 1 ⊓· · · ⊓Cm 1 ⊓D1

where each concept C j 1 represents a subset M j, and is inductively deﬁned as

 ∃R.C j l+1, if either l ≤n, ul ∈M j or l > n, ul−n ∈M j ∀R C j if either l ≤n ul ̸∈M j or l > n ul ̸∈M j for l ∈{1, . . . , 2n}

C j l =

and by the base case C j 2n+1 = ⊤. The concept D1 is deﬁned by

D1 = ∀R. · · · ∀R.    2n ⊥

and each of D2, D3, . . . has one universal quantiﬁer less than the previous one. Intuitively, for every element ul in U there are two corresponding levels l,l + n in the concepts C j 1’s, where “level” refers to the nesting of quantiﬁers. The element ul is present in M j if and only if there is an existential quantiﬁer in the concept C j 1 at level l + n – which implies by construction that ∃is also at level l. The concept D1 is designed in such a way that a clash for {CM(x)} can only occur in a trace containing at least 2n + 1 individual names.

Example 3.11 Consider the following instance of xc: let U = {u1, . . . , u3}, and

M = {M1 = {u1, u2}, M2 = {u2, u3}, M3 = {u3}}.

The corresponding ALE-concept CM is given by the conjunction of C1 1, C2 1, C3 1 and D1, deﬁned as follows.

u1 u2 u3 u1 u2 u3 M1 ↔ C1 1 = ∃R.∃R.∀R.∃R.∃R.∀R.⊤ M2 ↔ C2 1 = ∀R.∃R.∃R.∀R.∃R.∃R.⊤ M3 ↔ C3 1 = ∀R.∀R.∃R.∀R.∀R.∃R.⊤ D1 = ∀R.∀R.∀R.∀R.∀R.∀R.⊥

where on the left we put the subset M j corresponding to each C j 1, and above we put the elements of U corresponding to each level of the concepts. Observe that the elements of U appear twice.

The conjunction of the above concepts is unsatisﬁable if and only if the interplay of the various existential and universal quantiﬁers, represented by a trace, forces an individual name in the tableau for {CM(x)} to belong to the extension of ⊥. This reduction creates a correspondence between such a trace and an exact cover of U. In order to formally characterize such a correspondence, we deﬁne the activeness of a concept in a trace. Let T be a trace and C be a concept. We say that C is active in T if C is of the form ∃R.D and there are individual names y, z such that T contains C(y), R(y, z), and D(z). Therefore, an existentially quantiﬁed concept ∃R.D is active in T if the →∃-rule has been applied to the assertion ∃R.D(y) in T . Intuitively, if C j k is active in a trace of {CM(x)} containing a clash, then uk belongs to an exact cover of M

Lemma 3.12 ([Donini et al., 1992a], Lemma 3.1) Let T be a trace of {CM(x)}.

(i) Suppose C j k is active in T . Then for all l ∈{1, . . . , k} if the concept C j l is of the form ∃R.C j l+1, then it is active in T . (ii) If T contains a clash, then for every l ∈{1, . . . , 2n} there exists exactly one j such that C j l is active in T .

Example 3.13 The reader can gain an insight into the importance of the above properties by constructing the tableau for the concept

(∃R.∀R.∃R.A) ⊓ (∃R.∀R.∃R.B) ⊓ (∀R.∃R.⊤)

and verifying that the trace reaching the concept A has both existentials of the ﬁrst line active (and neither existential of the second line), and vice versa for the trace reaching B.

Example 3.14 (Example 3.11 Continued) Note that in Example 3.11 the two subsets M1 and M2 form a (non-exact) cover of U, and indeed, the tableau for {C1 1 ⊓C1 2 ⊓D1(x)} is satisﬁable. Moreover, observe the importance of the two levels. If concepts were formed by just one level, the following concepts would be unsatisﬁable (choose the highlighted existentials):

C1 1 = ∃R.∃R.∀R.⊤

C1 2 = ∀R.∃R.∃R.⊤ D1 = ∀R.∀R.∀R.⊥

corresponding to a cover by M1 and M2 which is non-exact. The second level ensures that once an existential is chosen, all nested existentials must be chosen too to form a trace.

Theorem 3.15 Unsatisﬁability in ALE is np-hard.

Proof We show that an instance (U, M) of xc has an exact cover if and only if CM is unsatisﬁable. Let M = {M1, . . . , Mm} be a set of subsets of U and CM = C1 1 ⊓. . . ⊓Cm 1 ⊓D1 be the corresponding concept. Since this proof is the base for three others in the chapter, we present it in some detail. Only if Let Mi1, . . . , Miq be an exact cover of U. Let T be a trace of {CM(x1)} deﬁned inductively as follows:

T1 = {C j 1(x1) | j ∈{1, . . . , m}} ∪{D1(x1)}

T T ∪{R(x x )} ∪{C j (x ) | u ∈M } ∪{D (x )}

Obviously, T = T2n+1 contains a clash, because D2n+1 = ⊥. For each level l there is exactly one j such that C j l = ∃R.C j l+1. Using this fact, one can easily show that T is a trace by induction on l. If If CM is unsatisﬁable, then there exists a trace T of {CM(x)} such that T contains a clash. We show that the subsets in

{M j | ∃l ∈{1, . . . , n} : C j n+l is active in T }

form an exact cover of U. First of all, since T is a trace, for every level l ∈{1, . . . , 2n} there exists a j such that C j l is active in T (Lemma 3.12(ii)). Hence the union of these subsets covers U. We now prove that no two subsets overlap: in fact, suppose there are i, j such that Mi, M j intersect non-trivially in an element ul. Here we exploit the two-layered construction of CM. By deﬁnition, there are h, k such that Ci n+h and C j n+k are active in T . Since ul is in both Mi and M j, by construction of CM we have Ci l = ∃R.Ci l+1 and C j l = ∃R.C j l+1. From Lemma 3.12(i), we know that Ci l and C j l are both active in T . Hence i = j from Lemma 3.12(ii).

The above reduction works also for the special case of xc in which every subset has at most three elements, which corresponds to at most six nested existential quantiﬁcations in each concept C j 1. Hence, bounding the number of nested exis- tential quantiﬁcations by a constant k ≥6 does not yield tractability. The original reduction from one-in-three 3sat shows moreover that bounding the number of existentials in each level by a constant k ≥3 does not yield tractability. Simulating qualiﬁed existential quantiﬁcations in CM by role intersection (see Subsection 3.2.2.1), we conclude that unsatisﬁability of concepts in AL(⊓) – AL plus role conjunction – is np-hard, too.

Theorem 3.16 Satisﬁability and subsumption of concepts are np-hard in AL(⊓).

We note that this source of intractability is not due to the presence of the concept ⊥, but to the interplay of universal and existential quantiﬁcation. In fact, the above reduction works also for the Description Logic FL−E, which is FL−plus qualiﬁed existential quantiﬁcation.

Theorem 3.17 Subsumption is np-hard in FL−E.

Proof TheproofisbasedonthereductiongivenforALE.TheALE-conceptCM = C1 1 ⊓· · · ⊓Cm 1 ⊓D1 in that reduction is unsatisﬁable if and only if C1 1 ⊓· · · ⊓Cm 1 is subsumed by D Now C1 ⊓ ⊓Cm is a concept in FL−E and D can be

rewritten to the equivalent concept E, deﬁned as

E = ∃R. · · · ∃R.    2n ⊤

i.e., a chain of 2n qualiﬁed existential quantiﬁcations terminating with the concept ⊤. Obviously, E is in FL−E, hence subsumption in FL−E is np-hard.

We now use the above construction to show that in three other Description Logics – extending FL−with each pair of role constructs for role conjunction, role inverse, and role chain – subsumption is np-hard. The fact that reductions can be easily re- used is a characteristic of Description Logics. It depends on the compositional semantics of constructs – hardness proofs obviously carry over to more general Description Logics – but also on the extensional semantics, that allows one to simulate a construct with others.

3.3.2 FL−plus role conjunction and role inverse

We abbreviate this Description Logic as FL−(⊓,−). We prove that FL−(⊓,−) is hard for np by an argument similar to that for FL−E. One may be tempted to use ⊓-simulation, deﬁned in Subsection 3.2.2.1, which replaces qualiﬁed ex- istential quantiﬁcations by role intersections. However, a direct ⊓-simulation of the concepts used in the reduction for FL−E does not work. In fact, ⊓- simulation preserves satisﬁability, not subsumption; e.g., while ∃R.C ⊓D is sub- sumed by ∃R.C, its ⊓-simulation ∃(R ⊓Q1) ⊓∀Q1.C ⊓D is not subsumed by ∃(R ⊓Q2) ⊓∀Q2.C. To carry over the proof, it is useful to have a tableau rule for role inverse:

Condition T contains R(x, y), where R is either a role name P or its inverse P−; Action T ′ = T ∪{R−(y, x)}, where if R = P−, then R−= P.

Theorem 3.18 Subsumption in FL−(⊓,−) is np-hard.

Proof We refer to the concept CM deﬁned in the reduction given for ALE. Let n be the cardinality of U in xc. First deﬁne the concept F as follows:

F = ∀R. · · · ∀R.    2n ∀(R−). · · · ∀(R−).    2n A

where A is a concept name (recall that CM does not contain any concept name but ⊤and ⊥) F is a concept of FL−(⊓−)

Observe now that the ALE-concept CM = C1 1 ⊓· · · ⊓Cm 1 ⊓D1 is unsatisﬁable if and only if C1 1 ⊓· · · ⊓Cm 1 ⊓F is subsumed by A (where C is the ⊓-simulation of C). In fact, the subsumption holds if and only if the complete tableau for {C1 1 ⊓· · · ⊓ Cm 1 ⊓F(x), ¬A(x)} contains the only possible clash {A(x), ¬A(x)}. This tableau contains a clash if and only if there is a trace of length 2n in the tableau, and such a trace is in one-to-one correspondence with the exact covers of the problem xc. Hence subsumption in FL−(⊓,−) is np-hard.

3.3.3 FL−plus role conjunction and role chain

We abbreviate this Description Logic as FL−(⊓, ◦).

Theorem 3.19 Subsumption in FL−(⊓, ◦) is np-hard.

Proof Again, we refer to the concept CM deﬁned in the reduction given for ALE. Observe that the ALE-concept CM = C1 1 ⊓. . . ⊓Cm 1 ⊓D1 is unsatisﬁable if and only if C1 1 ⊓. . . ⊓Cm 1 is subsumed by ¬D1 (again, C is the ⊓-simulation of C). The claim holds, since C1 1 ⊓. . . ⊓Cm 1 is in FL−(⊓) and ¬D1 can be expressed as the equivalent concept G, deﬁned as follows:

G = ∃(R ◦· · · ◦R)    2m . (3.8)

Obviously, G is in FL−(◦), hence subsumption in FL−(⊓, ◦) is np-hard.

We note that in the above reduction, subsumption is proved intractable by using only role conjunction in the subsumee (to simulate existential quantiﬁca- tion), and only role chain in the subsumer. We will exploit the subsumer (3.8) also in Subsection 3.3.4.

3.3.4 FL−plus role chain and role inverse

We abbreviate this Description Logic as FL−(◦,−). We ﬁrst show that, similarly to Subsection 3.2.2.1, qualiﬁed existential quantiﬁcations in a concept D can be replaced by a combination of role chains and role inverses, obtaining a new concept D that is satisﬁable iff D is.

3.3.4.1 Simulating ∃R.C via role chains and role inverses

Donini et al. [1991b; 1999] showed that a concept D containing qualiﬁed ex- istential role quantiﬁcations ∃R.C is satisﬁable iff the concept D is satisﬁable, where in D each occurrence of a concept ∃R.C is replaced by the concept ∃(R ◦Q ) ⊓∀(R ◦Q ◦Q−) C adding Q as a new role name (a different Q for

each occurrence of ∃R.C, to be used nowhere else). We say that C is a ◦-simulation of C. This simulation too can be explained by referring to tableaux, through an example concept.

Example 3.20 Consider the concept D below on the left, and its ◦-simulation D on the right:

 

 ∃R.A ⊓ ∃R.B ⊓ ∀R.C

∃(R ◦Q A) ⊓∀(R ◦Q A ◦Q− A).A ⊓ ∃(R ◦Q B) ⊓∀(R ◦Q B ◦Q− B).B ⊓ ∀R.C

D =

D =



where subscripts on new role names help to identify which existential they simulate. Applying the tableau rules of Chapter 2 to D(x), one obtains the model

R(x, y) A(y) Q A(y, uy) C(y) R(x, z) B(z) Q B(z, uz) C(z)

where subscripts on individuals uy, uz highlight that there is a new individual name for each individual name used to satisfy an existential quantiﬁcation. That is, the number of individual names in the tableau for D is at most twice that in the tableau for D.

Lemma 3.21 Let D be an ALE-concept and D its ◦-simulation. Then D is satis- ﬁable if and only if D is satisﬁable.

Proof The proof extends the above example. In one direction, an open tableau for D is also an open tableau for D (ignoring assertions on new role names). In the other direction, an open tableau for D can be transformed to an open tableau for D: to every role assertion R(x, y) – added to satisfy an existential ∃R.C in D – chain an assertion QC(y, uy).

If C is an ALE-concept, its ◦-simulation C is a concept belonging to the language AL(◦,−), that is, AL plus role inverses and role chains. Of course, ◦-simulations could be deﬁned for concepts belonging to Description Logics more expressive than ALE. For Description Logics in which every concept is satisﬁable (like FL−(◦,−)) this simulation can be interesting only in subsumptions. We can now come back to subsumption in the Description Logic FL−plus role inverses and role chains

Theorem 3.22 Subsumption in FL−(◦,−) is np-hard.

Proof For every ALE-concept C, one can compute in quadratic time an ◦- simulation C. For a given instance (U, M) of xc, CM is unsatisﬁable iff (by Lemma 3.21) CM is satisﬁable iff C1 1 ⊓. . . ⊓ Cm 1 is subsumed by ¬D1. Now the subsumee contains no negated concept, hence it belongs to FL−(◦,−). The sub- sumer is equivalent to the concept G in (3.8), which again is in FL−(◦,−).

3.4 Combining sources of complexity

In a Description Logic containing both sources of complexity, one might expect to code any problem involving the exploration of polynomial-depth, rooted AND–OR graphs. The computational analog of such graphs is the class APTime (problems solved in polynomial time by an alternating Turing machine) which is equivalent to PSpace (e.g., see [Johnson, 1990, p. 98]). A well-known PSpace-complete problem is Validity of Quantiﬁed Boolean Formulae:

Deﬁnition 3.23 (Quantiﬁed Boolean Formulae qbf) Decide the validity of the (second-order logic) closed sentence

(Q1X1)(Q2X2) · · · (Qn Xn)[F(X1, . . . , Xn)],

where each Qi is a quantiﬁer (either ∀or ∃) and F(X1, . . . , Xn) is a Boolean formula with Boolean variables X1, . . . , Xn.

The problem remains PSpace-complete if F is in 3CNF, i.e., conjunctive normal form with at most three literals per clause. We call the string of quantiﬁers the preﬁx of the quantiﬁed formula, and the 3CNF formula F its matrix. This problem can be encoded in an AND–OR graph, using AND-nodes to encode ∀-quantiﬁers, and OR-nodes for ∃-quantiﬁers. In the leaves, there is the matrix F. We use this analogy to illustrate the reduction, taken from [Schmidt-Schauß and Smolka, 1991].

3.4.1 PSpace -hardness of satisﬁability in ALC

Without loss of generality, we assume that each clause is non-tautological, i.e., a literal and its complement do not appear both in the same clause. Let F = G1 ∧· · · ∧Gm. The QBF (Q1X1) · · · (Qn Xn)[G1 ∧· · · ∧Gm] is valid iff the ALC- concept

C D ⊓C1 ⊓ ⊓Cn (3 9)

is satisﬁable, where in C all concepts are formed using the concept name A and the atomic role name R. The concept D encodes the preﬁx, and is of the form D1 ⊓∀R.(D2 ⊓∀R.(. . . (Dn−1 ⊓∀R.Dn) . . .) where fori ∈{1, . . . , n} each Di cor- responds to a quantiﬁer of the QBF in the following way:

Di = (∃R.A) ⊓(∃R.¬A), if Qi = ∀ ∃R.⊤, if Qi = ∃.

The concept Ci 1 is obtained from the clause Gi using the concept name A when a Boolean variable occurs positively in Gi, ¬A when it occurs negatively, and nesting l universal role quantiﬁcations to encode the variable Xl. In detail, let k be the maximum index of all Boolean variables appearing in Gi. Then, for l ∈ {1, . . . , (k−1)} one deﬁnes

 

∀R.(A ⊔Ci l+1), if Xl appears positively in Gi ∀R.(¬A ⊔Ci l+1), if Xl appears negatively in Gi ∀R.Ci l+1, if Xl does not appear in Gi

Ci l =



and the last concept of the sequence is deﬁned as

Ci k = ∀R.A, if Xk appears positively in Gi ∀R.¬A, if Xk appears negatively in Gi.

It can be shown that each trace in a tableau branch for D corresponds to a truth as- signment to the Boolean variables, and that all traces of a tableau branch correspond to a set of truth assignments consistent with the preﬁx. Therefore, Schmidt-Schauß and Smolka conclude that satisﬁability in ALC is PSpace-hard. Combining this result with the polynomial-space calculus given for ALCN in Chapter 2, one ob- tains that satisﬁability (and subsumption) in ALCN are PSpace-complete, and that the exponential-time behavior of the calculus cannot be improved unless PSpace =PTime. Satisﬁability and subsumption are still in PSpace if role conjuctions are added to ALCN [Donini et al., 1997a], or if inverse roles and transitive roles are added to ALC [Horrocks et al., 2000b]. Using ⊓-simulations, one can use the same reduction to prove that both satisﬁa- bility and subsumption in ALU(⊓) are PSpace-hard (and thus PSpace-complete). By a more complex reduction, Donini et al. [1991a] proved that satisﬁability in ALN(⊓) is also PSpace-hard. Hemaspaandra [1999] proved that satisﬁability in ALEN is PSpace-hard using a reduction from qbf, where the preﬁx was coded with a concept similar to D (more precisely, similar to the concept D in Subsec- tion 3 1 1 2) and the matrix was coded in a more complex way Also FL was

proved PSpace-hard in [Donini et al., 1997a]. Observe that all these Description Logics contain both sources of complexity.

3.4.2 A remark on reductions

Schild [1991] observed that ALC is a notational variant of multi-modal logic K, whose satisﬁability was proved PSpace-hard by Ladner [1977], using a different reduction from qbf. This gives us the occasion to point out a characteristic of reductions from a different, fairly experimental viewpoint. The target modal formula in Ladner’s reduction has size quadratic w.r.t. the given instanceofqbf,whileonecanobservethattheconceptC in(3.9)hasonlylinearsize. From a theoretical perspective of the PSpace reduction, this is irrelevant. However, qbf has also been studied from an experimental point of view (e.g., [Cadoli et al., 2000; Gent and Walsh, 1999]): trivial cases have been identiﬁed, easy-hard-easy patterns have been found, and one can use ratios of clauses/variables for which the probability that a random QBF is valid is around 0.5 – which have been proved experimentally to contain the “hard” instances. This experimental work can be transferred to Description Logics, to compare the various algorithms and systems for reasoning in ALC. This transfer yields the beneﬁts that

r concepts which are trivially (un)satiﬁable do not need to be isolated again; r the translation of “hard” QBFs can be used to test reasoning algorithms for ALC; r the performance of algorithms for ALC can be compared with best known algorithms for solving qbf (see [Cadoli et al., 2000; Rintanen, 1999; Giunchiglia et al., 2001]), and optimizations can be carried over.

However, using Ladner’s reduction to obtain “hard-to-reason” concepts, the quadratic blowup of the reduction soon makes the resulting concepts too big to be signiﬁcantly tested. Using Schmidt-Schauß and Smolka linear reduction, in- stead, one can use a spectrum of “hard” concepts as wide as the original instances of qbf. Thus, experimental analysis might make signiﬁcant differences between (theoretically equivalent) polynomial many-to-one transformations used in reduc- tions [Donini and Massacci, 2000].

3.5 Reasoning in the presence of axioms

In this section we consider the impact of axioms on reasoning. Intuitively, axioms introduce new concept expressions in every individual generated in a tableau, so that simple arguments on termination and complexity based on the nesting of operators do not apply. We start with a comparison with Dynamic Logic, and then we show how axioms can encode a succinct representation of AND–OR graphs, leading to an ExpTime lower bound

3.5.1 Results from Propositional Dynamic Logic

Propositional Dynamic Logic (pdl) [Harel et al., 2000] is a formalism able to express propositional properties of programs. Instead of introducing yet another logical syntax, we will talk about pdl in terms of Description Logics. A precise correspondence between Description Logics and pdl can be found in Chapter 5. The counterpart of pdl in Description Logics is ALCtrans [Baader, 1991], al- ready deﬁned in Chapter 2. We recall that ALCtrans is ALC plus a rich set of role constructors: union of roles, composition, and transitive closure. To be precise, pdl has also a role-forming constructor which is role identity, and the closure of a role is the reﬂexive–transitive one, denoted as R∗. Reﬂexive–transitive closure is deﬁned similarly to transitive closure, but considering also every pair (a, a) to be in the interpretation of R∗. However, Schild [1991] showed that these are minor differences, as long as we are concerned with computational behavior only. pdl and ALCtrans are relevant in this section about axioms, because using union and transitive closure of roles, one can “internalize” axioms in a concept in the following way [Baader, 1991; Schild, 1991]. Let C be an ALC concept, T a set of axioms of the form Ci ⊑Di, i ∈{1, . . . , m}. Observe that every axiom can also be thought of as a concept ¬C ⊔D which every individual in a model must belong to. Let R1, . . . , Rn be all the role names used in either C or T . Then C is satisﬁable w.r.t. T iff the following concept is satisﬁable:

C ⊓∀(R1 ⊔· · · ⊔Rn)∗.((¬C1 ⊔D1) ⊓· · · ⊓(¬Cm ⊔Dm)). (3.10)

The key property that makes this reduction correct is the connected model property [Streett, 1982]: if C has a model w.r.t. a set of axioms, then it has also a model in which one element a ∈I is in CI, and for every other element b in the model, there is a path of roles from a to b. Concept (3.10) is just a syntactic variant of a pdl expression. Hence, every upper bound on complexity of satisﬁability for pdl applies also to concept satisﬁability in ALC w.r.t. axioms, including all role constructors of pdl. Namely, satisﬁabil- ity in pdl was proved to be decidable in deterministic exponential time, ﬁrst by Pratt [1979], and then by Vardi and Wolper [1986] using an embedding into tree automata. This upper bound holds also for ALC plus axioms. It is interesting to observe that the deterministic exponential time upper bound was nontrivial; sim- ple nondeterministic upper bounds were proved by Fischer and Ladner [1979] for pdl and by Buchheit et al. [1993a] for Description Logics, using tableaux. Only recently a tableau with lemmas providing a deterministic exponential upper bound has been found [Donini and Massacci, 2000]. Regarding hardness, every lower bound on reasoning in ALC with axioms carries over to pdl However lower bounds for pdl were already known Fischer and

Ladner [1979] proved that pdl is ExpTime-hard using a reduction from Alternating Turing Machines working in polynomial space (recall that the complexity class Alternating Polynomial Space is the same as ExpTime [Johnson, 1990]). van Emde Boas [1997] proved the same result using a reduction from alternating domino games. However, both hardness proofs use a very small part of pdl, and in particular, transitive closure on roles appears only in one expression of the form (3.10), so that proofs could be adapted to ALC concept satisﬁability w.r.t. a set of inclusions, in a very simple way. Moreover, the proofs use ∀R.C to code an AND-node, and ∃R.C to code an OR-node. Hence, they follow the same intuition presented in the previous section, where we showed the correspondence between AND–OR trees and satisﬁability of ALC without axioms. Here, we want to present yet another proof, of a very different nature, that high- lights the fact that concept inclusions can express a large structure in a succinct way.

3.5.2 Axioms and succinct representations of AND–OR graphs

We now need more precise deﬁnitions about AND–OR graphs. An AND–OR graph is a graph in which nodes are partitioned into AND-nodes and OR-nodes. An OR- node is reachable if one of its predecessors is reachable (as in ordinary graphs), while an AND-node is reachable only if all its predecessors are reachable.

Deﬁnition3.24(AND–ORgraphAccessibilityProblem(agap)) GivenanAND– OR graph, a set of source nodes S1, . . . , Sm, and a target node T , is T reachable from S1, . . . , Sm?

Let n be the number of nodes of the graph, and d (a constant) the maxi- mum number of predecessors of a node. It is well known that agap can be solved in time polynomial in n (e.g., it can be reduced to Monotone Circuit Value, which is PTime-complete [Papadimitriou, 1994]). However, agap becomes ExpTime-complete when one considers its succinct version [Balcazar, 1996]. Let the out-degree of a node be bounded by a constant d. Let C be a Boolean circuit with log n inputs, and with 1 + d log n outputs; when the input of C is the binary encoding of a node N, its outputs are the encodings of the type of N (AND/OR) and of the d predecessors of N (using a dummy node if there are fewer than d predecessors).

Deﬁnition 3.25 (Succinct AND–OR Graph Accessibility Problem (s(agap))) Given a circuit C representing an AND–OR graph, a set of source nodes S1, . . . , Sm, and a target node T is T reachable from S S ?

Now, s(agap) is ExpTime-complete [Balcazar, 1996]. The intuition for this ex- ponential blowup in complexity is that there are many circuits which can encode graphs whose size is exponentially larger than the circuit size. This intuition applies to many other succinct representations of problems with circuits [Papadimitriou, 1994, p. 492] or with propositional formulae [Veith, 1997], yielding complete prob- lems for high complexity classes. We reduce s(agap) for graphs with in-degree d = 2 to unsatisﬁability of an ALC concept C w.r.t. a set of inclusions T . Intuitively, the axioms can succinctly encode either a proof of unsatisﬁability for a concept, or a model for C w.r.t. T . We note that, since we are coding reachability into unsatisﬁability, we will use ⊓to code OR-nodes – a conjunction is unsatisﬁable when at least one of its conjuncts is – and ⊔to code AND-nodes. First of all, let A1, . . . , Alog n be a set of concept names one-to-one with the inputs of the circuit C. Each node N in the graph is then mapped into a conjunction of As and their negations, denoted by concept(N), depending on the code of N: if the ith bit in the code of N is 1, use Ai, if it is 0, use ¬Ai. For example, if N has code 1101 then concept(N) is A1 ⊓A2 ⊓¬A3 ⊓A4. Then, let B1 1, . . . , B1 log n and B2 1, . . . , B2 log n be two sets of concept names one- to-one with the outputs of C. Conjunctions of Bs with negations code predecessor nodes. Moreover, let two concept names AND, OR represent the type of a graph node. If C has k internal gates, we use also k concept names W1, . . . , Wk. For each gate, we use a concept equality that mimics the Boolean formula deﬁning the gate. E.g., if C has an ∧-gate x1 ∧x2 = x3, we use the equality X1 ⊓X2 = X3, where X1, X2, X3 can either be concept names among W1, . . . , Wk denoting input/output of internal gates, or be some of the As and Bs, denoting inputs/outputs of the whole circuit. For the output of C encoding the type of the node, we use directly the two concept names AND, OR in the concept equality coding the output gate of C. Moreover, to model the different interpretation of predecessors for the two type of nodes, we use the inclusions

AND ⊑ ∃R1.⊤⊔∃R2.⊤ (3.11) OR ⊑ ∃R1.⊤⊓∃R2.⊤ (3.12)

where R1 and R2 are two role names (we use indices 1,2 to parallel indices of the Bs). Observe that concept AND implies a disjunction ⊔, and concept OR implies a conjunction ⊓. This is because we reduce reachability to unsatisﬁability, as we said before. Moreover, observe that predecessors in the AND–OR graph are coded into role successors in the target Description Logic

For the output of C encoding the predecessors of a node, we add the following inclusions for i ∈{1, . . . , log n}:

B1 i ⊑ ∀R1.Ai (3.13) ¬B1 i ⊑ ∀R1.¬Ai (3.14) B2 i ⊑ ∀R2.Ai (3.15) ¬B2 i ⊑ ∀R2.¬Ai. (3.16)

We denote by TC the set of all of the above axioms. We now give an example of what the axioms imply. Suppose C computes the two predecessors 1011 and 0110 for node 1101. Then, equalities coding C force concept(1101) = A1 ⊓A2 ⊓¬A3 ⊓A4 to be included in B1 1, ¬B1 2, B1 3, B1 4 (ﬁrst predecessor) and ¬B2 1, B2 2, B2 3, ¬B2 4 (second predecessor). Then inclusions (3.13)– (3.16)saythatevery R1-successorisincludedin A1,¬A2, A3, A4 –whichconjoined, make concept(1011) – and that every R2-successor is included in ¬A1, A2, A3, ¬A4 (concept(0110)). Moreover, if C computes an AND-type for node 1101, then axiom (3.11) implies that the corresponding concept is included in AND, and this implies that either an R1-successor or an R2-successor exists. For OR-type nodes, both successors exist.

Theorem 3.26 Let C be a circuit, T be the target node, and S1, . . . , Sm be the source nodes in an instance of s(agap). Then T is reachable from S1, . . . , Sm iff concept(T ) is unsatisﬁable in the TBox TC ∪{concept(S1) ⊑⊥} ∪· · · ∪{concept(Sm) ⊑⊥}.

Proof Most of the rationale of the proof has been informally given above. We sketch what is needed to complete the proof. If Suppose T is unreachable from S1, . . . , Sm. We construct a model (I, I) for concept(T ) satisfying the axioms as follows. Let I be the set of all nodes in the graph which are unreachable from S1, . . . , Sm. Then, (R1)I is the set of pairs (a, b) of nodes in I, such that b is the ﬁrst predecessor of a, and similarly for (R2)I (second predecessor). For i ∈{1, . . . , log n}, (Ai)I is the set of nodes in I

whose binary code has the ith bit equal to 1. The interpretation of the Bs, Ws, and AND, OR concepts is according to the 1-value of the circuit: node a is in their interpretation iff the output they correspond to is 1 when the code of a is the input of the circuit. Then, T ∈(concept(T ))I, and moreover (I, I) satisﬁes by construction all axioms in TC; e.g., if an OR-node is unreachable, then both its predecessors are unreachable, hence both predecessors are in I, and axiom (3.12) is satisﬁed. Similarly for an AND node

Only if Let N be any node reachable from S1, . . . , Sm, and let d(N) be the depth of the shortest hyperpath leading from S1, . . . , Sm to N. We show by induction on d(N) that concept(N) is unsatisﬁable in the TBox. If d(N) = 0, the claim holds by construction. Let N be a reachable node, with d(N) = k + 1. If N is an OR-node, at least one of its predecessors – let it be the ﬁrst predecessor, and call it M – is reachable with d(M) = k. Then concept(M) is unsatisﬁable by inductive hypothesis. But axiom (3.12) implies that concept(N) is included in ∃R1.⊤⊓∃R2.⊤, while (3.13)–(3.16) imply that concept(N) is included in ∀R1.concept(M), that is, ∀R1.⊥. Hence, also concept(N) is unsatisﬁable. A similar proof holds in case N is an AND-node. Then, the claim holds for N = T .

Observe that in the above proof we did not use qualiﬁed existential quantiﬁcation; hence, the proof works for the sublanguage of ALC called ALU. Now, axioms coding the circuit can be propositionally rewritten without union. Moreover, the only other axiom in which union is needed is (3.11), which could be rewritten equivalently as ∀R1.⊥⊓∀R2.⊥⊑¬OR, which is now in the language AL.

Theorem 3.27 Let C be a concept and T a set of inclusions in AL, with at least two role names. Deciding whether C is unsatisﬁable w.r.t. T is ExpTime-hard.

The above theorem sharpens a result by Calvanese [1996b], who proved Exp- Time-hardness for ALU. McAllester et al. [1996] proved ExpTime-hardness for a logic that includes FL−E, and their proof can be rewritten to work with ALU.

Remark 3.28 The above proof does not follow the correspondence used by Fischer and Ladner [1979] between AND-nodes and ∀R.C concepts on one side, and OR-nodes and ∃R.C concepts on the other side. There, quantiﬁcations ∃R and ∀R.C were used to code predecessors in the graph, node type was coded by ⊓, ⊔ constructors, while axioms were crucial to mimic the behavior of the circuit.

3.5.3 Syntax restrictions on axioms

In the proof, no restriction on axioms was imposed. A signiﬁcant syntactic restric- tion is to allow only concept names on the left-hand side of axioms. In this case, a dependency graph induced by the axioms of a TBox T can be constructed, whose nodes are labeled by concept names. A node A is connected to a node B if the concept name B appears (also as a subconcept) in a concept C, and A ⊑C is an axiom. Then, it makes sense to distinguish between cyclic axioms, in which the dependency graph contains a cycle and acyclic axioms

Acyclicity is signiﬁcant, because if only acyclic axioms are allowed, then rea- soning in ALC can be performed in PSpace by expanding axioms when needed [Baader and Hollunder, 1991b; Calvanese, 1996b]. The only case for ALC (till now) in which acyclic axioms make reasoning ExpTime-hard is when concrete domains are also added [Lutz, 2001b]. Also sublanguages of ALC can be considered. With regard to acyclic axioms in AL, Buchheit et al. [1998] proved that subsumption in acyclic AL TBoxes is conp-hard, and in PSpace. Calvanese [1996b] proved that cyclic axioms in AL are PSpace-complete, and other results for ALE and ALU. A second possible restriction is to allow axioms of the form A ≡C, but in which a concept name can appear only once on the left-hand side. For axioms of this form in ALN, K¨usters [1998] proved that reasoning is PSpace-complete when the TBox is cyclic, and np-complete when it is acyclic.

3.6 Undecidability

One of the main reasons why satisﬁability and subsumption in many Descrip- tion Logics are decidable – although highly complex – is that most of the con- cept constructors can express only local properties about an element [Vardi, 1997; Libkin, 2000]. Let C be a concept in ALC: recalling the tableau methods in Chap- ter 2, an assertion C(x) states properties about x, and about elements which are linked to x by a chain of at most |C| role assertions. Intuitively, this implies that a constraint regarding x will not “talk about” elements which are arbitrarily far (w.r.t. role links) from x. This also means that in ALC, and in many Description Logics, an assertion on an individual cannot state properties about a whole structure satisfying it. However, not every Description Logic satisﬁes locality.

3.6.1 Undecidability of role-value-maps

The ﬁrst notable non-local Description Logic is a subset of the language of the knowledge representation system Kl-One, isolated by Schmidt-Schauß [1989], which we call2 FL−(◦, =). It contains conjunction, universal quantiﬁcation, role composition, and equality role-value-maps R = Q. A role-value-map allows one to express concepts like “persons whose co-workers coincide with their relatives”, as it could be, e.g., a small family-based ﬁrm. Using two role names co-worker and relative, this concept would be expressed as (co-worker = relative ⊓person). The Description Logic proved undecidable by Schmidt-Schauß used equal- ity role-value-maps. Here we present a simpler proof for a Description Logic

2 I hi S h idt S h ß d th ALR

Table 3.2. Syntax and semantics of the Description Logic FL−(◦, ⊆).

concept expressions semantics

concept name A ⊆I

value restriction ∀R.C {x ∈I | ∀y. (x, y) ∈RI →y ∈CI} concept intersection C ⊓D CI ∩DI

role-value-map R ⊆Q {x ∈I | ∀y. (x, y) ∈RI →(x, y) ∈QI}

role expressions semantics

role name P ⊆I × I

role composition R ◦Q {(x, y) ∈I × I | ∃c. (x, z) ∈RI, (z, y) ∈QI}

using containment role-value-maps R ⊆Q. We call this Description Logic FL−(◦, ⊆). Clearly, FL−(◦, ⊆) is (slightly) more expressive than FL−(◦, =), since R = Q can be expressed by (R ⊆Q) ⊓(Q ⊆R), but not vice versa. Most of the original reduction is preserved, though. Although all constructs of FL−(◦, ⊆) have already been deﬁned in different parts of Chapter 2, we recall for convenience their syntax and semantics in the single Table 3.2. Recall that R ⊆Q is a concept: namely, the concept of all elements whose set of ﬁllers for role R is included in the set of ﬁllers for role Q. To avoid many parentheses, we assume ◦has always precedence over ⊆. Before giving the proof that subsumption in FL−(◦, ⊆) is undecidable, let us consider an example illustrating why FL−(◦, ⊆) is not local.

Example 3.29 Let Q, R, S, U, V be role names. Consider whether the con- cept C = ∀S.∀U.A ⊓(R ◦Q ⊆S) ⊓∀R.(Q ◦U ⊆V ) is subsumed by the concept D = ∀R.∀Q.∀U.B. The answer is no: in fact, a model satisfying C and not satisfying D is shown in Fig. 3.2. This model can be obtained by trying to satisfy ¬D = ∃R.∃Q.∃U.¬B with individual x, y, z, w, and then adding role assertions satisfying C. Ob- serve that a model of C cannot be a tree because of concepts like (R ◦Q ⊆S). Hence, any notion of “distance” between two individuals in a model, as the num- ber of role links connecting them, is ambiguous when a Description Logic has role-value-maps. Moreover, the satisfaction of the assertions (R ◦Q ⊆S)(x) and ∀S.A(x) in an interpretation depends on the satisfaction of the assertion A(z), for every individual z connected to x via a path of role ﬁllers that can be com- posed according to role-value-maps. In fact, replacing B with A in D yields a concept D′ which now subsumes C – and indeed, the previous model satisﬁes also D′

V (y, w)

A(w)

¬B(w) R(x, y)

(Q ◦U ⊆V )(y)

∀S.∀U.A(x)

Q(y, z)

U(z, w)

(R ◦Q⊆S)(x)

∀U.A(z)

∀R.(Q ◦U ⊆V )(x)

S(x, z)

Fig. 3.2. A possible countermodel for C ⊑D in Example 3.29. Boxes group assertions about an individual; arrows represent role assertions.

These properties are crucial for the reduction from ground rewriting systems to subsumption in FL−(◦, ⊆). For basics about rewriting systems, consult [Der- showitz and Jouannaud, 1990].

Deﬁnition 3.30 (Ground rewriting system) Let be a ﬁnite alphabet {a, b, . . .}. A term w on is an element of ∗, i.e., a ﬁnite sequence of 0 or more letters from . If v, w are terms, their concatenation is a term, denoted by vw. A ground rewriting system is a ﬁnite set of rewriting rules ρ = {si →ti}i=1,...,n, where for every i ∈{1, . . . , n} both si and ti are terms on . The rewriting relation ∗→induced by a set of rewriting rules ρ is the minimal relation which is reﬂexive, transitive, and satisﬁes the following conditions:

(i) if s →t ∈ρ then s ∗→t; (ii) for every letter a ∈ , if p ∗→q then both ap ∗→aq and pa ∗→qa.

The rewriting problem for ground rewriting systems is: Given a set of rewriting rules ρ and two terms v, w, decide whether v ∗→w.

Remark 3.31 In general, a single rewriting step of a term v consists in ﬁnding a substring of v which coincides with the antecedent s of a rewriting rule s →t, and then substituting t for s in v. Hence, v ∗→w if there exist n terms u1, . . . , un such that u1 = v, un = w, and for each i ∈{1, . . . , n −1} the two terms ui, ui+1 are such that for some terms p and q, we have ui = psq, ui+1 = ptq, and s → t ∈ρ. This proves that the term problem is recursively enumerable. However, it is semidecidable (recursively enumerable, but nonrecursive).

We reduce this problem to subsumption in FL−(◦, ⊆) as follows. First of all, observe that we can deﬁne the following one-to-one correspondence between terms and role chains:

r For every letter a in , let Pa be a role name. r For every term w, let Rw be the composition of the role names corresponding to the letters of For e ample if b then R P P P

Now for each set of rewriting rules ρ, we deﬁne the concept Cρ as

Cρ = ⊓s→t∈ρ(Rs ⊆Rt).

Let Q be a new atomic role: we deﬁne a concept C as

C = ⊓a∈ (Q ◦Pa ⊆Q).

Intuitively, if a model I satisﬁes C (x), then for every term w, if (Q ◦Rw)(x, z) holds in I, then Q(x, z) also holds, i.e., x is directly connected via Q to every other element z to which it is indirectly connected via Q ◦Rw. If also I |= ∀Q.Cρ(x), then Cρ(z) holds for every such z. This is a key property of the reduction.

Remark 3.32 The two concepts ∀Q.Cρ and C are a way to internalize simple axioms in a concept. Consider a TBox T = {⊤⊑Cρ} which states that every in- dividual in a model must satisfy concept Cρ. One could prove that in FL−(◦, ⊆) a concept C is subsumed by a concept D w.r.t. T iff C ⊓∀Q.Cρ ⊓∀Q.C is subsumed by ∀Q.D, where the latter is plain subsumption between concept ex- pressions.

Theorem 3.33 Subsumption in FL−(◦, ⊆) is undecidable.

Let ρ be a set of rewriting rules, and v, w be two terms. Deﬁne the following two concepts:

C = C ⊓∀Q.Cρ (3.17) D = ∀Q.(Rv ⊆Rw). (3.18)

We divide the proof in two lemmas.

Lemma 3.34 If v ∗→w then the concept C is subsumed by D.

Proof We ﬁrst prove that the claim holds for the base case of the inductive deﬁnition of ∗→(Condition (i) in Deﬁnition 3.30). Then, we prove the claim for the two inductive cases (Condition (ii)). Finally, we prove that the proof carries over the closure conditions. In all cases, let s →t ∈ρ. Base case The concept D is ∀Q.(Rs ⊆Rt). Observe that the concept ∀Q.Cρ is equivalent to ⊓s→t∈ρ∀Q.(Rs ⊆Rt). Hence, C is subsumed by D because D is one of the conjuncts of (an equivalent form of ) C. Inductive cases For the ﬁrst inductive case, let D = ∀Q.(Pa ◦Rp ⊆Pa ◦Rq), and let the inductive hypothesis be that C is subsumed by ∀Q.Rp ⊆Rq. For a contradiction suppose C is not subsumed by D: then there is a model I in which

both C(x) and ¬D(x) hold. The latter constraint implies that there is an element y such that

(i) I |= Q(x, y) (ii) I |= (Pa ◦Rp)(y, z) (iii) I ̸|= (Pa ◦Rq)(y, z).

From (ii), there is an element y′ such that both Pa(y, y′) and Rp(y′, z) hold. Now from C (x), we must have I |= Q(x, y′), and from the inductive hypothesis this im- plies (Rp ⊆Rq)(y′). Then, I |= Rq(y′, z) holds, hence I |= (Pa ◦Rq)(y, z), con- tradicting (iii). The second inductive case is simpler, since one does not need to consider C (x). The interested reader can use it as an exercise. We conclude the proof by showing that the reduction carries over the reﬂexive and transitive closure of ∗→. First, from the semantics in Table 3.2 it follows that Rw ⊆Rw is equivalent to ⊤, which implies also that D ≡⊤. Hence the claim holds also for w ∗→w (i.e., reﬂexivity). For transitivity, the induction is easy: suppose u ∗→v and v ∗→w: then by induction C is subsumed by D1 and by D2, where D1 = ∀Q.(Ru ⊆Rv) and D2 = ∀Q.(Rv ⊆Rw). Then C is subsumed also by D1 ⊓D2 which is equivalent to ∀Q.((Ru ⊆Rv) ⊓(Rv ⊆Rw)). This concept is subsumed by ∀Q.(Ru ⊆Rw), which is the claim.

We now prove the other direction of the reduction.

Lemma 3.35 If v ̸ ∗→w, then the concept C is not subsumed by D.

Proof We give the rule for constructing an inﬁnite tableau branch T and show that it deﬁnes a model that satisﬁes C, and does not satisfy D. The tableau is one-to-one with an inﬁnite automaton accepting the term v, and every other term into which v can be rewritten. Let v[1], . . . , v[n] denote the n letters of v (v[i] is the ith letter of v). Let x, y, z be individual names. Start from the set of assertions

T0 = Pv[1](y, y1), . . . , Pv[i+1](yi, yi+1), . . . , Pv[n](yn−1, z).

Then add role assertions to T following the →⊆-rule:

Condition there is a rewriting rule s →t ∈ρ where s = s[1] · · · s[h] and t = t[1] · · · t[k]; T contains h + 1 individuals y0, . . . , yh and h assertions Ps[i](yi−1, yi) for i ∈{1, . . . , h} T does not contain all assertions P (y y′) P (y′ y )

Action T ′ = T ∪{Pt[1](y0, y′ 1), . . . , Pt[k](y′ k−1, yh)}, where y′ 1, . . . , y′ k−1, are k −1 individual names not occurring in T .

Intuitively, if there is in T a path of role assertions such that Rs(y0, yh) holds, the →⊆-ruleaddsanotherpathsuchthatalso Rt(y0, yh)holds.Ofcourse,Tω canhavean inﬁnite number of individuals and role assertions between them; this is reasonable, since its role paths from y to z are one-to-one with the possible transformations on v one can make using the rewriting rules. One can also think of Tω as an inﬁnite-state automaton accepting v = {u | v ∗→u}. The →⊆-rule always adds new assertions to T , and its application given some premises does not destroy other premises of application of the →⊆-rule itself, since we keep in T all the rewritten terms. Therefore, the construction is monotonic over the ⊆-lattice of all tableaux with a countable number of individuals and role assertions between individuals. Hence there exists a ﬁxpoint Tω. In building Tω, however, a fair strategy must be adopted. That is, if at a given stage Ti of the construction, the →⊆-rule is applicable for individuals y0, . . . , yh, then for some ﬁnite k, in Ti+k the →⊆-rule has been applied for those premises – i.e., a possible rule application is not indeﬁnitely deferred. This could be achieved by, e.g., inserting possible rule applications in a queue.

Proposition 3.36 Let Tω be constructed using the →⊆-rule, and a fair strategy. For every term u = u[1] · · · u[k], v ∗→u iff in Tω there are k −1 individual names y1, . . . , yk−1 and k assertions Pu[1](y, y1), . . . , Pu[k](yk−1, z).

Proof If v ∗→u, then there are a minimum ﬁnite number n of applications of rewriting rules in ρ transforming v into u. By induction on such n, the premises of the →⊆-rule are fulﬁlled, and since Tω is built adopting a fair strategy, from some ﬁnite stage of its construction onwards, Ru(y, z) must hold. For the other direction, if Ru(y, z) holds in Tω, then for each →⊆-rule application leading to Ru(y, z) one can apply a rewriting rule to v, leading to u.

We can now deﬁne the model I satisfying C and not satisfying D. Let N be the set of individual names of Tω. I has domain {x} ∪N. Let I = Tω ∪{Q(x, y)|y ∈ N}. Then I satisﬁes C(x) straightforwardly; moreover, it does not satisfy D from Proposition 3.36.

To prove that subsumption is undecidable in the less expressive Description Logic FL−(◦, =), Schmidt-Schauß [1989] started from the word problem for groups. Starting from the Post correspondence problem with a more complex construction

Patel-Schneider [1989b] proved that subsumption is also undecidable in the more expressive Description Logic FL−(◦, ⊆) plus role inverses, functional roles, and role restrictions. Starting from the word problem – which is less general than the term rewrit- ing problem, but still semidecidable – Baader [1998] showed that subsumption in FL−(◦, ⊆) is undecidable without referring to tableaux. We report here the second part of his proof (corresponding to Lemma 3.35), since it is quite short and elegant, and shows a different way of proving the only-if direction, namely, giving a direct deﬁnition of an inﬁnite structure satisfying the concepts. The word problem follows Deﬁnition 3.30, but considers the reﬂexive- symmetric-transitive closure ∗↔of rewriting rules. This is also known as the word problem for semigroups, or Thue systems. In this case, ground term and word are synonyms. Of course, ∗↔is an equivalence relation on words; let [v] denote the ∗↔-equivalence classes. Note that [u] = [v] iff u ∗↔v. There is a natural multipli- cation on these classes induced by concatenation: [u][v] = [uv] (since ∗↔is even a congruence, this is well-deﬁned). Taking the equivalence classes plus one distinguished element x as the domain of the model I, the roles can be interpreted as

QI = {(x, [u])|u ∈ ∗} (3.19) (Pa)I = {([u], [ua])|a ∈ , u ∈ ∗}. (3.20)

Then, it can be shown that if v ̸ ∗↔w, then x belongs to CI but not to DI, as follows.

(i) x belongs to CI: from (3.20), for every word u we have (x, [u]) ∈QI and ([u], [ua]) ∈ (Pa)I; but also from (3.19), (x, [ua]) ∈QI, hence C (x) is satisﬁed by I. Regarding ∀Q.Cρ(x), suppose ([u], [w]) ∈(Rs)I, where s →t ∈ρ. Then [w] = [us] by deﬁni- tion of (Pa)I. Moreover, from s →t ∈ρ it follows that us ∗↔ut, hence [us] = [ut]. Consequently, ([u], [w]) = ([u], [ut]) ∈(Rt)I from (3.20). (ii) x does not belong to DI: for the empty word ϵ, [ϵ] is a Q-ﬁller of x; however, [ϵ] does not satisfy the concept Rv ⊆Rw. In fact, ([ϵ], [v]) ∈(Rv)I; but ([ϵ], [v]) /∈(Rw)I, since [w] is the only Rw-ﬁller of [ϵ] but [v] ̸= [w] from the assumption that v ̸ ∗↔w.

3.7 Reasoning about individuals in ABoxes

When an ABox is considered, the reasoning problem of instance checking arises: Given an ABox A, an individual a and a concept C, decide whether A |= C(a). For the instance check problem, the size of the input is formed by the size of the concept expression C plus the size of A. Since the size of one input may be much larger than the other in real applications, it makes sense to distinguish the complexity w.r.t. the two inputs – as is usually done in databases with data complexity and query

A common intuition [Schmolze and Lipkis, 1983] about instance checking was that it could be performed via subsumption, using the so-called most speciﬁc con- cept (msc) method.

Deﬁnition 3.37 (Most speciﬁc concepts) Let A be an ABox in a given Description Logic, and let a be an individual in A. A concept C is the most speciﬁc concept of a in A, written msc(A, a), if, for every concept D in the given Description Logic, A |= D(a) implies C ⊑D.

Recall from Chapter 2 a slightly different deﬁnition of msc in the realization prob- lem: given an individual a and an ABox A, ﬁnd the most speciﬁc concepts C (w.r.t. subsumption) such that A |= C(a) [Nebel, 1990a, p. 104]. Since conjunction is always available in every Description Logic, the two deﬁnitions are equivalent (just conjoin all speciﬁc concepts of realization into one msc). Clearly, once msc(A, a) is known, to decide whether a is an instance of a concept D it should be sufﬁcient to check whether msc(A, a) is subsumed by D, turning instance checking into subsumption. Moreover, when a TBox is present, off-line classiﬁcation of all msc’s in the TBox may provide a way to pre-compute many instance checks, providing an on-line speed-up. The intuition about how to compute msc(A, a) was to gather the con- cepts/properties explicitly stated for a in A. However, this approach is quite sensi- tive to the Description Logic chosen to express msc(A, a) and the queries. In fact, most speciﬁc concepts can be easily computed for simple Description Logics, like AL. However, it may not be possible when slightly more expressive languages are considered.

Example 3.38 A simple example (simpliﬁed from [Baader and K¨usters, 1998]) is the ABox made just by the assertion R(a, a). If FL−is used for most speciﬁc concepts and queries, then msc({R(a, a)}, a) = ∃R. However, if qualiﬁed existen- tial quantiﬁcation is allowed for most speciﬁc concepts, then each of the concepts ∃R, ∃R.∃R, ∃R.∃R.∃R, . . . , is more speciﬁc than the previous one. Using this argument, it is possible to prove that msc({R(a, a)}, a) has no ﬁnite representation, unless transitive closure on roles is also allowed. Using the axiom A ⊑∃R.A in an ad hoc TBox, msc({R(a, a)}, a) = A for the simple ABox of this example – but this does not simplify instance checking. An alternative approach would be to raise in- dividuals in the language to express concepts, through the concept constructor {. . .} that enumerates the individuals belonging to it (called “one-of ” in Classic). In that case, msc({R(a, a)}, a) = ∃R.{a} (see [Donini et al., 1990]). But this “solution” to instance checking becomes now a problem for subsumption, which must take individuals into account (for a treatment of Description Logics with one-of, see

The msc method makes an implicit assumption: to work well, the size of msc(A, a) should be comparable with the size of the whole ABox, and in most cases much shorter. However, consider the Description Logic ALE, in which subsumption is in np. Then, solving instance checking by means of subsump- tion in polynomial space and time would imply that instance checking was in np, too. However, suppose that we prove that instance checking is hard for conp. Then, solving instance checking by subsumption implies that either conp ⊆np, or msc(A, a), if ever exists, has superpolynomial size w.r.t. A. The former conclusion is unlikely to hold, while the latter would make unfeasible the entire method of msc’s. In general, this argument works whenever subsumption in a Description Logic belongs to a complexity class C, while instance checking is proved hard for a different complexity class C′, for which C′ ⊆C is believed to be false. We present here a proof using this argument, found by Schaerf [1993; 1994b; 1994a]. We ﬁrst start with a simple example highlighting the construction.

Example 3.39 Let f, c1, c2, x, y, z be individuals, R, P, N be role names, and A be a concept name. Let A be the following ABox, whose structure we highlight by means of arrows between assertions:

R( f, c1) ↗P(c1, x) A(x) ↘N(c1, y)

f ↗

R( f, c2) ↗P(c2, y) ↘N(c2, z) ¬A(z).

↘

The query ∃R.(∃P.A ⊓∃N.¬A)( f ) is entailed by A. That is, one among c1 and c2 has its P-ﬁller in A and its N-ﬁller in ¬A. This can be veriﬁed by case analysis on y: in every model either A(y) or ¬A(y) must be true. For models in which A(y) holds, c2 is the R-ﬁller of f satisfying the query; for models in which ¬A(y) holds, c1 is. Observe that if ALE is used to express most speciﬁc concepts, the best approximation we can ﬁnd for msc(A, f ), by collecting assertions along the role paths starting from f , is the concept C = ∃R.(∃P.A ⊓∃N) ⊓∃R.(∃P ⊓∃N.¬A), in which the fact that the same individual y is both the N-ﬁller of ∃N and the P-ﬁller of ∃P is lost. Indeed, C is not subsumed by the query, as one can see by constructing an open tableau for C ⊓¬∃R.(∃P.A ⊓∃N.¬A)( f ).

The above example can be extended to a proof that deciding A |= C(a), where C is an ALE-concept, is conp-hard. Observe that this is a different source of complexity w.r.t. unsatisﬁability in ALE. In fact, a concept C is unsatisﬁable iff {C(a)} |= ⊥(a). This problem is np-complete when C is a concept in ALE (Subsection 3 3 1)

The source conp-complete problem is the complement of 2+2-sat, which is the following problem.

Deﬁnition 3.40 (2+2-sat) Given a 4CNF propositional formula F, in which every clause has exactly two positive literals and two negative ones, decide whether F is satisﬁable.

The problem 2+2-sat is a simple variant of the well-known 3-sat. Indeed, for 3-literal clauses mixing both positive and negative literals, add a fourth disjunct, constantly false; e.g., X ∨Y ∨¬Z is transformed into the 2+2-clause X ∨Y ∨ ¬Z ∨¬true. Unmixed clauses can be replaced by two mixed ones using a new variable (see [Schaerf, 1994a, Theorem 4.2.6]). Given an instance of 2+2-sat F = C1 ∧C2 ∧· · · ∧Cn, where each clause Ci = Li 1+ ∨Li 2+ ∨¬Li 1−∨¬Li 2−, we construct an ABox AF as follows. AF has one individual l for each variable L in F, one individual ci for each clause Ci, one individual f for the whole formula F, plus two individuals true and false for the corresponding propositional constants. The roles of AF are Cl (for Clause), P1, P2 (for positive literals), N1, N2 (for negative literals), and the only concept name is A. Finally, AF is given by (we group role assertions on ﬁrst individual to ease reading):

 

P1(c1,l1 1+) P2(c1,l1 2+) N1(c1,l1 1−) N2(c1,l1 2−) ... ...

Cl( f, c1)



A(true), ¬A( f alse).

 

P1(cn,ln 1+) P2(cn,ln 2+) N1(cn,ln 1−) N2(cn,ln 2−)

Cl( f, cn)



Now let D be the following, ﬁxed, query concept:

D = ∃Cl.((∃P1.¬A) ⊓(∃P2.¬A) ⊓(∃N1.A) ⊓(∃N2.A)).

Intuitively, an individual name l is in the extension of A or ¬A iff the propositional variable L is assigned true or false, respectively. Then, checking whether AF |= D( f ) corresponds to checking that in every truth assignment for F there exists a clause whose positive literals are interpreted as false, and whose negative literals are interpreted as true – i.e., a clause that is not satisﬁed. If one applies the above idea to translate the two clauses (having just two literals each) false ∨¬Y, Y ∨¬true, one obtains exactly the ABox of Example 3 39

The correctness of this reduction was proved by Schaerf [1993; 1994a]. We report here only the concluding lemma.

Lemma 3.41 A 2+2-CNF formula F is unsatisﬁable if and only if AF |= D( f ).

Hence, instance checking in ALE is conp-hard. This implies that instance check in ALE cannot be efﬁciently solved by subsumption, unless conp ⊆np. We remark that only the size of AF depends on the source formula F, while D is ﬁxed. Hence, instance checking in ALE is conp-hard with respect to knowledge base complexity – and it is also np-hard from Subsection 3.3.1. The upper bound for knowledge base complexity of instance checking in ALE is in p 2, but it is still not known whether the problem is p 2-complete. Regarding combined complexity – that is, neither the size of the ABox nor that of the query is ﬁxed – in [Schaerf, 1994a; Donini et al., 1994b] it was proved that instance checking in ALE is PSpace- complete. Since the above reduction makes use of negated concept names, it may seem that conp-hardness arises from the interaction between qualiﬁed existential quan- tiﬁcation and negated concept names. However, all that is needed are two concepts whose union covers all possible cases. We saw in Subsection 3.2.1 that ∃R and ∀R.B have this property. Therefore, if we replace A and ¬A in AF with ∃R and ∀R.B, respectively (where R is a new role name and B is a new concept name), we obtain a newreductionforwhichLemma3.41stillholds.Hence,instancecheckinginFL−E (i.e., ALE without negation of concept names) is conp-hard too, thus conﬁrming that conp-hardness is originated by qualiﬁed existential quantiﬁcation alone. In other words, intractability arises from a query language containing both qualiﬁed existential quantiﬁcation, and pairs of concepts whose union is equivalent to ⊤. Hence, for languages containing these constructs, the msc method is not effective. Regarding the expressivity of the language for assertions in the ABox, conp- hardness of instance checking arises already when assertions in the ABox involve just concept and role names. However, note that a key point in the reduction is the fact that two individuals in the ABox can be linked via different role paths, as f and y were in Example 3.39.

3.8 Discussion

In this chapter we analyzed various lower bounds on the complexity of reasoning about simple concept expressions in Description Logics. Our presentation appealed to the intuitive notions of exploring AND–OR trees, in the special case when the tree is derived from a tableau. Weremarkthatanalternativeapproachtoreasoningistoreduceittotheemptiness test for automata (e g [Vardi 1996]) which has been quite successfully applied

to temporal logics, and propositional logics of programs. However, till now such techniques have been used to obtain upper bounds in reasoning, while in order to obtain lower bounds one would need a way to reduce problems on automata to un- satisﬁability/subsumption in Description Logic. The only example of this reduction is [Nebel, 1990b], for a very simple Description Logic, which we have omitted in this chapter for lack of space. We end the chapter with a perspective on the signiﬁcance of the np, conp, and PSpace complexity lower bounds we have presented. Present reasoning systems in Description Logics (see Chapter 8) can now cope with reasonable size ExpTime-complete problems. Hence the computational complexity of the problems now reachable is above PSpace. However, in our opinion, for imple- mented systems the signiﬁcance of a reduction lies not just in the theoretical lower bound obtained, but also in the reduction itself. In fact, when experiment- ing with algorithms for subsumption, satisﬁability, etc. [Baader et al., 1992b; Hustadt and Schmidt, 1997] on an implemented system, one can exploit al- ready known “hard” cases of a source problem like 3-sat, 2+2-sat, set split- ting, or qbf validity to obtain “hard” instances for the algorithm under test. These instances isolate the inﬂuence of each source of combinatorial explosion on the performance of the overall reasoning system, and can be used to opti- mize reasoning algorithms in a piecewise fashion [Horrocks and Patel-Schneider, 1999], separately for the various sources of complexity. In this respect, the is- sue of ﬁnding “efﬁcient” reductions (w.r.t. the size of the resulting concepts) is still open, and can make the difference when concepts to be tested scale up (see [Donini and Massacci, 2000]).

3.9 A list of complexity results for subsumption and satisﬁability

Many names have been invented for languages of different Description Logics, e.g., FL for Frame Language, ALC for Attributive Descriptions Language with Complement, etc. Although suggestive, these names are not very explicit about which constructs are in the named language. This makes the huge mass of results about complexity of reasoning in Description Logics often difﬁcult to screen by non-experts in the ﬁeld. To clarify the constructs each language is equipped with, we use two lists of constructors: the ﬁrst one for concept constructors, and the second one for role constructors. For example, the pair of lists (⊓, ∃R, ∀R.C) (⊓, ◦) denotes a language whose concept constructors are conjunction ⊓, unqualiﬁed existential quantiﬁcation ∃R, and universal role quantiﬁcation ∀R.C, and whose role constructors are conjunction ⊓and composition ◦. Many combinations of concept constructors have been given a name which is now commonly used. For instance the ﬁrst list of the above example is known as FL−In these cases

we follow a syntax ﬁrst proposed in [Baader and Sattler, 1996b], and write just FL−(⊓, ◦) – that is, FL−augmented with role conjunction and composition – to make it immediately recognizable by researchers in the ﬁeld.

3.9.1 Notation

In the following catalog, satisﬁability and subsumption refer to the problems with plain concept expressions. When satisﬁability and subsumption are w.r.t. a set of axioms, we state it explicitly. Moreover, when the constructs of the Description Logic allow one to reduce subsumption between C and D to satisﬁability of C ⊓ ¬D, we mention only satisﬁability. In the lists, we have triedto use thesymbol ofthe DLconstruct whenever possible. We have abbreviated some constructs, however: unqualiﬁed number restrictions ⩾nR, ⩽nR are denoted by ≶R, while qualiﬁed number restrictions ⩾n R.C, ⩽n.RC are ≶R.C. When a construct is allowed only for names (either concept names in the ﬁrst list, or role names in the second one) we apply the construct to the word name.

3.9.2 Subsumption in PTime

To the best of the author’s knowledge, no proof of PTime-hardness has been given for any Description Logic so far. Therefore the following results refer only to membership in PTime.

r (⊓, ∃R, ∀R.C) () known as FL−[Levesque and Brachman, 1987]. r (⊓, ∃R, ∀R.C, ¬(name)) () known as AL [Schmidt-Schauß and Smolka, 1991]. r (⊓, ∃R, ∀R.C, ≶R) () known as ALN [Donini et al., 1997a]. r AL(◦), AL(−) [Donini et al., 1999]. r FL−(⊓) [Donini et al., 1991a]. r (⊓, ∃R.C, {individual}) (⊓,−) known as ELIRO1 [Baader et al., 1998b].

3.9.3 np and conp r (⊓, ∃R.C, ∀R.C, ¬(name)) () (known as ALE) subsumption and unsatisﬁability are np- complete [Donini et al., 1992a] (see Subsection 3.3.1). r AL(⊓), ALE(⊓), and (⊓, ∃R.C, ∀R.C) () (known as ALR, ALER and FL−E respec- tively) subsumption and unsatisﬁability are np-complete [Donini et al., 1997a] (see The- orems 3.16, 3.17 for hardness, and [Donini et al., 1992a] for membership). r (⊓, ⊔, ∃R, ∀R.C, ¬(name)) () (known as ALU) subsumption and unsatisﬁability are conp-complete [Donini et al., 1997a] (see Subsection 3.1.1.1). r ALN(−) subsumption is conp-complete, while satisﬁability is decidable in polynomial time [Donini et al., 1999]. r FL−(⊓,−), FL−(⊓, ◦), and FL−(◦,−) [Donini et al., 1999] (see Subsections 3.3.2, 3 3 3 and 3 3 4)

r AL(), satisﬁability w.r.t. a set of acyclic axioms is conp-hard [Buchheit et al., 1994a; Calvanese, 1996b; Buchheit et al., 1998] (conp-complete for ALE() [Calvanese, 1996b]).

3.9.4 PSpace r (⊓, ⊔, ¬, ∃R.C, ∀R.C) () (known as ALC) [Schmidt-Schauß and Smolka, 1991] (see Subsection 3.4.1). r (⊓, ¬(name), ∃R.C, ∀R.C, ≶R) () (known as ALEN) [Hemaspaandra, 1999]. r FL−(R|C) (known as FL), ALN(⊓), ALU(⊓), (⊓, ∃R.C, ∀R.C, ¬, ≶R) (⊓) (known as ALCNR) [Donini et al., 1997a]. r ALC(⊓, ⊔, ◦) satisﬁability [Massacci, 2001]. Membership is nontrivial. r ALE() satisﬁability w.r.t. a set of cyclic axioms is PSpace-complete [Calvanese, 1996b]. r ALN() satisﬁability w.r.t. a set of cyclic axioms of the form A ≡C, where each concept name A can appear only once on the left-hand side, is PSpace-complete [K¨usters, 1998].

3.9.5 ExpTime r AL w.r.t. a set of axioms (see Section 3.5 for hardness). r (⊓, ⊔, ¬, ∃R.C, ∀R.C) (⊔, ◦,∗, id(),−) which includes ALCtrans [Baader, 1991; Schild, 1991]. Membership is nontrivial, and was proved by Pratt [1979] without inverse, and by Vardi and Wolper [1986] for converse-pdl, reducing the problem to emptiness of tree automata. r (⊓, ⊔, ¬, ∃R.C, ∀R.C, ≶name.C, ≶name−.C) (⊔, ◦,∗,−, id()), known as ALCQIreg (see Chapter 5). Membership is nontrivial. r (⊓, ⊔, ¬, ∃R.C, ∀R.C, µx.C[x], {individual}) (−), where µx.C[x] denotes the least ﬁx- point of x [Sattler and Vardi, 2001]. Membership is nontrivial.

3.9.6 NExpTime r adding concrete domains (see [Baader and Hanschke, 1991a]), satisﬁability in ALC w.r.t. a set of acyclic axioms, and ALC(−) [Lutz, 2001a]. r ALC(⊓, ⊔, ¬) satisﬁability [Lutz and Sattler, 2001]. r (⊓, ⊔, ∃R.C, ∀R.C, ¬, {individual}, ≶R.C) () satisﬁability [Tobies, 2001b]. r (⊓, ⊔, ¬, ∃R.C, ∀R.C, ≤≥R)(⊓)(knownasALCNR)satisﬁabilityw.r.t.asetofaxioms (only membership was proved) in [Buchheit et al., 1993a]).

3.9.7 Undecidability results r FL−(◦, =), which is a subset of the language of the knowledge representation sys- tem Kl-One [Schmidt-Schauß, 1989] (see Subsection 3.6.1 for undecidability of FL−(◦, ⊆) ). r FL−(◦, ⊆,−, functionality, R|C), which is a subset of the language of the knowledge representation system Nikl [Patel-Schneider, 1989a]. r () (⊓ ) (kno n as U) [Schild 1989]

r ALCN(◦, ⊔, ), ALCN(◦, ⊓) satisﬁability w.r.t. a set of axioms [Baader and Sattler, 1999].

Acknowledgements

I thank Franz Baader for useful and stimulating discussions on the proofs of Lemmas 3.34, 3.35, and many other comments and help. I am indebted to Maurizio Lenzerini, Daniele Nardi, Werner Nutt and Andrea Schaerf, co-authors of many papers containing results presented in this chapter. I thank also Fabio Massacci for involving me in the experimental evaluation of reasoning algorithms. Giuseppe De Giacomo spent some time discussing automata with me, and Diego Calvanese made helpful comments on an early draft; I thank them both. The work has been supported by the Italian CNR (projects LAICO, DeMAnD, “Metodi di Ragionamento Automatico nella modellazione ed analisi di dominio”), and the Italian MURST (project MOSES).

4

Relationships with other Formalisms

ULRIKE SATTLER DIEGO CALVANESE RALF MOLITOR

Abstract

In this chapter, we are concerned with the relationship between Description Logics and other formalisms, regardless of whether they were designed for knowledge rep- resentation issues or not. We concentrate on those representation formalisms that either (1) had or have a strong inﬂuence on Description Logics (e.g., modal logics), (2) are closely related to Description Logics for historical reasons (e.g., seman- tic networks and structured inheritance networks), or (3) have similar expressive power (e.g., semantic data models). There are far more knowledge representation formalisms than those mentioned in this chapter. For example, “verb-centered” graphical formalisms like those introduced by Simmons [1973] are not mentioned since we believe that their relationship with Description Logics is too weak.

4.1 AI knowledge representation formalisms

In artiﬁcial intelligence (AI), various “non-logical” knowledge representation for- malisms were developed, motivated by the belief that classical logic is inadequate for knowledge representation in AI applications. This belief was mainly based upon cognitive experiments carried out with human beings and the wish to have repre- sentational formalisms that are close to the representations in human brains. In this section, we discuss some of these formalisms, namely semantic networks, frame systems, and conceptual graphs. The ﬁrst two formalisms are mainly presented for historical reasons since they can be regarded as ancestors of Description Logics. In contrast, the third formalism can be regarded as a “sibling” of Description Logics since both have similar ancestors and live in the same time.

4.1.1 Semantic networks

Semantic networks originate in Quillian’s semantic memory models [Quillian, 1967] a graphical formalism designed to represent “word concepts” in a

- has skin - can move around - eats - breathes

Animal

- has wings - can fly - has fins - can swim - has gills

Bird Fish

- has feathers

- can sing - is yellow - can bite - is dangerous Ostrich - has long, thin legs - is tall - can’t fly

Salmon - is pink - is edible - swims upstreams to lay eggs

Canary Shark

Fig. 4.1. A semantic network describing animals.

deﬁnitorial way, i.e., similar to the one that can be found in an encyclopedia deﬁ- nition. This formalism is based on labeled graphs with different kinds of edges and nodes. Besides others, Quillian’s networks allow subclass–superclass edges, and and or edges, and subject–object edges between nodes. Following Quillian’s memory models, a great variety of semantic network formalisms were proposed; an overview of their history can be found in [Brach- man, 1979]. In general, semantic networks distinguish between concepts (de- noted by generic nodes) and individuals (denoted by individual nodes), and be- tween subclass–superclass edges and property edges. Using subclass–superclass links, concepts can be organised in a specialization hierarchy. Using prop- erty edges, properties can be associated to concepts, that is, to the individ- uals belonging to the concept the properties are associated with. Figure 4.1 contains a hierarchy of animals, birds, ﬁshes, etc. Interestingly, the cogni- tive adequacy of this approach was proven empirically [Collins and Quillian, 1970]. The two kinds of edges interact with each other: a property is inherited along subclass–superclass edges – if not modiﬁed in a more speciﬁc class. For ex- ample, birds are equipped with skin because animals are equipped with skin, and birds inherit this property because of the subclass–superclass edge be- tween birds and animals. In contrast, although ostriches are birds, they do not inherit the property “can ﬂy” from birds because this property is “modiﬁed” for ostriches

Intuitively, it should be possible to translate subclass–superclass edges into con- cept deﬁnitions, for example,1

Shark ≡Fish ⊓CanBite ⊓IsDangerous.

According to Brachman [1985], the above translation is not always intended. Subclass–superclass edges can also be read as primitive concept deﬁnitions, that is, they impose only necessary properties but not sufﬁcient ones. Hence the above translation might better be

Shark ⊑Fish ⊓CanBite ⊓IsDangerous.

Due to the lack of a precise semantics, there are even more readings of subclass– superclass edges, which are discussed in [1975; 1977b; 1985]. A prominent reading is that of inheritance by default, which can be speciﬁed in different ways, thus leading to misunderstandings and to the question which of these speciﬁcations is the “right” one (see also Chapter 6). As a consequence of this ambiguity, new formalisms mainly evolved along two lines: (1) To capture inheritance by default, various non-monotonic inheritance sys- tems, respectively various ways of reasoning in non-monotonic inheritance systems, were investigated [Touretzky et al., 1987; 1991; Selman and Levesque, 1993]. (2) To capture the monotonic aspects of semantic networks, a new graphical formalism, structuredinheritancenetworks,wasintroducedandimplementedinthesystemKl- One [Brachman, 1979; Brachman and Schmolze, 1985]. It was designed to cover the declarative, monotonic aspects of semantic networks, and hence did not specify the way in which (non-monotonic multiple) inheritance was supposed to function in conﬂicting situations. Brachman and Schmolze [1985] argue that Kl-One does not allow cancellation or inheritance by default because such mechanisms would make taxonomies meaningless. Indeed, all properties of a given concept could be canceled, so that it would ﬁt everywhere in the taxonomy. Their proposition is to make a strict separation of default assertions and conceptual descriptions. Brachman and Schmolze [1985], besides pointing out the computation of the taxonomy as a core system service, describe the meaning of various concept con- structors that were implemented in Kl-One, for example conjunction, universal value restrictions, role hierarchies, role-value-maps, etc. Moreover, we ﬁnd a clear distinction between individuals and concepts, and between a terminological and an assertional formalism. Later[LevesqueandBrachman,1987],Kl-Onewasprovidedwithawell-deﬁned “Tarski-style” semantics which ﬁxed the precise meaning of its graphical constructs and led to the deﬁnition of the ﬁrst Description Logic [Levesque and Brachman, 1987], at that time also called terminological languages, concept languages, or

1 I th f ll i t d d D i ti L i d ﬁ d i Ch t 2

Kl-One based languages. Besides giving a precise meaning to semantic networks, this formalization allowed the investigation of inference algorithms with respect to their soundness, completeness, and computational complexity. For example, it turned out that subsumption in Kl-One is undecidable, mainly due to role-value- maps [Schmidt-Schauß, 1989].

4.1.2 Frame systems

Minsky [1981] introduced frame systems as an alternative to logic-oriented ap- proaches to knowledge representation, which he thought were not adequate to “simulatecommon-sensethinking”forvariousreasons.Hissystemprovidesrecord- like data structures to represent prototypical knowledge concerning situations and objects and includes defaults, multiple perspectives, and analogies. Nowadays, semantic networks and frame systems are often viewed as the same family of formalisms. However, in standard semantic networks, properties are restricted to primitive, atomic ones, whereas, in general, properties in frame systems can be complex concepts described by frames. One goal of the frame approach was to gather all relevant knowledge about a situation (e.g., entering a restaurant) in one object instead of distributing this knowledge across various axioms. Roughly speaking, a situation (or an object) is described in one frame. A frame contains slots, similar to entries in a record, to represent properties of the situation described by the frame. Reasoning comes in two shapes: (1) Using a “partial matching”, more speciﬁc frames are embedded into more general ones, thus giving, for example, meaning to a new situation or classifying an object as a kind of, say, bird. (2) Searching for slot ﬁllers to collect more information concerning a speciﬁc situation. A variety of expert systems [Fikes and Kehler, 1985; Christaller et al., 1992; Gen, 1995; Flex, 1999] are based on a frame-based formalism and are further enhanced with rules, triggers, daemons, etc. Despite the fact that frame systems were designed as an alternative to logic, the monotonic, declarative part of this formalism could be shown to be captured using ﬁrst-order predicate logic [Hayes, 1977; 1979]. To our knowledge, no precise semantics could be given for the non-declarative, non-logical, or non-monotonic aspects of frame systems. Hence neither their expressive power nor the quality of the corresponding reasoning algorithms and services can be compared with other formalisms. In the remainder of this section, we show how the monotonic part of a frame- based knowledge base can be translated into an ALUN TBox [Calvanese et al., 1994].2 Since there is no standard syntax for frame systems, we have chosen to use

2 N t l th t l ti b t l th l b C l l [1994]

basically the notation adopted by Fikes and Kehler [1985], which is used also in the Kee3 system. A frame deﬁnition is of the form Frame: F in KB F E, where F is a frame name and E is a frame expression, i.e., an expression formed according to the following syntax:

E −→SuperClasses: F1, . . . , Fh MemberSlot: S1 ValueClass: H1 Cardinality.Min: m1 Cardinality.Max: n1 · · · MemberSlot: Sk ValueClass: Hk Cardinality.Min: mk Cardinality.Max: nk.

Fi denotes a frame name, Sj denotes a slot name, m j and n j denote positive integers, and Hj denotes slot constraints. A slot constraint can be speciﬁed as follows:

H −→F | (INTERSECTION H1 H2) | (UNION H1 H2) | (NOT H).

A frame knowledge base F is a set of frame deﬁnitions. For example, Figure 4.2 shows a simple Kee knowledge base describing courses in a university. Cardinality restrictions are used to impose a minimum and maximum number of students that may be enrolled in a course, and to express that each course is taught by exactly one individual. The frame AdvCourse represents courses which enroll only graduate students, i.e., students who already have a degree. Basic courses, on the other hand, may be taught only by professors. Hayes [1979] gives a semantics to frame deﬁnitions by translating them to ﬁrst- order formulae in which frame names are translated to unary predicates, and slots are translated to binary predicates. In order to translate frame knowledge bases to ALUN knowledge bases, we ﬁrst deﬁne the function  that maps each frame expression into an ALUN concept expression as follows: Each frame name F is mapped onto an atomic concept (F), each slot name S onto an atomic role (S), and each slot constraint H onto the corresponding Boolean combination (H) of concepts. Then, every frame

3 Kee is a trademark of Intellicorp. Note that Kee users does not directly specify their knowledge base in this t ti b t ll d t d ﬁ f i t ti l i th hi l t i t f

Frame: Course in KB University MemberSlot: enrolls ValueClass: Student Cardinality.Min: 2 Cardinality.Max: 30 MemberSlot: taughtby ValueClass: (UNION GradStudent Professor) Cardinality.Min: 1 Cardinality.Max: 1

Frame: BasCourse in KB University SuperClasses: Course MemberSlot: taughtby ValueClass: Professor

Frame: Professor in KB University

Frame: Student in KB University

Frame: GradStudent in KB University SuperClasses: Student MemberSlot: degree ValueClass: String Cardinality.Min: 1 Cardinality.Max: 1

Frame: AdvCourse in KB University SuperClasses: Course MemberSlot: enrolls ValueClass: (INTERSECTION GradStudent (NOT Undergrad)) Cardinality.Max: 20

Frame: Undergrad in KB University SuperClasses: Student

Fig. 4.2. A Kee knowledge base.

expression of the form

SuperClasses: F1, . . . , Fh MemberSlot: S1 ValueClass: H1 Cardinality.Min: m1 Cardinality.Max: n1 · · · MemberSlot: Sk ValueClass: Hk Cardinality.Min: mk Cardinality.Max: nk

is mapped into the concept

(F1) ⊓· · · ⊓(Fh) ⊓ ∀(S1).(H1) ⊓⩾m1 (S1) ⊓⩽n1 (S1) ⊓ · · · ∀(Sk).(Hk) ⊓⩾mk (Sk) ⊓⩽nk (Sk).

Making use of the mapping , we obtain the ALUN knowledge base (F) corresponding to a frame knowledge base F, by introducing in (F) an inclusion assertion (F) ⊑(E) for each frame deﬁnition Frame: F in KB F E in F. The ALUN knowledge base corresponding to the Kee knowledge base given in Figure 4.2 is shown in Figure 4.3. The correctness of the translation follows from the correspondence between the set theoretic semantics of ALUN and the ﬁrst order interpretation of frames

Course ⊑ ∀enrolls.Student ⊓⩾2 enrolls ⊓⩽30 enrolls ⊓ ∀taughtby.(Professor ⊔GradStudent) ⊓= 1 taughtby AdvCourse Course ⊓∀enrolls.(GradStudent ⊓¬Undergrad) ⊓⩽20 enrolls BasCourse Course ⊓∀taughtby.Professor GradStudent Student ⊓∀degree.String ⊓= 1 degree Undergrad Student

Fig. 4.3. The ALUN knowledge base corresponding to the Kee knowledge base in Figure 4.2.

r verifying whether a frame F is satisﬁable in a knowledge base and r identifying which of the frames are more general than a given frame

are captured by concept satisﬁability and concept subsumption in ALUN knowl- edge bases. Hence reasoning for the monotonic, declarative part of frame systems can be reduced to concept satisﬁability and concept subsumption in ALUN knowl- edge bases.

4.1.3 Conceptual graphs

Besides Description Logics, conceptual graphs [Sowa, 1984] can be viewed as de- scendants of frame systems and semantic networks. Conceptual graphs (CGs) are a rather popular (especially in natural language processing) and expressive formalism for representing knowledge about an application domain in a graphical way. They are given a formal semantics, e.g., by translating them into (ﬁrst-order) formulae. In the CG formalism, one is, just as for Description Logics, not only interested in representing knowledge, but also in reasoning about it. Reasoning services for CGs are, for example, deciding whether a given graph is valid, i.e., whether the corresponding formula is valid, or whether a graph g is subsumed by a graph h, i.e., whether the formula corresponding to g implies the formula corresponding to h. Since CGs can express all of ﬁrst-order predicate logic [Sowa, 1984], these reasoning problems are undecidable for general CGs. In the literature [Sowa, 1984; Wermelinger, 1995; Kerdiles and Salvat, 1997] one can ﬁnd complete calculi for validity of CGs, but implementations of these calculi may not terminate for for- mulae that are not valid. An approach to overcoming this problem, which has also been employed in the area of Description Logics, is to identify decidable frag- ments of the formalism. The most prominent decidable fragment of CGs is the class of simple conceptual graphs (SGs) [Sowa, 1984], which corresponds to the conjunctive, positive, and existential fragment of ﬁrst-order predicate logic (i.e., existentially quantiﬁed conjunctions of atoms). Even for this simple fragment, how- ever, subsumption is still an np-complete problem [Chein and Mugnier, 1992].4

4 Since SGs are equivalent to conjunctive queries (see also Chapter 16), the np-completeness of subsumption

Although Description Logics and CGs are employed in very similar applications, precise comparisons were published, to our knowledge, only recently [Coupey and Faron, 1998; Baader et al., 1999c]. These comparisons are based on translations of CGs and DL concepts into ﬁrst-order formulae. It turned out that the two formalisms are quite different for several reasons:

(i) CGs are translated into closed ﬁrst-order formulae, whereas DL concepts are translated into formulae in one free variable; (ii) since Description Logics use a variable-free syntax, certain identiﬁcations of variables expressed by cycles in SGs and by co-reference links in CGs cannot be expressed in Description Logics; (iii) in contrast to CGs, most Description Logics considered in the literature only allow unary and binary relations and not relations of arity greater than 2; (iv) SGs are interpreted by existential sentences, whereas almost all Description Logics considered in the literature allow for universal quantiﬁcation.

Possibly as a consequence of these differences, so far no natural fragment of CGs that corresponds to a Description Logic has been identiﬁed. In the sequel, we will illustrate the main aspects of the correspondence result presented by Baader et al. [1999c], which strictly extends the one proposed by Coupey and Faron [1998].

Simple conceptual graphs

Simple conceptual graphs (SGs) as introduced by Sowa [1984] are the most promi- nent decidable fragment of CGs. They are deﬁned with respect to a so-called sup- port. Roughly speaking, the support is a partially ordered signature that can be used to ﬁx the a primitive ontology of a given application domain. It introduces a set of concept types (unary predicates), a set of relation types (n-ary predicates), and a set of individual markers (constants). As an example, consider the support S shown in Figure 4.4, where ⊤is the most general concept type representing the entire domain. The partial ordering on the individual markers is ﬂat, i.e., all individual markers are pairwise incomparable and the so-called generic marker ∗is more gen- eral than all individual markers. In this example, all relation types are assumed to have arity 2 and to be pairwise incomparable except for hasDescendants, which is more general than hasChild. The partial orderings on the types yield a ﬁxed special- ization hierarchy for these types that must be taken into account when computing subsumption relations between SGs. For binary relation types, this partial ordering resembles a role hierarchy in Description Logics. An SG over the support S is a labeled bipartite graph of the form g = (C, R, E, ℓ), where C is a set of concept nodes, R is a set of relation nodes, E ⊆C × R is the edge relation L and l is a labeling of concept nodes

concept types: relation types: individual marker:

⊤ ∗

hasDescendants

CSCourse Human

KR101 PETER MARY

attends hasChild likes

Male Female Student

Fig. 4.4. An example of a support.

g:

h:

Female : Mary c0 Female : ∗ d0

1

2 1 2

hasChild hasChild

hasChild hasChild

2 1

1 2

Student : ∗ c2 Human : ∗ d1 Human : ∗ d2

Human : PETER

c1

2 2

1

1 1

likes likes

attends

2

CScourse : KR101 c3

Fig. 4.5. Two simple graphs.

As an example, consider the SGs depicted in Figure 4.5: the SG g describes a woman Mary having a child who likes its grandfather Peter and who attends the computer science course number KR101; the node d0 in the SG h describes all mothers having a child who likes one of its grandparents. Each concept node is labeled by l with a concept type (such as Female) and a referent, i.e., an individual marker (such as MARY) or the generic marker ∗. A concept node is called generic if its referent is the generic marker; otherwise, it is called an individual concept node. Each relation node is labeled with a relation type r (such as hasChild), and its outgoing edges are labeled with indices according to the arity of r. For example, for the binary relation hasChild, there is one edge labeled with 1 (leading to the parent), and one edge labeled with 2 (leading to the child). Simple graphs are given a formal semantics in ﬁrst-order predicate logic (FOL) by the operator  [Sowa, 1984]: each generic concept node is related to a unique variable, and each individual concept node is related to its individual marker. Concept types and relation types are translated into atomic formulae, and the whole SG g is translated into the existentially closed conjunction of all atoms obtained from the nodes in g

(1) (2) (3)

⊤

Female Student

FemStud

Female: MARY

c0

FemStud: MARY {Female, Student}: MARY

Student: MARY

c1 e0

d0

Fig. 4.6. Expressing conjunction of concept types in SGs.

In our example, this operator yields

(g) = ∃x1.(Female(MARY) ∧Human(PETER) ∧Student(x1) ∧ CScourse(KR101) ∧hasChild(PETER, MARY) ∧ hasChild(MARY, x1) ∧likes(x1, PETER) ∧attends(x1, KR101)),

(h) = ∃x0x1x2.(Female(x0) ∧Human(x1) ∧Human(x2) ∧ hasChild(x1, x0) ∧hasChild(x0, x2) ∧likes(x2, x1)),

where x1 in (g) is (resp. x0, x1, and x2 in (h) are) introduced for the generic concept node c2 (resp. the generic concept nodes d0, d1, and d2). In general, there are three different ways of expressing conjunction of concept types. For example, suppose we want to express that Mary is both female and a student. This can be expressed by an SG containing one individual concept node for each statement (see Figure 4.6(1)).5 A second possibility is to introduce a new concept type in the support for a common specialization of Female(MARY) and Student(MARY) (see Figure 4.6(2)). Finally, such a conjunction can be represented by labeling the corresponding concept node with a set of concept types instead of a single concept type (see Figure 4.6(3); for details on how to handle SGs labeled with sets of concept types see [Baader et al., 1999c]). Subsumption with respect to a support S for two SGs g, h is deﬁned by a so-called projection from h to g [Sowa, 1984; Chein and Mugnier, 1992]: g is subsumed by h w.r.t. S iff there exists a mapping from h to g that (1) maps concept nodes (resp. relation nodes) in h onto more speciﬁc (w.r.t. the partial ordering in S) concept nodes (resp. relation nodes) in g and that (2) preserves adjacency. In our example (Figure 4.5), it is easy to see that g is subsumed by h, since mapping di onto ci for 0 ≤i ≤2 yields a projection w.r.t. S from h to g. Subsumption for SGs is an np-complete problem [Chein and Mugnier, 1992]. In the restricted case where the subsumer h is a tree, subsumption can be decided in polynomial time [Mugnier and Chein, 1992].

5 Note that this solution could not be applied if the individual marker MARY were replaced by the generic marker b th t lti i t d ld b i t t d b diff t i bl

Concept descriptions and simple graphs

In order to determine a Description Logic corresponding to (a fragment of) SGs, one must take into account the differences between Description Logics and CGs mentioned before.

r Most Description Logics only allow role terms corresponding to binary relations and concept descriptions describing connected structures. Thus, Baader et al. [1999c] and Coupey and Faron [1998] restrict their attention to connected SGs over a support S containing only unary and binary relation types. r Due to the different semantics of SGs and concept descriptions (closed formulae vs. for- mulae in one free variable), Coupey and Faron restrict their attention to SGs that are trees. Baader et al. introduce so-called rooted SGs, i.e., SGs that have one distinguished node called the root. An adaption of the operator  yields a translation of a rooted SG g into an FO formula (g)(x0) with one free variable x0. r Since all Description Logics considered in the literature allow conjunction of concepts, Baader et al. allow concept nodes labeled with a set of concept types instead of a single concept type in order to express conjunction of atomic concepts in SGs. Coupey and Faron avoid the problem of expressing conjunction of atomic concepts: they just do not allow (1) conjunctions of atomic concepts in concept descriptions, and (2) individual concept nodes in SGs.

The Description Logic considered by Baader et al., denoted by ELIRO1, allows existential restrictions and intersection of concept descriptions (EL), inverse roles (I), intersection of roles (R), and unary one-of concepts (O1). For the constants occurring in the one-of concepts the unique name assumption applies, i.e., all constants are interpreted as different objects. Coupey and Faron only consider a fragment of the Description Logic ELI. In both papers, the correspondence result is based on translating concept descrip- tions into syntax trees. For example, consider the ELIRO1-concept

C = Female ⊓∃hasChild−.(Human ⊓{PETER}) ⊓ ∃(hasChild ⊓likes).(Male ⊓Student ⊓∃attends.CScourse)

describing all daughters of Peter who have a fond child that is a student attending a computer science course. The syntax tree corresponding to C is depicted on the left-hand side of Figure 4.7. One can show [Baader et al., 1999c] that, if concept descriptions C are re- stricted to contain at most one unary one-of concept in each conjunction, the cor- responding syntax tree TC can be easily translated into an equivalent rooted SG gC that is a tree6 (see Figure 4.7). Conversely, every rooted SG g that is a tree and that contains only binary relation types can be translated into an equivalent

6 I thi t t t t i th l ti b t t dj t t d

TC: c0 : Female

{Female} : ∗ gC: c0

1

2

1

hasChild−

likes ⊓hasChild

hasChild hasChild

likes

1

2 2

c2 : Male, Student c1 : Human, {PETER}

{Human} : PETER

{Male, Student} : ∗

c2 c1

1

attends

attends

2

c3 : CScourse

{CScourse} : ∗

c3

Fig. 4.7. Translating concept descriptions into simple graphs.

ELIRO1-concept description Cg. There are, however, rooted SGs that can be translated into equivalent ELIRO1-concept descriptions though they are not trees. For example, the rooted SG g depicted in Figure 4.5 is equivalent to the concept description

Cg = {MARY} ⊓Female ⊓∃hasChild−.(Human ⊓{PETER}) ⊓ ∃hasChild.(Student ⊓∃attends.({KR101} ⊓CScourse) ⊓∃likes.{PETER}).

In general, the above correspondence result can be strengthened as follows [Baader et al., 1999c]: every rooted SG g containing only binary relation types can be trans- formed into an equivalent rooted SG that is a tree if each cycle in g with more than two concept nodes contains at least one individual concept node. Hence, each such rooted SG can be translated into an equivalent ELIRO1-concept descrip- tion. Note that the SG h with root d0 in Figure 4.5 cannot be translated into an equivalent ELIRO1-concept description Ch because, in ELIRO1, one cannot express that the grandparent (represented by the concept node d1) and the hu- man liked by the child (represented by the concept node d2) must be the same person. The correspondence result between ELIRO1 and rooted SGs allows the tractability result for subsumption between SGs that are trees to be trans- ferred to ELIRO1. Furthermore, the characterization of subsumption based on projections between graphs was adapted to ELIRO1 and other Descrip- tion Logics, e.g., ALE, and is used in the context of inference problems like matching and computing least common subsumers [Baader and K¨usters, 1999; Baader et al., 1999b]. Conversely, the correspondence result can be used as a basis for determining more expressive fragments of conceptual graphs, for which va- lidity and subsumption are decidable. Based on an appropriate characterization of a fragment of conceptual graphs corresponding to a more expressive Description

Logic (like ALC), one could use algorithms for these Description Logics to decide validity or subsumption of graphs in this fragment.

4.2 Logical formalisms

In this section, we will investigate the relationship between Description Logics and other logical formalisms. Traditionally, the semantics of Description Logics is given in a Tarski-style model-theoretic way. Alternatively, it can be given by a translation into predicate logic, where it depends on the Description Logic whether this translation yields ﬁrst-order formulae or whether it goes beyond ﬁrst-order, as is the case for De- scription Logics that allow, e.g., the transitive closure of roles or ﬁxpoints. Due to the variable-free syntax of Description Logics and the fact that concepts denote sets of individuals, the translation of concepts yields formulae in one free variable. Following the deﬁnition by Borgida [1996], a concept C and its translation π(C)(x) are said to be equivalent if and only if, for all interpretations7 I = (I, ·I) and all a ∈I, we have

a ∈CI iff I |= π(C)(a).

A Description Logic DL is said to be less expressive than a logic L if there is a translation that translates all DL-concepts into equivalent L formulae. Such a translation is called preserving. Note that there are various other ways in which equivalence of formulae and logics being “less expressive than” others could have been deﬁned [Baader, 1996a; Kurtonina and de Rijke, 1997; Areces and de Rijke, 1998]. For example, a less strict deﬁnition is the one that only asks the translation to preserve satisﬁability. To start with, we give a translation π that translates ALC-concepts into predicate logic and which will be useful in the remainder of this section. For those familiar with modal logics, note that this translation parallels the one from propositional modal logic [van Benthem, 1983; 1984]; the close relationship between modal logic and Description Logic will be discussed in Subsection 4.2.2. For ALC, the translation of concepts into predicate logic formulae can be deﬁned in such a way that the resulting formulae involve only two variables, say x, y, and only unary and binary predicates. In the following, Lk denotes the ﬁrst-order predicate logic over unary and binary predicates with k variables. The translation is given by two mappings πx and πy from ALC-concepts into L2 formulae in one free variable. Each concept name A is also viewed as a unary predicate symbol, and each role name R is viewed as a binary predicate symbol.

7 I th f ll i i i t t ti b th DL d di t l i i t t ti

For ALC-concepts, the translation is inductively deﬁned as follows:

πx(A) = A(x), πy(A) = A(y), πx(C ⊓D) = πx(C) ∧πx(D), πy(C ⊓D) = πy(C) ∧πy(D), πx(C ⊔D) = πx(C) ∨πx(D), πy(C ⊔D) = πy(C) ∨πy(D), πx(∃R.C) = ∃y.R(x, y) ∧πy(C), πy(∃R.C) = ∃x.R(y, x) ∧πx(C), πx(∀R.C) = ∀y.R(x, y) ⊃πy(C), πy(∀R.C) = ∀x.R(y, x) ⊃πx(C).

Other concept and role constructors that can easily be translated into ﬁrst-order predicate logic without involving more than two variables are inverse roles, con- junction, disjunction, and negation on roles, and one-of.8

If a Description Logic allows number restrictions ⩾n R, ⩽n R, the translation involves either counting quantiﬁers ∃≥n, ∃≤n (and still involves only two variables) or equality (and involves an unbounded number of variables):

πx(⩾n R) = ∃≥ny.R(x, y) = ∃y1, . . . , yn.  i̸= j yi ̸= y j ∧ i R(x, yi) πx(⩽n R) = ∃≤ny.R(x, y) = ∀y1, . . . , yn+1.  i̸= j yi ̸= y j ⊃ i ¬R(x, yi).

For qualiﬁed number restrictions, the translations can easily be modiﬁed with the same effect on the number of variables involved. So far, all Description Logics have been less expressive than ﬁrst-order predicate logic (possibly with equality or counting quantiﬁers). In contrast, the expressive power of a Description Logic including the transitive closure of roles goes beyond ﬁrst-order logic: First, it is easy to see that expressing transitivity (ρ+(x, y) ∧ ρ+(y, z)) ⊃ρ+(x, z) involves at least three variables. To express that a relation ρ+ is the transitive closure of ρ, we ﬁrst need to enforce that ρ+ is a transitive relation including ρ – which can easily be axiomatized in ﬁrst-order predicate logic. Secondly, we must enforce that ρ+ is the smallest transitive relation including ρ – which, as a consequence of the Compactness Theorem, cannot be expressed in ﬁrst-order logic.

Internalization of Knowledge Bases: So far, we have been concerned with pre- serving translations of concepts into logical formulae, and thus could reduce satis- ﬁability of concepts to satisﬁability of formulae in the target logic. In Description Logics, however, we are also concerned with concept consistency and logical im- plication w.r.t. a TBox, and with ABox consistency w.r.t. a TBox. Furthermore, TBoxes differ in whether they are restricted to be acyclic, allow cyclic deﬁnitions, or allow general concept inclusion axioms (see Chapter 2 for details). In ﬁrst-order logic, the equivalent to a TBox assertion is simply a univer- sally quantiﬁed formula, and thus it is not necessary to make the above-mentioned distinction between, for example, pure concept satisﬁability and satisﬁability with

8 I thi th t l ti i t L2 ith t t

respect to a TBox – provided that cyclic TBoxes are read with descriptive semantics [Baader, 1990a; Nebel, 1991] (cyclic TBoxes read with least or greatest ﬁxpoint semantics go beyond the expressive power of ﬁrst-order predicate logic). In the following, we consider only the most expressive form of TBoxes, namely those allowing general concept inclusion axioms. Given a preserving translation π from DL concepts into ﬁrst-order formulae and a TBox T = {Ci ⊑Di | 1 ≤i ≤n}, we deﬁne

n

i=1 (πx(Ci) ⊃πx(Di)).

π(T ) = ∀x.

Then it is easy to show that:

r A concept C is satisﬁable with respect to T iff the formula πx(C) ∧π(T ) is satisﬁable. r A concept C is subsumed by a concept D with respect to T iff the formula πx(C) ∧ ¬πx(D) ∧π(T ) is unsatisﬁable. r Given two index sets I, J, an ABox {Rk(ai, a j) | ⟨i, j, k⟩∈I} ∪{C j(ai) | ⟨i, j⟩∈J} is consistent with T iff the formula 

⟨i, j,k⟩∈I Rk(ai, a j) ∧ 

⟨i, j⟩∈J πx(C j)(ai) ∧π(T )

is satisﬁable, where the ai-s in the formula are constants corresponding to the individuals in the ABox.

Observe that, if all concepts in a TBox T can be translated to L2 (resp. C2), then the translation π(T ) of T is also a formula of L2 (resp. C2). Hence in ﬁrst-order logic, reasoning with respect to a knowledge base (consisting of a TBox and possibly an ABox) is not more complex than reasoning about concept expressions alone – in contrast to the complexity of reasoning for most Description Logics, where considering even acyclic TBoxes can make a considerable difference (for example, see [Calvanese, 1996b; Lutz, 1999a]). This gap is not surprising since ﬁrst-orderpredicatelogicisfarmorecomplexthanmostDescriptionLogics,namely undecidable. In the following, we investigate logics that are more closely related to Descrip- tion Logics, namely restricted variable fragments, modal logics, and guarded frag- ments.

4.2.1 Restricted variable fragments

One way to deﬁne decidable fragments of ﬁrst-order logic is to restrict the set of variables which are allowed inside formulae and the arity of relation symbols. As mentioned in the previous section, we use Lk to denote ﬁrst-order predicate logic over unary and binary predicates with at most k variables Analogously Ck denotes

ﬁrst-order predicate logic over unary and binary predicates with at most k variables and counting quantiﬁers ∃≥n, ∃≤n. With the exception of the Description Logics introduced by Calvanese et al. [1998a] and Lutz et al. [1999], the translation of DL concepts into predi- cate logic formulae involves predicates of arity at most 2. From the translations in the previous section, it follows immediately that

r ALCR is less expressive than L2 and that r ALCNR is less expressive than C2.

As we have shown above, general TBox assertions can be translated into L2 for- mulae. These facts together with the linearity of the translation yield upper bounds for the complexity of ALCR and ALCNR (even though these bounds are far from being tight): L2 and C2 are known to be NExpTime-complete [Gr¨adel et al., 1997a; Pacholski et al., 2000] (for C2, this is true only if numbers in counting quantiﬁers are assumed to be coded in unary, an assumption often made in Description Logics); hence satisﬁability and subsumption with respect to a (possibly cyclic) TBox are in NExpTime for ALCR and ALCNR. However, both L2 and C2 are far more expressive than ALCR and ALCNR, respectively. For example, both logics allow the negation of binary predicates, i.e., subformulae of the form ¬R(x, y). In Description Logics, this corresponds to negation of roles, an operator that is rarely considered in Description Logics, except in the weakened form of difference9 [De Giacomo, 1995; Calvanese et al., 1998a] (exceptions are the work by Mameide and Montero [1993] and Lutz and Sattler [2000b], which deal with genuine negation of roles). Moreover, L2 and C2

allow “global” quantiﬁcation, i.e., formulae of the form ∃x.(x) or ∀x.(x) that talk about the whole interpretation domain. In contrast, quantiﬁcation in Description Logics is, in general, “local”, e.g., concepts of the form ∀R.C only constrain all R-successors of an individual. Borgida [1996] presents a variety of results stating that a certain Description Logic is less expressive than, or as expressive as, a certain fragment of ﬁrst-order logic. We mention only the most important ones:

r ALC extended with

(role constructors) full Boolean operators on roles, inverse roles, cross-product of two concepts, an identity role id, and (concept constructors) individuals (“one-of”),

is as expressive as L2 (and therefore decidable and, more precisely, NExpTime-complete).

9 Difference of roles is easier to deal with than genuine negation, since it does not destroy “locality” of quantiﬁ- ti

r A further extension of this logic with all sorts of role-value-maps is as expressive as L3

(and therefore undecidable).

Since both extensions include full Boolean operators on roles, they can simulate a universal role using the complex role R ⊔¬R, and thus general TBox assertions can be internalized (see Chapter 5). Thus, for these two extensions, reasoning with respect to (possibly cyclic) TBoxes can be reduced to pure concept reasoning – i.e., the TBox can be internalized – and the above complexity results include both sorts of reasoning problems. Later, a second Description Logic was presented that is as expressive as L2 [Lutz et al., 2001a]. In contrast to the logic in [Borgida, 1996], this logic does not allow a role to be built as the cross-product of two concepts, and it does not provide individuals. However, using the identity role id (with idI = {(x, x) | x ∈I} for all interpretations I), we can guarantee that (the atomic concept) N is interpreted as an individual, i.e., a singleton set, using the following TBox axiom:

⊤⊑∃(R ⊔¬R).(N ⊓∀¬id.¬N).

4.2.2 Modal logics

Modal logics and Description Logics have a very close relationship, which was ﬁrst described in [Schild, 1991]. In a nutshell, Schild [1991] points out that ALC can be seen as a notational variant of the multi-modal logic Km. Later, a similar relation- ship was observed between more expressive modal logics and Description Logics [De Giacomo and Lenzerini, 1994a; Schild, 1994], namely between (extensions of) Propositional Dynamic Logic pdl and (extensions of) ALCreg, i.e., ALC extended with regular roles. Following and exploiting these observations, various (complex- ity) results for Description Logics were found by translating results from modal or propositional dynamic logics and the µ-calculus to Description Logics [De Gia- como and Lenzerini, 1994a; 1994b; Schild, 1994; De Giacomo, 1995]. Moreover, upper bounds for the complexity of satisﬁability problems were tightened consid- erably, mostly in parallel with the development of decision procedures suitable for implementations and optimization techniques for these procedures [De Giacomo and Lenzerini, 1995; De Giacomo, 1995; Horrocks et al., 1999]. In the following, we will describe the relation between modal logics and Description Logics in more detail. We start by introducing the basic modal logic K; for a nice introduction and overview see [Halpern and Moses, 1992; Blackburn et al., 2001]. Given a set of propositional letters p1, p2,. . . , the set of formulae of the modal logic K is the smallest set that

r contains p1, p2,. . . , r is closed under Boolean connectives ∧, ∨, and ¬, and r if it contains φ, then it also contains ✷φ and ✸φ.

The semantics of modal formulae is given by so-called Kripke structures M = ⟨S, π, K⟩, where S is a set of so-called states or worlds (which correspond to individuals in Description Logics), π is a mapping from the set of propositional letters into sets of states (i.e., π(pi) is the set of states in which pi holds), and K is a binary relation on the states S, the so-called accessibility relation (which can be seen as the interpretation of a single role). The semantics is then given as follows, where, for a modal formula φ and a state s ∈S, the expression M, s |= φ is read as “φ holds in M in state s”.

M, s |= pi iff s ∈π(pi) M, s |= φ1 ∧φ2 iff M, s |= φ1 and M, s |= φ2 M, s |= φ1 ∨φ2 iff M, s |= φ1 or M, s |= φ2 M, s |= ¬φ iff M, s ̸|= φ M, s |= ✸φ iff there exists s′ ∈S with (s, s′) ∈K and M, s′ |= φ M, s |= ✷φ iff for all s′ ∈S, if (s, s′) ∈K, then M, s′ |= φ.

In contrast to many other modal logics, K does not impose any restrictions on the Kripke structures. For example, the modal logic S4 is obtained from K by restrict- ing the Kripke structures to those where the accessibility relation K is reﬂexive and transitive. Other modal logics restrict K to be symmetric, well-founded, an equiva- lence relation, etc. Moreover, the number of accessibility relations may be different from one. Then we are talking about multi-modal logics, where each accessibility relation Ki can be thought to correspond to one agent, and is quantiﬁed using the multi-modal operators ✷i and ✸i (or, alternatively [i] and ⟨i⟩). For example, Km stands for the multi-modal logic K with m agents. To establish the correspondence between the modal logic Km and the Description Logic ALC, Schild [1991] gave the following translation f from ALC-concepts using role names R1, . . . , Rm to Km:

f (A) = A, f (C ⊓D) = f (C) ∧f (D), f (C ⊔D) = f (C) ∨f (D), f (¬(C)) = ¬( f (C)), f (∀Ri.C) = ✷i( f (C)), f (∃Ri.C) = ✸i( f (C)).

Now, Kripke structures can easily be viewed as DL interpretations and vice versa. Then from the semantics of K and ALC it follows immediately that a is an

instance of an ALC-concept C in an interpretation I iff its translation f (C) holds in a in the Kripke structure corresponding to I. Obviously, we can deﬁne an analogous translation from Km formulae into ALC. There exists a large variety of modal logics for a variety of applications. In the following, we will sketch some of them together with their relation to Description Logics.

Propositional Dynamic Logics are designed for reasoning about the behavior of programs. Propositional Dynamic Logic (pdl) was introduced by Fischer and Ladner [1979], and proven to have an ExpTime-complete satisﬁability problem by Fischer and Ladner [1979] and Pratt [1979]; for an overview, see [Harel et al., 2000]. pdl was designed to describe the (dynamic) behavior of programs: complex programs can be built starting from atomic programs by using non-deterministic choice (∪), composition (;), and iteration (·∗). pdl formulae can be used to describe the properties that should hold in a state after the execution of a complex program. For example, the following pdl formula holds in a state if the following condition is satisﬁed: whenever program α or β is executed, a state is reached where p holds, and there is a sequence of alternating executions of α and β such that a state is reached where ¬p ∧q holds:

[α ∪β]p ∧⟨(α; β)∗⟩(¬p ∧q).

Its DL counterpart, ALCreg, was introduced independently by Baader [1991]. ALCreg is the extension of ALC with regular expressions over roles10 and can be seen as a notational variant of Propositional Dynamic Logic. For this corre- spondence, see the work by Schild [1991] and De Giacomo and Lenzerini [1994a], and Chapter 5. There exist a variety of extensions of pdl (or ALCreg), for example with inverse roles, counting, or difference of roles, most of which still have an Exp- Time satisﬁability problem; see, e.g., [Kozen and Tiuryn, 1990; De Giacomo, 1995; De Giacomo and Lenzerini, 1996] and Chapter 5.

The µ-calculus can be viewed as a generalization of dynamic logic, with simi- lar applications, and was introduced by Pratt [1981] and Kozen [1983]. It is ob- tained from multi-modal Km by allowing (least and greated) ﬁxpoint operators to be used on propositional letters. For example, for µ the least ﬁxpoint operator and X a variable for propositional letters, the formula µX.p ∨⟨α⟩X describes the states with a (possibly empty) chain of α edges into a state in which p holds. In pdl, this formula is written ⟨α∗⟩p, and its ALCreg counterpart is ∃R∗ α.p. However, the µ-calculus is strictly more expressive than pdl or ALCreg: for example, the

10 Regular expressions over roles are built using union (⊔), composition (◦), and the Kleene operator (·∗) on roles d b d i ALC t i th l f t i l ( Ch t 5)

µ-calculus can express well-foundedness of a program (binary relation), i.e., there is a µ-calculus formula that has only models in which α is interpreted as a well- founded relation (that is, a relation without any inﬁnite chains). In [De Giacomo and Lenzerini, 1994b; 1997; Calvanese et al., 1999c], this additional expressive power is shown to be useful in a variety of DL applications. The DL counterpart of the µ-calculus extended with number restrictions [De Giacomo and Lenzerini, 1994b; 1997] and additionally with inverse roles [Calvanese et al., 1999c] is proven to have an ExpTime-complete satisﬁability problem. There are two other classes of Description Logics with other forms of ﬁxpoints: in Description Logics, ﬁxpoints ﬁrst came in through (1) the transitive closure op- erator [Baader, 1991], which is naturally deﬁned using a least ﬁxpoint, and (2) ter- minological cycles [Baader, 1990a], which have a different meaning according to whether a greatest, least, or arbitrary ﬁxpoint semantics is employed [Nebel, 1991; Baader, 1996b; K¨usters, 1998].

Temporal logics are designed for reasoning about time-dependent information. They have applications in databases, automated veriﬁcation of programs, hardware, distributed systems, natural language processing, planning, etc. and come in various shapes; for a survey of temporal logics, see, e.g., [Gabbay et al., 1994]. Firstly, they can differ in whether the basic temporal entities are time points or time intervals. Secondly, they differ in whether they are based on a linear or on a branching temporal structure. In the latter structures, the ﬂow of time might “branch” into various succeeding future times. Finally, they differ in the underlying logic (e.g., Boolean logic or ﬁrst-order predicate logic) and in the operators provided to speak about the past and the future (e.g., operators that refer to the next time point, to all future time points, to a future time point and all its respective future time points, etc.). In contrast to some other modal logics, temporal logics do not have very close Description Logic relatives. However, they are mentioned here because they are used to “temporalize” Description Logics; for a survey on temporal Description Logics, see [Artale and Franconi, 2001] and Chapter 6. When speaking of the “temporalization” of a logic, e.g., ALC, one usually refers to a logic with two- dimensional interpretations. One dimension refers to the ﬂow of time, and each state in this ﬂow of time comprises an interpretation of the underlying logic, e.g., an ALC interpretation. Obviously, the logic obtained depends on the tem- poral logic chosen for the temporal dimension and on the underlying (descrip- tion) logic. Moreover, one has the choice of requiring that the interpretation domain of each time point is the same for all states (“constant domain assump- tion”) or that it is a subset of the domains of the interpretations underlying future states Examples of temporalized Description Logics can be found in [Wolter and

Zakharyaschev, 1999d; Sturm and Wolter, 2002; Artale et al., 2001; Schild, 1993; Lutz et al., 2001b]. An alternative to this temporalization is to extend a Descrip- tion Logic with a temporal concrete domain [Baader and Hanschke, 1991a]. This yields a “two-sorted” interpretation domain, consisting of abstract individuals on the one hand and time points or intervals on the other hand. Abstract individuals are then related to the temporal structure using features (functional roles) and the standard concrete domain constructs. An example of such a logic is described by Lutz [2001a].

Hybrid logics extend standard modal logics with the ability to refer to single states (individuals in the interpretation domain) using so-called nominals (see, e.g., [Blackburn and Seligman, 1995; Areces et al., 2000; Areces, 2000] for hybrid logics related to Description Logics). Nominals are simply special propositional variables which hold in exactly one state. Hybrid logics enjoy a variety of “nice” properties whose description goes beyond the scope of this article; for a summary, see [Areces, 2000]. In Description Logics, there are three standard ways to refer to individuals: (1) we can use ABox individuals in ABoxes, (2) we can use the “one- of” concept constructor {o1, . . . , ok} which can be applied to individual names oi and which is present in only a few Description Logics (e.g., in the Description Logic described in [Bresciani et al., 1995]), and (3) we can use nominals in a similar way as in hybrid logics (e.g., [De Giacomo, 1995; Tobies, 2000; Horrocks and Sattler, 2001]), namely as special atomic concepts that are interpreted as singleton sets. For most Description Logics, there is a direct mapping between nominals and the “one- of” constructor and back: let oi stand for individual names and, at the same time, nominals. Then we can extend the translation f mentioned above to the “one-of” constructor as follows – provided that we make the unique name assumption (see Chapter 2) either for both the individual names and the nominals or for neither of them:

f ({o1, . . . , ok}) = f ({o1} ⊔· · · ⊔{ok}) = o1 ∨· · · ∨ok.

ABox individuals can be viewed as a restricted form of nominals, and each ABox in a Description Logic L can be translated into a single concept of (the extension of) L with conjunction, existential restriction, and “one-of”: ﬁrst, translate each assertion of the form

C(a) into {a} ⊓C and R(a, b) into {a} ⊓∃R.{b}.

Next, for C1, . . . , Cm the resulting concepts of this translation and U a role name not occurring in any Ci, deﬁne C = ⊓∃U.Ci. Then each model of

C is a model of the original ABox – provided, again, that the unique name as- sumption holds either for both individual names and nominals or for neither. Vice versa, each model of the original ABox can easily be extended to a model of C. So far, we have only mentioned the weakest way in which nominals occur in hybrid logics. The next stronger form is formulae of the form ϕ@oi which de- scribes, intuitively, that ϕ holds in the state oi. For U a universal role and Cϕ the translation of ϕ, this formula corresponds to the concept ∃U.(oi ⊓Cϕ). Finally, we only point out that there are even more expressive ways of talking about nominals in hybrid logics using, for example, variables for nominals and quantiﬁcation over them. So much for the relation between certain modal logics and certain Description Logics. In the remainder of this section, the relationship between standard DL constructors and their counterpart in modal logics is discussed.

Number restrictions: In modal logics, the equivalent to qualiﬁed number restric- tions ⩾n R.C and ⩽n R.C [Hollunder and Baader, 1991b] is known as graded modalities [Fine, 1972; Van der Hoek and de Rijke, 1995], whereas no equivalent to the standard, weaker form of number restrictions, ⩾n R and ⩽n R, has been considered explicitly. Number restrictions can be said to play a central role in Description Logics: they are present in almost all knowledge representation systems based on Description Logics, several variants have been investigated with respect to their computational complexity (e.g., see [Tobies, 1999c] for qualiﬁed number restrictions, [Baader and Sattler, 1999] for symbolic number restrictions and number restrictions on complex roles), and it was proved by De Giacomo and Lenzerini [1994a] that reasoning with respect to (possibly cyclic) TBoxes for the DL equivalent to converse-pdl extended with qualiﬁed number restrictions (on atomic and inverse atomic roles) is ExpTime- complete. Incontrast,theyplayaminorroleinmodalanddynamiclogics.Amoreprominent role in dynamic logics is played by deterministic programs, i.e., programs that are to be interpreted as functional relations (see Chapter 2). Ben-Ari et al. [1982] and Parikh [1981] show that validity (and hence satisﬁability) of dpdl (i.e., the logic that is obtained from pdl by restricting programs to be deterministic) is ExpTime- complete. Moreover, Parikh [1981] has shown that pdl formulae can be linearly translated into dpdl formulae, and this translation was used by De Giacomo and Lenzerini [1994a] to code qualiﬁed number restrictions into dpdl formulae. As a consequence, we have that satisﬁability and subsumption with respect to (possibly cyclic) TBoxes in ALC extended with regular expressions over roles and qualiﬁed number restrictions is in ExpTime

Transitivity: In modal logics and Description Logics, transitivity comes in (at least) two different shapes, as transitive roles (or frames whose accessibility relation is transitive, as in K4m) and as the transitive closure operator on roles (or the Kleene star operator on programs in pdl). Interestingly, these two sorts of transitivity differ in their complexity. Fischer and Ladner [1979] prove that satisﬁability in pdl is ExpTime-complete. However, the only operator on programs (or roles) used in the hardness proof is the transitive closure operator. Translated to Description Logics, this yields ExpTime- completeness of satisﬁability in ALC extended with the transitive closure operator on roles. In contrast, K4m is known to be of the same complexity as Km (or ALC), namely PSpace-complete [Halpern and Moses, 1992], while providing tran- sitivity: K4m is obtained from Km by restricting Kripke structures to those where the accessibility relations are transitive. Translated into Description Log- ics, this means that concept satisﬁability in ALC extended with transitive roles (i.e., the ability to say that certain roles are interpreted as transitive relations) is in PSpace [Sattler, 1996]. An extension of this Description Logic with role hierarchies was implemented in the Description Logic system Fact [Hor- rocks, 1998a]. Although pure concept satisﬁability of this extension is Exp- Time-hard, its highly optimized implementation behaves quite well [Horrocks, 1998b].

Inverse roles: Without the converse operator on programs/time (or the inverse operator on roles), binary relations are restricted to be used asymmetrically: for example, one is restricted to modeling either “into the future” or “into the past”, or one must decide whether to use a role “has-child” or “is-child-of”, but may not use both and relate them in the proper way. Hence in both modal and Description Logics, the converse/inverse operator plays an important role since it overcomes this asymmetry, and a variety of logics allowing this operator have been investigated [Streett, 1982; Vardi, 1985; De Giacomo and Massacci, 1996; Calvanese, 1996a; De Giacomo, 1996; Horrocks et al., 1999].

4.2.3 Guarded fragments

Andr´eka et al. [1996] introduce guarded fragments as natural generalizations of modal logics to relations of arbitrary arity. Their deﬁnition and investigation was motivated by the question why modal logics have such “nice” properties, e.g., ﬁnite axiomatizability, Craig interpolation, and decidability. Guarded fragments are obtained from ﬁrst order logic by allowing the use of quantiﬁed variables only

if these variables are guarded by appropriate atoms11 before they are used in the body of a formula. More precisely, quantiﬁers are restricted to appear only in the form

∃y(P(x, y) ∧(y)) or ∀y(P(x, y) ⊃(y)) (First Guarded Fragment) ∃y(P(x, y) ∧(x, y)) or ∀y(P(x, y) ⊃(x, y)) (Guarded Fragment)

for atoms P, vectors of variables x and y, and (ﬁrst) guarded fragment formulae  with free variables in y and x (resp. in y). The loosely guarded fragment further allows a restricted form of conjunction as guards. Obviously, the translation (∃y.R(x, y) ∧ϕ(y))(x) of the K formula ✸ϕ (or of the ALC concept ∃R.Cϕ) is a formula in the ﬁrst guarded fragment since the quantiﬁed variable y is “guarded” by R. A more complex guarded fragment formula is

∃z1, z2.(parents(x, z1, z2) ∧(married(z1, z2) ∧(∀y.parents(y, z1, z2) ⊃rich(y))))

in one free variable x, a guard atom parents, and describing all those persons that have married parents and whose siblings (including oneself) are rich. All guarded fragments have been shown to be decidable [Andr´eka et al., 1996]. Gr¨adel [1999] proves that satisﬁability of the guarded fragment is in ExpTime – provided that the arity of the predicates is bounded – and 2ExpTime-complete for unbounded signatures. Interestingly, the guarded fragment was shown to re- main in 2ExpTime when extended with ﬁxpoints [Gr¨adel and Walukiewicz, 1999]. These “nice” properties together with their close relationship to modal logics and Description Logics suggest that they are a good starting point for the development of a Description Logic with n-ary predicates [Gr¨adel, 1998]: in [Lutz et al., 1999], a restriction of the guarded fragment was proven to be PSpace-complete, where the restriction concerns the way in which variables are used in guard atoms. Roughly speaking, each predicate A comes with a two-fold arity (i, j) and, when A is used as a guard, either all ﬁrst i variables are quantiﬁed and none of the last j are or, symmetrically, all last j variables are quantiﬁed and none of the ﬁrst i are. Hence one might think of the predicates as having two-fold “groupings”. A similar logic, the so-called action-guarded fragment AGF, is proposed in [Gon¸calv`es and Gr¨adel, 2000]: it comes with a similar grouping of variables in predicates (which is, when extended with “inverse actions”, the same as the grouping in [Lutz et al., 1999]) and, additionally, it divides predicates into those allowed as guards and those allowed in the body of formulae. From a DL perspective, this should not be too severe a restriction since it parallels the distinction between role and concept names. Inter- estingly, the extension of AGF with counting quantiﬁers (the ﬁrst-order counterpart of number restrictions), inverse actions, and ﬁxpoints yields an ExpTime logic – provided that the arity of the predicates is bounded and that numbers in counting

11 At f l P( ) h P i k di t b l d i bl

quantiﬁers are coded unarily [Gon¸calves and Gradel, 2000]. This result is even more interesting when we note that the guarded fragment, when extended with number restrictions, functional restrictions, or transitivity (i.e., statements saying that certain binary relations are to be interpreted as transitive relations) becomes undecidable [Gr¨adel, 1999]. To the best of our knowledge, the only other n-ary Description Logics with sound and complete inference algorithms are DLR [Calvanese et al., 1998a] and DLRµ [Calvanese et al., 1999c], which seem to be orthogonal to the guarded fragment. An exact description of the relationship between DLR (resp. DLRµ) and the guarded fragment (resp. its extension with ﬁxpoints) is missing so far.

4.3 Database models

In this section we will describe the relationship between Description Logics and data models used in databases. We will consider both traditional data models used in the conceptual modeling of an application domain, such as semantic and object- oriented data models, and more recently introduced formalisms for representing semistructured data and data on the web. We will concentrate on the relationship between the formalisms and refer to Chapter 16 for a more detailed discussion on the use of Description Logics in data management [Borgida, 1995].

4.3.1 Semantic data models

Semantic data models were introduced primarily as formalisms for database schema design [Abrial, 1974; Chen, 1976], and are currently adopted in most of the database and information system design methodologies and Computer Aided Software Engineering (CASE) tools [Hull and King, 1987; Batini et al., 1992]. In semantic data models, classes provide an explicit representation of ob- jects with their attributes and their relationships to other objects, and subtype– supertype relationships are used to specify the inheritance of properties. Here, we concentrate on the Entity–Relationship (ER) model [Chen, 1976; Teorey, 1989; Batini et al., 1992; Thalheim, 1993], which is one of the most widespread semantic data models. However, the considerations we make hold also for other formalisms for conceptual modeling, such as UML class diagrams [Rumbaugh et al., 1998; Jacobson et al., 1998].

4.3.1.1 Formalization

The basic elements of the ER model are entities, relationships, and attributes, which are used to model the domain of interest by means of an ER schema

name/String

code/Integer

serv cust

Registration Customer

Service

(1,∞) (0,∞)

loc

(1,1)

(0,∞)

serv

(exclusive, complete)

Location

Supply

com

Business Customer Private Customer

SSN/String city/String street/String

(0,20)

ﬁeld/String Department

name/String

Fig. 4.8. An Entity–Relationship schema.

Figure 4.8 shows a simple ER schema representing the registration of customers for (telephone) services provided by departments (e.g., of a telephone company). The schema is drawn using the standard graphical ER notation, in which entities are represented as boxes, and relationships as diamonds. An attribute is shown as a circle attached to the entity for which it is deﬁned. An entity type (or simply entity) denotes a set of objects, called its instances, with common properties. Elementary properties are modeled through attributes, whose values belong to one of several predeﬁned domains, such as Integer, String, Boolean, etc. Relationships between instances of different entities are modeled through relationship types (or simply relationships). A relationship denotes a set of tuples, each one representing an association among a combination of instances of the entities that participate in the relationship. The participation of an entity in a relationship is called an ER role and has a unique name. It is depicted by connecting the relationship to the participating entity. The number of ER roles for a relationship is called its arity. Cardinality constraints can be attached to an ER role in order to restrict the minimum or maximum number of times an instance of an entity may participate via that ER role in instances of the relationship [Abrial, 1974; Grant and Minker, 1984; Lenzerini and Nobili, 1990; Ferg, 1991; Ye et al., 1994; Thalheim, 1992; Calvanese and Lenzerini, 1994b]. Minimal and maximal cardinality constraints can be arbitrary non-negative integers. However, typical values for minimal cardinality constraints are 0, denoting no constraint, and 1, denoting mandatory participation of theentityintherelationship;typicalvaluesformaximalcardinalityconstraintsare1, denoting functionality, and ∞, denoting no constraint. In Figure 4.8, cardinality constraints are used to impose that each customer must be registered for at least one service. Also, each service is provided by exactly one department, which in turn may not provide more than 20 different services. To represent inclusions between the sets of instances of two entities or two rela- tionships, so called IS-A relations are used. An IS-A relation states the inheritance of properties from a more general entity (resp relationship) to a more speciﬁc one A

generalization is a set of IS-A relations which share the more general entity (resp. re- lationship). Multiple generalizations can be combined in a generalization hierarchy. A generalization can be mutually exclusive, meaning that all the speciﬁc entities (resp. relationships) are mutually disjoint, or complete, meaning that the union of the more speciﬁc entities (resp. relationships) completely covers the more general entity (resp. relationship). In Figure 4.8, a mutually exclusive and complete generalization is used to represent the fact that customers are partitioned into private and business customers. Additionally, keys are used to represent the fact that an instance of an entity is uniquely identiﬁed by a certain set of attributes, or that an instance of a relation- ship is uniquely identiﬁed by a set of instances of the entities participating in the relationship. Although we do not provide a formal deﬁnition here, the semantics of an ER schema can be given by specifying which database states are consistent with the information structure represented by the schema; for details see e.g., [Calvanese et al., 1999e]. Traditionally, the ER model has been used in the design phase of commercial applications, and modern CASE tools usually provide sophisticated schema editing facilities and automatic generation of code for the interaction with the database management system. However, these tools do not provide any support beyond the graphical user interface, for dealing with the complexity of schemas. In particular, the designer is responsible for checking schemas for important properties such as consistency and redundancy. This may be a complex and time-consuming task if performed by hand. By translating an ER schema into a DL knowledge base in such a way that the veriﬁcation of schema properties corresponds to traditional DL reasoning tasks, the reasoning facilities of a DL system can be proﬁtably exploited to support conceptual database design.

4.3.1.2 Correspondence with Description Logics

Both in Description Logics and in the ER model, the domain of interest is mod- eled through classes and relationships, and various proposals have been made for establishing a correspondence between the two formalisms. Bergamaschi and Sartori [1992] provide a translation of ER schemas into acyclic ALN knowledge bases. However, due to the limited expressiveness of the target language, several features of the ER model and desired reasoning tasks could not fully be captured by the proposed translation. Indeed, when relating the ER model to Description Logics, one has to take into account the following aspects:

(i) The ER model allows relations of arbitrary arity, while in traditional Description Logics only unary and binary relations are considered

Registration ⊑ ∀custRegistration.Customer ⊓= 1 custRegistration ⊓ ∀locRegistration.Location ⊓= 1 locRegistration ⊓ ∀servRegistration.Service ⊓= 1 servRegistration Supply ⊑ ∀servSupply.Service ⊓= 1 servSupply ⊓ ∀comSupply.Customer ⊓= 1 comSupply

Customer ⊑ ∀custRegistration−.Registration ⊓⩾1 custRegistration−

Location ⊑ ∀locRegistration−.Registration Service ⊑ ∀servRegistration−.Registration ⊓ ∀servSupply−.Supply ⊓= 1 servSupply−

Department ⊑ ∀comSupply−.Supply ⊓⩽20 comSupply−

Customer ⊑ BusinessCustomer ⊔PrivateCustomer BusinessCustomer ⊑ Customer PrivateCustomer ⊑ Customer ⊓¬BusinessCustomer Customer ⊑ ∀name.String ⊓= 1 name

Fig. 4.9. Part of the knowledge base corresponding to the Entity–Relationship schema in Figure 4.8.

(ii) The assumption of acyclicity is unrealistic in an ER schema, while it is common in DL knowledge bases. (iii) Database states are considered to be ﬁnite structures, while no assumption on ﬁniteness is usually made on the interpretation domain of a DL knowledge base.

Before discussing these issues in more detail, we show in Figure 4.9 part of the ALUNI knowledge base corresponding to the ER schema in Figure 4.8, derived according to the translation proposed by Calvanese et al. [1994; 1999e]. We have omitted the part corresponding to the translation of most attributes, showing as an example only the translation of the attribute name of the entity Customer. Due to point (i), when translating ER schemas into knowledge bases of a tradi- tional Description Logic, it becomes necessary to reify relationships, i.e., to translate each relationship into a concept whose instances represent the tuples of the relation- ship. Each entity is also translated into a concept, while each ER role is translated into a Description Logic role. Then, using functional roles, one can enforce that each instance of the atomic concept C corresponding to a relationship R represents a tuple of R, i.e., for each role representing an ER role of R, the instance of C is connected to exactly one instance of the entity associated to the ER role. There is, however, one condition, which is implicit in the semantics of the ER model, but which does not necessarily hold once relationships are reiﬁed, and which can also not be enforced in Description Logics on the models of a knowledge base: the condition is that the extension of a relationship R does not contain some tuple twice. After reiﬁcation this corresponds to the fact that there are no two instances of the concept corresponding to R that are connected through all roles of R exactly to the same instances of the entities associated to the roles. However, it can be shown that, when reasoning on a knowledge base corresponding to an ER schema, nothing is lost by ignoring this condition Indeed given an arbitrary model of such

a knowledge base, one can always ﬁnd a model in which the condition holds, and thus one that corresponds directly to a legal database state [Calvanese et al., 1994; De Giacomo, 1995; Calvanese et al., 1999e]. Cardinality constraints are translated using number restrictions on the inverse of the roles connecting relationships to entities. To avoid the need for qualiﬁed number restrictions, in the translation in Figure 4.9 we have disambiguated the roles by appending to their name the name of the relationship they belong to. An alternative would be to allow the same role to appear in several places, and use qualiﬁed number restrictions instead of unqualiﬁed ones. While considerably complicating the language, this makes it possible to translate also IS-A relations between relationships, which cannot be captured using the translation proposed by Calvanese et al. [1999e]. Also more general forms of cardinality constraints have been proposed for the ER model [Thalheim, 1992], allowing one, e.g., to limit the number of locations a customer may be registered for, independently of the service. To the best of our knowledge, such types of cardinality constraints cannot be cap- tured in Description Logics in general. Borgida and Weddell [1997] have studied reasoning in Description Logics in the presence of functional dependencies that are more general than unary ones, and which allow one to represent keys of rela- tions. Decidability of reasoning in a very expressive Description Logic augmented with non-unary key constraints has been shown by Calvanese et al. [2000b], and Calvanese et al. [2001a] have shown that also general functional dependencies can be added without losing ExpTime-completeness. IS-A relations are simply translated using concept inclusion assertions. General- ization hierarchies additionally require negation, if they are mutually disjoint, and union, if they are complete. With respect to point (ii), we observe that the translation of an ER schema containing cycles obviously gives rise to a cyclic DL knowledge base. However, due to the necessity of properly relating a relationship via an ER role to an entity, even when translating an acyclic ER schema, the resulting knowledge base contains cycles. On the other hand, it is sufﬁcient to use inclusion assertions rather than equivalence, since the former naturally correspond to the semantics of ER schemas. With respect to point (iii), we observe that one cannot simply ignore it and adopt algorithms that reason with respect to arbitary models. Indeed, the ER model itself does not have the ﬁnite model property [Cosmadakis et al., 1990; Calvanese and Lenzerini, 1994b], which states that, if a knowledge base (resp. schema) has an arbitrary, possibly inﬁnite model (resp. database state), then it also has a ﬁnite one (see also Chapter 5 for more details). A further conﬁrmation comes from the fact that, for correctly capturing ER schemas in Description Logics, possibly cyclic knowledge bases expressed in a Descrip- tion Logic including functional restrictions and inverse roles are required and

such knowledge bases do not have the ﬁnite model property [Calvanese et al., 1994; 1999e]. Therefore one must resort to techniques for ﬁnite model reasoning. Calvanese et al. [1994] show that reasoning w.r.t. ﬁnite models in ALUNI knowledge bases containing only inclusion assertions is ExpTime-complete, and Calvanese [1996a] presents a 2ExpTime algorithm for reasoning in ALCQI knowl- edge bases with general inclusion assertions.

4.3.1.3 Applications of the correspondence

The study of the correspondence between Description Logics and semantic data models has led to signiﬁcant advantages in both ﬁelds. On the one hand, the richness of constructs that is typical of Description Logics makes it possible to add them to semantic data models and take them fully into account when reasoning on a schema [Calvanese et al., 1998g]. Notable examples are:

r the ability to specify not only IS-A and generalization hierarchies, but also arbitrary Boolean combinations of entities or relationships, which can correspond to forms of negative and incomplete knowledge [Di Battista and Lenzerini, 1993]; r the ability to reﬁne properties along an IS-A hierarchy, such as restricting the numeric range for cardinality constraints, or reﬁning the participation in relationships using uni- versal quantiﬁcation over roles; r the ability to deﬁne classes by means of equality assertions, and not only to state necessary properties for them.

The correspondence between semantic data models and Description Logics has been recently exploited to add such advanced capabilities to CASE tools. A notable example is the i•com tool [Franconi and Ng, 2000] for conceptual modeling, which combines a user-friendly graphical interface with the ability to automatically infer properties of a schema (e.g., inconsistency of a class, or implicit IS-A relations) by invoking the Fact Description Logic reasoner [Horrocks, 1998a; 1999]. On the other hand, the basic ideas behind the translation of semantic data mod- els into Description Logics, namely reiﬁcation and the fact that one can restrict the attention to models in which distinct instances of a reiﬁed relation correspond to dis- tinct tuples, have led to the development of Description Logics in which relations of arbitrary arity are ﬁrst class citizens [De Giacomo and Lenzerini, 1994c; Calvanese et al., 1997; 1998a]. Using such Description Logics, the translation of an ER schema is immediate, since now relationships of arbitrary arity also have their direct coun- terpart. For example, using DLR [Calvanese et al., 1998a], the part of the schema in Figure 4.8 relative to the ternary relation Registration can be translated as follows:

Registration ⊑ ($1: Customer) ⊓($2: Location) ⊓($3: Service) Customer ⊑ ∃[$1]Registration.

Description Logics could also be considered as expressive variants of semantic data models with incorporated reasoning facilities. This is of particular importance in the context of information integration, where a high expressiveness is required to capture in the best possible way the complex relationships that hold between data in different information sources [Levy et al., 1995; Calvanese et al., 1998d; 1998e].

4.3.2 Object-oriented data models

Object-oriented data models have been proposed recently with the goal of devising database formalisms that could be integrated with object-oriented programming systems [Abiteboul and Kanellakis, 1989; Kim, 1990; Cattell and Barry, 1997; Rumbaugh et al., 1998]. Object-oriented data models rely on the notion of object identiﬁer at the extensional level (as opposed to traditional data models which are value-oriented) and on the notion of class at the intensional level. The structure of the classes is speciﬁed by means of typing and inheritance. Since we aim at dis- cussing the relationship with Description Logics, which are well-suited to describe structural rather than dynamic properties, we restrict our attention to the structural component of object-oriented models. Hence we do not consider all those aspects that are related to the speciﬁcation of the behavior and evolution of objects, which nevertheless constitute an important part of these data models. Although in our discussion we do not refer to any speciﬁc formalism, the model we use is inspired by the one presented by Abiteboul and Kanellakis [1989], and embodies the basic features of the static part of the ODMG standard [Cattell and Barry, 1997].

4.3.2.1 Formalization

An object-oriented schema is a ﬁnite set of class declarations, which impose con- straints on the instances of the classes that are used to model the application domain. A class declaration for a class C has the form

class C is-a C1, . . . , Ck type-is T,

where the is-a part, which is optional, speciﬁes inclusions between the sets of instances of the classes involved, while the type-is part speciﬁes through the type expression T the structure assigned to the objects that are instances of the class. We consider union, set, and record types, built according to the following syntax, where the letter A is used to denote attributes:

T −→C | union T1, . . . , Tk end | set-of T |

class Customer type-is

class Registration type-is

union BusinessCustomer, PrivateCustomer end

record

cust: Customer, regis: set-of record

class PrivateCustomer is-a Customer type-is

serv: Service loc: Location end end

record

SSN: String end

class Service type-is

record

code: Integer, suppliedBy: Department end

Fig. 4.10. Part of an object-oriented schema.

Figure 4.10 shows part of an object-oriented schema modeling the same reality as the Entity–Relationship schema of Figure 4.8. Notice that now registrations are represented as a class and grouped according to the customer, since all registrations related to one customer are collected in the set-valued attribute regis. The meaning of an object-oriented schema is given by specifying the character- istics of a database state for the schema. The deﬁnition of a database state makes use of the notions of object identiﬁer and value. Starting from a ﬁnite set OJ of ob- ject identiﬁers, the set of complex values over OJ is built inductively by grouping values into ﬁnite sets and records. A database state J for a schema is constituted by the set of object identiﬁers, a mapping πJ assigning to each class a subset of OJ , and a mapping ρJ assigning to each object in OJ a value over OJ . Notice that, although the set of values that can be constructed from a set OJ of object identiﬁers is inﬁnite, for a database state one only needs to consider the ﬁnite subset VJ of values assigned by ρJ to the elements of OJ , including the values that are not explicitly associated with object identiﬁers, but are used to form other values. The interpretation of type expressions in a database state J is deﬁned through an interpretation function ·J that assigns to each type expression T a set T J of values in VJ as follows: r if T is a class C, then T J = πJ (C); r if T is a union type union T1, . . . , Tk end, then T J = T J 1 ∪· · · ∪T J k ; r it T is a record type (resp. set type), then T J is the set of record values (resp. set values) compatible with the structure of T . For records we are using an open semantics, meaning that the records that are instances of a record type may have more components than those explicitly speciﬁed in the type [Abiteboul and Kanellakis, 1989].

A database state J for an object-oriented schema S is said to be legal (with respect to S) if for each declaration

class C is a C C type is T

in S, we have (1) CJ ⊆CJ i for each i ∈{1, . . . , n}, and (2) ρJ (CJ ) ⊆T J . There- fore, for a legal database state, the type expressions that are present in the schema determine the (ﬁnite) set of values that must be considered. The construction of such values is limited by the depth of type expressions.

4.3.2.2 Correspondence with Description Logics

When establishing a correspondence between an object-oriented model such as the one presented above, and Description Logics, one must take into account that the interpretation domain for a DL knowledge base consists of atomic objects, whereas each object of an object-oriented schema is assigned a possibly struc- tured value. Therefore one needs to explicitly represent in Description Logics the type structure of classes [Calvanese et al., 1994; 1999e; Artale et al., 1996a]. We describe now the translation proposed by Calvanese et al. [1994; 1999e], that over- comes this difﬁculty by introducing into the DL knowledge base concepts and roles with a speciﬁc meaning: the concepts AbstractClass, RecType, and SetType are used to denote instances of classes, record values, and set values, respectively. The associations between classes and types induced by the class declarations, as well as the basic characteristics of types, are modeled by means of speciﬁc roles: the functional role value models the association between classes and types, and the role member is used for specifying the type of the elements of a set. Moreover, the concepts representing types are assumed to be mutually disjoint, and disjoint from the concepts representing classes. These constraints are expressed by the following inclusion assertions, which are always part of the knowledge base that is obtained from an object-oriented schema:

AbstractClass ⊑ = 1 value RecType ⊑ ∀value.⊥ SetType ⊑ ∀value.⊥⊓¬RecType.

The translation from object-oriented schemas to Description Logic knowledge bases is deﬁned through a mapping , which maps each type expression to a concept expression as follows:

r Each class C is mapped to an atomic concept (C). r Each type expression union T1, . . . , Tk end is mapped to (T1) ⊔· · · ⊔(Tk). r Each type expression set-of T is mapped to SetType ⊓∀member.(T ). r Each attribute A is mapped to an atomic role (A), and each type expression record A1: T1, . . . , Ak: Tk end is mapped to

RecType ⊓∀(A1).(T1) ⊓= 1 (A1) ⊓· · · ⊓ ∀(A ) (T ) ⊓ 1 (A )

Customer ⊑ AbstractClass ⊓∀value.(BusinessCustomer ⊔PrivateCustomer) PrivateCustomer ⊑ AbstractClass ⊓Customer ⊓∀value.(RecType ⊓= 1 SSN ⊓∀SSN.String) Service ⊑ AbstractClass ⊓ ∀value.(RecType ⊓= 1 code ⊓∀code.Integer ⊓ = 1 suppliedBy ⊓∀suppliedBy.Department)

Customer ⊑ AbstractClass ⊓ ∀value.(RecType ⊓= 1 cust ⊓∀cust.Customer ⊓ = 1 regis ⊓∀regis.(SetType ⊓ ∀member.(RecType ⊓

serv ⊓∀serv.Service ⊓ loc loc.Location)))

Fig. 4.11. The speciﬁc part of the knowledge base corresponding to the object-oriented schema in Figure 4.10.

Then, the knowledge base (S) corresponding to an object-oriented schema S is obtained by taking for each class declaration

class C is-a C1, . . . , Cn type-is T

an inclusion assertion

(C) ⊑AbstractClass ⊓(C1) ⊓· · · ⊓(Cn) ⊓∀value.(T ).

We show in Figure 4.11 the knowledge base resulting from the translation of the fragment of object-oriented schema shown in Figure 4.10. Analogously to the ER model, it is sufﬁcient to use inclusion assertions instead of equivalence assertions to capture the semantics of object-oriented schemas. A trans- lation to an acyclic knowledge base is possible under the assumption that no class in the schema refers to itself, either directly in its type or indirectly via the class decla- rations12 [Artale et al., 1996a]. However, since this assumption represents a rather strong limitation in expressiveness, cycles are typically present in object-oriented schemas, and in this case the resulting DL knowledge base will contain cyclic asser- tions. No inverse roles are needed for the translation, since in object-oriented mod- els the inverse of an attribute is rarely considered. Furthermore, the use of number restrictions is limited to functionality, since all attributes are implicitly functional. To establish the correctness of the transformation, and thus ensure that the reasoning tasks on an object-oriented schema can be reduced to reasoning tasks on its translation into Description Logics, we would like to establish a one-to- one correspondence between database states legal for the schema and models of the knowledge base resulting from the translation. However, as for the ER model, the knowledge base may have models that do not correspond directly to legal database states. In this case, this is due to the fact that, while values have a treelike structure, the corresponding individuals in a model of the Description Logic knowledge base may be part of cyclic substructures. One way of ruling

12 Note that cyclic references cannot appear directly in a type, which is constructed inductively, but only through th l d l ti

out such cyclic substructures would be to adopt a speciﬁc constructor that allows one to impose well-foundedness [Calvanese et al., 1995], or even exploit general ﬁxed points on concepts [Schild, 1994; De Giacomo and Lenzerini, 1994a; 1997; Calvanese et al., 1999c]. However, it turns out that, in this case, it is not necessary to explicitly enforce such a condition. Indeed, due to the ﬁnite depth of nesting of types in a schema, it can be shown that each model of the translation of the schema can be unfolded into one that directly corresponds to a legal database state (more details are provided by Calvanese et al. [1999e]).

4.3.2.3 Applications of the correspondence

Similarly to the ER model, the existence of property-preserving transformations from object-oriented schemas into DL knowledge bases makes it possible to exploit the reasoning capabilities of a DL system for checking relevant schema properties, such as consistency and redundancy [Bergamaschi and Nebel, 1994; Artale et al., 1996a; Calvanese et al., 1998g]. Additionally, several extensions of the object- oriented formalism that are useful for the purpose of conceptual modeling can be considered:

r Not only IS-A, but also disjointness, and, more generally, Boolean combinations of classes can be used. r Class deﬁnitions can be used to specify not only necessary but also necessary and sufﬁcient properties for an object to be an instance of a class [Bergamaschi and Nebel, 1994]. r Cardinality constraints and not only implicit functionality can be imposed on attributes. Having attributes with multiple values could in some cases be a useful alternative to set-valued attributes. r By admitting also the use of inverse roles in the language, one gains the ability to impose constraints using a relation in both directions, as is customary in semantic data models. The increase in expressiveness that one obtains this way has indeed been recognized as extremely important by the database community [Albano et al., 1991], and has been included in the recent ODMG standard [Cattell and Barry, 1997].

The basic characteristics of object-oriented data models have also been included in the structural part of the Uniﬁed Modeling Language (UML) [Rumbaugh et al., 1998; Jacobson et al., 1998], which is becoming the standard language for the anal- ysis phase of software and information system development. Additionally, UML allows the deﬁnition of generic recursive data structures (both inductive and co- inductive) such as lists and trees, and their specialization to speciﬁc types. In order to capture also these aspects of UML in Description Logics and take them fully into account when reasoning over a schema, the Description Logic must provide the ability to represent and reason over data structures. In particular, to represent UML schemas it is necesary to resort to very expressive Description Logics including

number restrictions, inverse roles or n-ary relations, and ﬁxpoint constructs on con- cepts [Calvanese et al., 1999c]. Also in this case, the reasoning services provided by a DL system can be integrated into CASE tools and proﬁtably exploited to support the designer in the analysis phase [Franconi and Ng, 2000].

4.3.3 Semistructured data models and XML

In recent application areas such as data integration, access to data on the web, and digital libraries, the structure of the data is usually not rigid, as in conven- tional databases, and thus it is difﬁcult to describe it using traditional data models. Therefore, so called semistructured data models have been proposed, which are graph-based data models that provide ﬂexible structuring mechanisms, and thus al- low one to represent data that is neither raw nor strictly typed [Abiteboul et al., 2000; Abiteboul, 1997; Buneman et al., 1997; Mendelzon et al., 1997]. The Extensible Markup Language (XML) [Bray et al., 1998; Abiteboul et al., 2000], which has been introduced as a mechanism for representing structured documents on the Web, can in fact also be considered a model for semistructured data. Indeed, XML is by now much the most popular model for data on the Web, and there is a tremen- dous effort related to XML and the associated standards,13 both in the research community and in industry. Description Logics have traditionally been used to describe and organize data in a more ﬂexible way than is done in databases, basically using graph-like structures. Hence it seems natural to adopt Description Logics and the associated reasoning services for representing and reasoning on semistructured data and XML as well. In the following, we discuss the (rather few) proposals made in the literature. What these proposals have in common is the necessity to resort to ﬁxpoints, either by adopting ﬁxpoint semantics [Nebel, 1991; Baader, 1991], or by using reﬂexive– transitive closure or explicit ﬁxpoint constructs [De Giacomo and Lenzerini, 1997] (see also Chapter 5). For the recent extensive work on the use of Description Logics to provide a semantically richer representation of data on the Web we refer to Chapter 14.

4.3.3.1 Relationship between semistructured data and Description Logics

Michaeli et al. [1997] propose to extend a semistructured data model that is an abstraction of the OEM model [Abiteboul et al., 1997] with a layer of classes, representing objects with common properties. Class expressions correspond to DL concepts and the properties for the classes are speciﬁed by a set of classiﬁcation rules, which provide sufﬁcient conditions for class membership and are interpreted

13 h // 3 /

under a least ﬁxpoint semantics. By a reduction to reasoning in a Description Logic with ﬁxpoint operators [De Giacomo and Lenzerini, 1997; Calvanese et al., 1999c], it is shown that determining class satisﬁability and containment under a set of rules is ExpTime-decidable (and in fact ExpTime-complete). In the following, we discuss in more detail the use of Description Logics to represent and reason on semistructured data, on the example of one typical rep- resentative for semistructured data models. In semistructured data models, data is organized in the form of a graph, and information on both the values and the schema for the data is attached to the edges of the graph. In the formalism pro- posed by Buneman et al. [1997], the labels of edges in a schema are formulae of a complete ﬁrst order theory, and the conformance of a database to a schema is deﬁned in terms of a special relation, called simulation. The notion of simulation is less rigid than the usual notion of satisfaction, and suitably reﬂects the need for dealing with less strict data structures. In order to capture in Description Logics the notion of simulation, it is necessary on the one hand to express the local con- ditions that a node must satisfy, and on the other hand to deal with the fact that the simulation relation is the greatest relation satisfying the local conditions. Since semistructured data schemas may contain cycles, the local conditions may depend on each other in a cyclic way. Therefore, while the local conditions can be encoded by means of suitable inclusion assertions in ALU, the maximality condition on the simulation relation can only be captured correctly by resorting to a greatest ﬁx- point semantics [Calvanese et al., 1998c; 1998b]. Then, using a Description Logic with ﬁxpoint constructs, such as µALCQ [De Giacomo and Lenzerini, 1994b; 1997] (see also Chapter 5), a so-called characteristic concept for a semistruc- tured data schema can be constructed, which captures exactly the properties of the schema. Subsumption between two schemas, which is the task of deciding whether every semistructured database conforming to one schema also conforms to another schema [Buneman et al., 1997], can be decided by checking subsumption between the characteristic concepts of the schemas [Calvanese et al., 1998c]. The correspondence with Description Logics can again be exploited to enrich semistructured data models, without losing the ability to check schema subsump- tion. Indeed, the requirement already raised by Buneman et al. [1997], to extend semistructured data models with several types of constraints, has been addressed by Calvanese et al. [1998b], who propose several types of constraints, such as exis- tence and cardinality constraints, which are naturally derived from DL constructs. Reasoning in the presence of constraints is done by encoding also the constraints in the characteristic concept of a schema. Calvanese et al. deal also with the presence of incomplete information in the theory describing the properties of edge labels, by proposing the use of a theory expressed in µALCQ, instead of a complete ﬁrst order theory

<?xml version="1.0"?> <!DOCTYPE Services SYSTEM "services.dtd">

<?xml version="1.0"?> <!DOCTYPE Customers SYSTEM "services.dtd">

<Services> <Department name="standard-services"> <Service code="522"> <Name>call-back when busy</Name> <Cost>...</Cost> ... </Service> <Service code="214"> <Name>three-party call</Name> </Service> </Department>

<Customers> <Customer type="business"> <Name>FIAT</Name> <Field>manufacturing</Field> <Registered service="522"> <Location><City>Torino</City> <Address>...</Address> </Location> <Location>...</Location> </Registered> <Registered service="612"> <Location>...</Location> </Registered> </Customer>

<Department name="business-services"> <Service code="612"> <Name>conference call</Name> </Service> ... </Department> </Services>

<Customer type="private"> <Name>...</Name> <SSN>...</SSN> <Registered service="214"> <Location>...</Location> </Registered> </Customer> ... </Customers>

Fig. 4.12. Two XML documents specifying respectively customers and services.

4.3.3.2 Relationship between XML and Description Logics

XML [Bray et al., 1998] is a formalism for representing documents that are struc- tured by means of nested tags. Recently, XML has gained popularity also as a formalism for representing (semistructured) data and exchanging it over the Web. Figure 4.12 shows two example XML documents containing respectively data about customers and their registration to services provided by various departments (e.g., of a telephone company). A part of an XML document consisting of a start tag (e.g., <Customer>), the matching end tag (e.g., </Customer>), and everything in between is called an element. Elements can be arbitrarily nested, and can have associated attributes, speciﬁed by means of attribute–value pairs inside the start tag (e.g., type="business"). Intuitively, each XML document can be viewed as a ﬁnite ordered unranked tree,14 where each element represents a node, and the children of an element are those elements directly contained in it. How XML documents are viewed as trees is deﬁned, together with an API for accessing and manipulating such trees/XML-documents, by the Document Object Model,15

which deﬁnes, besides element nodes, other types of nodes, such as attributes, comments, etc.

14 In an unranked tree each node can have an arbitrary ﬁnite number of child nodes. The tree is ordered since the

<!-- File: services.dtd -->

<!ELEMENT Customers (Customer)+ > <!ELEMENT Customer (Name, (Field|SSN), Registered+) > <!ELEMENT Registered (Location)+ > ... <!ELEMENT Services (Department)+ > <!ELEMENT Department (Service)* > <!ELEMENT Service (Name, Cost?, ...) > <!ELEMENT Name #PCDATA > ...

<!ATTLIST Customer type (business|private) "private"> <!ATTLIST Registered service IDREF #REQUIRED> <!ATTLIST Department name CDATA #REQUIRED> <!ATTLIST Service code ID #REQUIRED> ...

Fig. 4.13. Part of the Document Type Declaration S for the XML documents in Figure 4.12.

In XML, it is possible to impose a structure on documents by means of a Doc- ument Type Declaration (DTD) [Bray et al., 1998]. A DTD consists of a set of declarations: For each element type used in the XML document, the DTD must contain a declaration that speciﬁes, by means of a regular expression, how ele- ments can be nested within elements of that type. The keyword #PCDATA is used to specify that the element content (i.e., the part enclosed by the tags) is free text without nested elements. For each attribute appearing in the XML document, the DTD must contain a declaration specifying the name of the attribute, the type of the elements it is associated to, and additional properties (e.g., the type and whether the attribute is optional or mandatory). Figure 4.13 shows part of the DTD for the XML documents in Figure 4.12. We refer to [Bray et al., 1998] for a precise deﬁ- nition of the syntax and semantics of XML DTDs. We illustrate the method for encoding XML DTDs into DL knowledge bases proposed in [Calvanese et al., 1999d]. For simplicity, we do not consider XML attributes, although they can easily be dealt with by introducing suitable roles. Due to the presence of regular expressions, to encode DTDs into Description Logics, it is necessary to resort to a Description Logic equipped with constructs for building regular expressions over roles (see Chapter 5). Notice that the encoding of DTDs into DL knowledge bases must allow for representing unranked trees and at the same time for preserving the order of the children of a node. For example, the DTD in Figure 4.13 enforces that the content of a Customer element consists of a Name element, followed by (in DTDs, concatenation is denoted by “,”) either a Field or an SSN element (alternative is denoted by “|”), followed by an arbitrary number (but at least one) of Registered elements (transitive closure is denoted by “+”). To overcome these difﬁculties Calvanese et al [1999d] propose to represent XML

f r

<Customers>

f

f

r

f r

f

r

<Customer> f

r

r <Customer>

f

f

r

r

r

</Customer> f

r <Name>

f

r

</Name> FIAT f

</Customers>

r

f r

f

r

r <Field>

f

r

</Field> manufacturing

</Customer>

Fig. 4.14. The binary tree corresponding to the XML document on the left-hand side of Figure 4.12.

an encoding of DTDs in Description Logics that exploits such a representation. Figure 4.14 shows the binary tree corresponding to one of the XML documents in Figure 4.12. Figure 4.15 shows part of the axioms encoding the DTD in Figure 4.13. The two roles f and r are used to encode binary trees, and such roles are globally functional (axiom (4.1)). Moreover, the well-founded construct (see Chapter 5) wf(f ⊔r) is used to express that there can be no inﬁnite chain of objects, each one connected to the next by means of f ⊔r. Such a condition turns out to be necessary to correctly capture the fact that XML documents correspond to trees that are ﬁnite. For each element type E, the atomic concepts StartE and EndE represent respectively the start tags (4.2) and end tags (4.3) for E, and such tags are leaves of the tree (4.4). The remaining leaves of the tree are free text, represented by the atomic concept PCDATA (4.5). Using such concepts and roles, one can introduce for each element type E appearing in a DTD D an atomic concept ED, and encode the regular expression specifying the structure of elements of type E in a suitable complex role, exploiting constructs for regular expressions over roles (including the id(·) construct). This is illustrated in Figure 4.15 for part of the element types of the DTD in Figure 4.13. We refer to [Calvanese et al., 1999d] for the precise deﬁnition of the encoding

⊤ ≡ ⩽1 f ⊓⩽1 r ⊓wf (f ⊔r) StartE ⊑ Tag for each element type E (4.2 (4.1) ) EndE ⊑ Tag for each element type E (4.3) Tag ⊑ ∀(f ⊔r).⊥ (4.4) PCDATA ⊑ ∀(f ⊔r).⊥⊓¬Tag (4.5) CustomersS ≡ ∃f.StartCustomers ⊓∃(r ◦(id(∃f.CustomerS) ◦r)+).EndCustomers CustomerS ≡ ∃f.StartCustomers ⊓∃(r ◦id(∃f.NameS) ◦r ◦(id(∃f.FieldS) ⊔id(∃f.SSNS)) ◦r ◦(id(∃f.RegisteredS) ◦r)+).EndCustomer NameS ≡ ∃f.StartName ⊓∃(r ◦id(∃f.PCDATA) ◦r).EndName ...

Fig. 4.15. Part of the encoding of the DTD S in Figure 4.13 into a DL knowledge base.

TheencodingofDTDsintoDescriptionLogicscanbeexploitedtoverifydifferent kinds of properties on DTDs, namely inclusion, equivalence, and disjointness be- tween the sets of documents conforming respectively to two DTDs. Such reasoning tasks come in different forms. For strong inclusion (resp. equivalence, disjointness) both the document structure and the actual tag names are of importance when com- paring documents, while for structural inclusion (resp. equivalence, disjointness) one abstracts away from the actual tag names, and considers only the document structure [Wood, 1995]. Parametric inclusion (resp. equivalence, disjointness) gen- eralizes both notions, by considering an equivalence relation between tag names, and comparing documents modulo such an equivalence relation. By exploiting the encoding of DTDs into Description Logics presented above, all forms of inference on DTDs can be carried out in deterministic exponential time [Calvanese et al., 1999d].

5

Expressive Description Logics

DIEGO CALVANESE GIUSEPPE DE GIACOMO

Abstract

This chapter covers extensions of the basic Description Logics introduced in Chapter 2 by very expressive constructs that require advanced reasoning tech- niques. In particular, we study reasoning in Description Logics that include general inclusion axioms, inverse roles, number restrictions, reﬂexive–transitive closure of roles, ﬁxpoint constructs for recursive deﬁnitions, and relations of arbitrary arity. The chapter will also address reasoning w.r.t. knowledge bases including both a TBox and an ABox, and discuss more general ways to treat objects. Since the log- ics considered in the chapter lack the ﬁnite model property, ﬁnite model reasoning is of interest and will also be discussed. Finally, we mention several extensions to Description Logics that lead to undecidability, conﬁrming that the expressive Description Logics considered in this chapter are close to the boundary between decidability and undecidability.

5.1 Introduction

Description Logics have been introduced with the goal of providing a formal reconstruction of frame systems and semantic networks. Initially, the research has concentrated on subsumption of concept expressions. However, for certain applica- tions, it turns out that it is necessary to represent knowledge by means of inclusion axioms without limitation on cycles in the TBox. Therefore, recently there has been a strong interest in the problem of reasoning over knowledge bases of a general form. See Chapters 2, 3, and 4 for more details. When reasoning over general knowledge bases, it is not possible to gain tractabil- ity by limiting the expressive power of the Description Logic, because the power of arbitrary inclusion axioms in the TBox alone leads to high complexity in the inference mechanisms Indeed logical implication is ExpTime hard even for the

very simple language AL (see Chapter 3). This has led to the investigation of very powerful languages for expressing concepts and roles, for which the property of interest is no longer tractability of reasoning, but rather decidability. Such logics, called here expressive Description Logics, have the following characteristics:

(i) The language used for building concepts and roles comprises all classical concept- forming constructs, plus several role-forming constructs such as inverse roles and reﬂexive–transitive closure. (ii) No restriction is posed on the axioms in the TBox.

The goal of this chapter is to provide an overview of the results and techniques for reasoning in expressive Description Logics. The chapter is organized as follows. In Section 5.2, we outline the correspondence between expressive Description Logics and Propositional Dynamic Logics, which has given the basic tools to study reason- ing in expressive Description Logics. In Section 5.3, we exploit automata-theoretic techniques developed for variants of Propositional Dynamic Logics to address rea- soning in expressive Description Logics with functionality restrictions on roles. In Section 5.4 we illustrate the basic technique of reiﬁcation for reasoning with expressive variants of number restrictions. In Section 5.5, we show how to reason with knowledge bases composed of a TBox and an ABox, and discuss extensions to deal with names (one-of construct). In Section 5.6, we introduce Description Logics with explicit ﬁxpoint constructs, which are used to express in a natural way inductively and coinductively deﬁned concepts. In Section 5.7, we study Descrip- tion Logics that include relations of arbitrary arity, which overcome the limitations of traditional Description Logics of modeling only binary links between objects. This extension is particularly relevant for the application of Description Logics to databases. In Section 5.8, the problem of ﬁnite model reasoning in Description Logics is addressed. Indeed, for expressive Description Logics, reasoning w.r.t. ﬁnite models differs from reasoning w.r.t. unrestricted models, and requires spe- ciﬁc methods. Finally, in Section 5.9, we discuss several extensions to Description Logics that lead in general to undecidability of the basic reasoning tasks. This shows that the expressive Description Logics considered in this chapter are close to the limit of undecidability, and are carefully designed in order to retain decidability.

5.2 Correspondence between Description Logics and Propositional Dynamic Logics

In this section, we focus on expressive Description Logics that, besides the standard ALC constructs, include regular expression over roles and possibly inverse roles [Baader, 1991; Schild, 1991]. It turns out that such Description Logics correspond directly to Propositional Dynamic Logics which are modal logics used to express

properties of programs. We ﬁrst introduce the syntax and semantics of the Descrip- tion Logics we consider, then introduce Propositional Dynamic Logics, and ﬁnally discuss the correspondence between the two formalisms.

5.2.1 Description Logics

We consider the Description Logic ALCIreg, in which concepts and roles are formed according to the following syntax:

C, C′ −→A | ¬C | C ⊓C′ | C ⊔C′ | ∀R.C | ∃R.C R, R′ −→P | R ⊔R′ | R ◦R′ | R∗| id(C) | R−

where A and P denote respectively atomic concepts and atomic roles, and C and R denote respectively arbitrary concepts and roles. In addition to the usual concept-forming constructs, ALCIreg provides constructs to form regular expressions over roles. Such constructs include role union, role com- position, reﬂexive-transitive closure, and role identity. Their meaning is straight- forward, except for role identity id(C) which, given a concept C, allows one to build a role which connects each instance of C to itself. As we shall see in the next section, there is a tight correspondence between these constructs and the opera- tors on programs in Propositional Dynamic Logics. The presence in the language of the constructs for regular expressions is speciﬁed by the subscript “reg” in the name. ALCIreg also includes the inverse role construct, which allows one to denote the inverse of a given relation. One can, for example, state with ∃child−.Doctor that someone has a parent who is a doctor, by making use of the inverse of the role child. It is worth noticing that, in a language without inverse of roles, in order to express such a constraint one must use two distinct roles (e.g., child and parent) that cannot be put in the proper relation to each other. We use the letter I in the name to specify the presence of inverse roles in a Description Logic; by dropping inverse roles from ALCIreg, we obtain the Description Logic ALCreg. From the semantic point of view, given an interpretation I, concepts are in- terpreted as subsets of the domain I, and roles as binary relations over I, as follows:1

AI ⊆ I

(¬C)I = I \ CI

(C ⊓C′)I = CI ∩C′I

1 We use R∗to denote the reﬂexive–transitive closure of the binary relation R, and R1 ◦R2 to denote the h i i f th bi l ti R d R

(C ⊔C′)I = CI ∪C′I

(∀R.C)I = {o ∈I | ∀o′. (o, o′) ∈RI ⊃o′ ∈CI} (∃R.C)I = {o ∈I | ∃o′. (o, o′) ∈RI ∧o′ ∈CI}

PI ⊆ I × I

(R ⊔R′)I = RI ∪R′I

(R ◦R′)I = RI ◦R′I

(R∗)I = (RI)∗

id(C)I = {(o, o) ∈I × I | o ∈CI} (R−)I = {(o, o′) ∈I × I | (o′, o) ∈RI}.

We consider the most general form of TBoxes constituted by general inclusion axioms of the form C ⊑C′, without any restriction on cycles. We use C ≡C′ as an abbreviation for the pair of axioms C ⊑C′ and C′ ⊑C. We adopt the usual descriptive semantics for TBoxes (see Chapter 2).

Example 5.1 The following ALCIreg TBox Tﬁle models a ﬁle system constituted by ﬁle-system elements (FSelem), each of which is either a Directory or a File. Each FSelem has a name, a Directory may have children while a File may not, and Root is a special directory which has no parent. The parent relationship is modeled through the inverse of the role child.

FSelem ⊑ ∃name.String FSelem ≡ Directory ⊔File Directory ⊑ ¬File Directory ⊑ ∀child.FSelem File ⊑ ∀child.⊥ Root ⊑ Directory Root ⊑ ∀child−.⊥.

The axioms in Tﬁle imply that in a model every object connected by a chain of role child to an instance of Root is an instance of FSelem. Formally, Tﬁle |= ∃(child−)∗.Root ⊑FSelem. To verify that the implication holds, suppose that there exists a model in which an instance o of ∃(child−)∗.Root is not an instance of FSelem. Then, reasoning by induction on the length of the chain from the instance of Root to o, one can derive a contradiction. Observe that induction is required, and hence such reasoning is not ﬁrst-order.

In the following, when convenient, we assume, without loss of generality, that ⊔and ∀R C are expressed by means of ⊓and ∃R C We also assume that the

inverse operator is applied to atomic roles only. This can again be done without loss of generality, since the following equivalences hold: (R1 ◦R2)−= R− 1 ◦R− 2 , (R1 ⊔R2)−= R− 1 ⊔R− 2 , (R∗)−= (R−)∗, and (id(C))−= id(C).

5.2.2 Propositional Dynamic Logics

Propositional Dynamic Logics (PDLs) are modal logics speciﬁcally developed for reasoning about computer programs [Fischer and Ladner, 1979; Kozen and Tiuryn, 1990; Harel et al., 2000]. In this subsection, we provide a brief overview of PDLs, and illustrate the correspondence between Description Logics and PDLs. Syntactically, a PDL is constituted by expressions of two sorts: programs and formulae. Programs and formulae are built by starting from atomic programs and propositional letters, and applying suitable operators. We denote propositional let- ters by A, arbitrary formulae by φ, atomic programs by P, and arbitrary pro- grams by r, all possibly with subscripts. We focus on converse-pdl [Fischer and Ladner, 1979] which, as it turns out, corresponds to ALCIreg. The abstract syntax of converse-pdl is as follows:

φ, φ′ −→⊤| ⊥| A | φ ∧φ′ | φ ∨φ′ | ¬φ | ⟨r⟩φ | [r]φ r,r′ −→P | r ∪r′ | r;r′ | r∗| φ? | r−.

The basic Propositional Dynamic Logic pdl [Fischer and Ladner, 1979] is obtained from converse-pdl by dropping converse programs r−. The semantics of PDLs is based on the notion of (Kripke) structure, deﬁned as a triple M = (S, {RP}, ), where S denotes a non-empty set of states, {RP} is a family of binary relations over S, each of which denotes the state transitions caused by an atomic program P, and  is a mapping from S to propositional letters such that (s) determines the letters that are true in state s. The basic semantical relation is “a formula φ holds at a state s of a structure M”, written M, s |= φ, and is deﬁned by induction on the formation of φ:

M, s |= A iff A ∈(s) M, s |= ⊤ always M, s |= ⊥ never M, s |= φ ∧φ′ iff M, s |= φ and M, s |= φ′

M, s |= φ ∨φ′ iff M, s |= φ or M, s |= φ′

M, s |= ¬φ iff M, s ̸|= φ M, s |= ⟨r⟩φ iff there is s′ such that (s, s′) ∈Rr and M, s′ |= φ M, s |= [r]φ iff for all s′, (s, s′) ∈Rr implies M, s′ |= φ

wherethefamily{R }issystematicallyextendedsoastoinclude foreveryprogram

r, the corresponding relation Rr deﬁned by induction on the formation of r:

RP ⊆ S × S Rr∪r′ = Rr ∪Rr′ Rr;r′ = Rr ◦Rr′ Rr∗ = (Rr)∗

Rφ? = {(s, s) ∈S × S | M, s |= φ} Rr− = {(s1, s2) ∈S × S | (s2, s1) ∈Rr}.

If, for each atomic program P, the transition relation RP is required to be a function that assigns to each state a unique successor state, then we are dealing with the deterministic variants of PDLs, namely dpdl and converse-dpdl [Ben-Ari et al., 1982; Vardi and Wolper, 1986]. It is important to understand, given a formula φ, which are the formulae that play some role in establishing the truth-value of φ. In simpler modal logics, these formulae are simply all the subformulae of φ, but due to the presence of reﬂexive– transitive closure this is not the case for PDLs. Such a set of formulae is given by the Fischer–Ladner closure of φ [Fischer and Ladner, 1979]. To be concrete we now illustrate the Fischer–Ladner closure for converse-pdl. However, the notion of Fischer–Ladner closure can be easily extended to other PDLs. Let us assume, without loss of generality, that ∨and [·] are expressed by means of ¬, ∧, and ⟨·⟩. We also assume that the converse operator is applied to atomic programs only. This can again be done without loss of generality, since the following equivalences hold: (r ∪r′)−= r−∪r′−, (r;r′)−= r′−;r−, (r∗)−= (r−)∗, and (φ?)−= φ?. The Fischer–Ladner closure of a converse-pdl formula ψ, denoted CL(ψ), is the least set F such that ψ ∈F and such that:

if φ ∈F then ¬φ ∈F (if φ is not of the form ¬φ′) if ¬φ ∈F then φ ∈F if φ ∧φ′ ∈F then φ, φ′ ∈F if ⟨r⟩φ ∈F then φ ∈F if ⟨r ∪r′⟩φ ∈F then ⟨r⟩φ, ⟨r′⟩φ ∈F if ⟨r;r′⟩φ ∈F then ⟨r⟩⟨r′⟩φ ∈F if ⟨r∗⟩φ ∈F then ⟨r⟩⟨r∗⟩φ ∈F if ⟨φ′?⟩φ ∈F then φ′ ∈F.

Note that CL(ψ) includes all the subformulae of ψ, but also formulae of the form ⟨r⟩⟨r∗⟩φ derived from ⟨r∗⟩φ, which are in fact bigger than the formula they derive from. On the other hand, both the number and the size of the for- mulae in CL(ψ) are linearly bounded by the size of ψ [Fischer and Ladner 1979]

exactly like the set of subformulae. Note also that, by deﬁnition, if φ ∈CL(ψ), then CL(φ) ⊆CL(ψ). A structure M = (S, {RP}, ) is called a model of a formula φ if there exists a state s ∈S such that M, s |= φ. A formula φ is satisﬁable if there exists a model of φ, otherwise the formula is unsatisﬁable. A formula φ is valid in a structure M if for all s ∈S, M, s |= φ. Formulae that are used to select the interpretations of interest are called axioms. Formally, a structure M is a model of an axiom φ, if φ is valid in M. A structure M is a model of a ﬁnite set of axioms  if M is a model of all axioms in . An axiom is satisﬁable if it has a model, and a ﬁnite set of axioms is satisﬁable if it has a model. We say that a ﬁnite set  of axioms logically implies a formula φ, written  |= φ, if φ is valid in every model of . It is easy to see that satisﬁability of a formula φ as well as satisﬁability of a ﬁnite set of axioms  can be reformulated by means of logical implication, as ∅̸|= ¬φ and  ̸|= ⊥respectively. Interestingly, logical implication can, in turn, be reformulated in terms of satis- ﬁability, by making use of the following theorem (see [Kozen and Tiuryn, 1990]).

Theorem 5.2 (Internalization of axioms) Let  be a ﬁnite set of converse-pdl axioms, and φ a converse-pdl formula. Then  |= φ if and only if the formula

¬φ ∧[(P1 ∪· · · ∪Pm ∪P− 1 ∪· · · ∪P− m )∗]′

is unsatisﬁable, where P1, . . . , Pm are all atomic programs occurring in  ∪{φ} and ′ is the conjunction of all axioms in .

Such a result exploits the power of program constructs (union, reﬂexive–transitive closure) and the connected model property (i.e., if a formula has a model, it has a model which is connected) of PDLs in order to represent axioms. The con- nected model property is typical of modal logics and it is enjoyed by all PDLs. As a consequence, a result analogous to Theorem 5.2 holds for virtually all PDLs. Reasoning in PDLs has been thoroughly studied from the computational point of view, and the results for the PDLs considered here are summarized in the following theorem [Fischer and Ladner, 1979; Pratt, 1979; Ben-Ari et al., 1982; Vardi and Wolper, 1986]:

Theorem 5.3 Satisﬁability in pdl is ExpTime-hard. Satisﬁability in pdl, in converse-pdl, and in converse-dpdl can be decided in deterministic exponential time

5.2.3 The correspondence

The correspondence between Description Logics and PDLs was ﬁrst published by Schild [1991].2 In the work by Schild, it was shown that ALCIreg can be considered a notational variant of converse-pdl. This observation allowed the results on converse-pdl to be exploited for instantly closing long-standing issues regarding the decidability and complexity of both satisﬁability and logical implication in ALCreg and ALCIreg.3 The paper was very inﬂuential for the research in expressive Description Logics in the following decade, since thanks to the correspondence between PDLs and Description Logics, ﬁrst results but especially formal techniques and insights could be shared by the two communities. The correspondence between PDLs and Description Logics has been extensively used to study reasoning methods for expressive Description Logics. It has also led to a number of interesting exten- sions of PDLs in terms of those constructs that are typical of Description Logics and have never been considered in PDLs. In particular, there is a tight relation between qualiﬁed number restrictions and graded modalities in modal logics [Van der Hoek, 1992; Van der Hoek and de Rijke, 1995; Fattorosi-Barnaba and De Caro, 1985; Fine, 1972]. The correspondence is based on the similarity between the interpretation struc- tures of the two logics: at the extensional level, individuals (members of I) in Description Logics correspond to states in PDLs, and links between two individ- uals correspond to state transitions. At the intensional level, concepts correspond to propositions, and roles correspond to programs. Formally, the correspondence is realized through a one-to-one and onto mapping τ from ALCIreg concepts to converse-pdl formulae, and from ALCIreg roles to converse-pdl programs. The mapping τ is deﬁned inductively as follows:

τ(A) = A τ(P) = P τ(¬C) = ¬τ(C) τ(R−) = τ(R)−

τ(C ⊓C′) = τ(C) ∧τ(C′) τ(R ⊔R′) = τ(R) ∪τ(R′) τ(C ⊔C′) = τ(C) ∨τ(C′) τ(R ◦R′) = τ(R); τ(R′) τ(∀R.C) = [τ(R)]τ(C) τ(R∗) = τ(R)∗

τ(∃R.C) = ⟨τ(R)⟩τ(C) τ(id(C)) = τ(C)?

Axioms in TBoxes of Description Logics correspond in the obvious way to axioms in PDLs. Moreover all forms of reasoning (satisﬁability, logical implication, etc.) have their natural counterpart.

2 In fact, the correspondence was ﬁrst noticed by Levesque and Rosenschein at the beginning of the 1980s, but never published. In those days Levesque just used it in seminars to show the intractability of certain Description Logics. 3 I f t th d id bilit f ALC ith t th id(C) t t i d d tl t bli h d b B d [1991]

One of the most important contributions of the correspondence is obtained by rephrasing Theorem 5.2 in terms of Description Logics. It says that every TBox can be “internalized” into a single concept, i.e., it is possible to build a concept that expresses all the axioms of the TBox. In doing so we rely on the ability to build a “universal” role, i.e., a role linking all individuals in a (connected) model. Indeed, a universal role can be expressed by using regular expressions over roles, and in particular the union of roles and the reﬂexive–transitive closure. The possibility of internalizing the TBox when dealing with expressive Description Logics tells us that for such Description Logics reasoning with TBoxes, i.e., logical implication, is no harder than reasoning with a single concept.

Theorem 5.4 Concept satisﬁability and logical implication in ALCreg are ExpTime-hard. Concept satisﬁability and logical implication in ALCreg and ALCIreg can be decided in deterministic exponential time.

Observe that for Description Logics that do not allow the expression of a uni- versal role, there is a sharp difference between reasoning techniques used in the presence of TBoxes, and techniques used to reason on concept expressions. The profound difference is reﬂected by the computational properties of the associated decision problems. For example, the logic AL admits simple structural algorithms for deciding reasoning tasks not involving axioms, and these algorithms are sound and complete and work in polynomial time. However, if general inclusion axioms are considered, then reasoning becomes ExpTime-complete (see Chapter 3), and the decisionproceduresthathavebeendevelopedincludesuitableterminationstrategies [Buchheit et al., 1993a]. Similarly, for the more expressive logic ALC, reasoning tasks not involving a TBox are PSpace-complete [Schmidt-Schauß and Smolka, 1991], while those that do involve one are ExpTime-complete.

5.3 Functional restrictions

We have seen that the logics ALCreg and ALCIreg correspond to standard pdl and converse-pdl respectively, which are both well-studied. In this section we show how the correspondence can also be used to deal with constructs that are typical of Description Logics, namely functional restrictions, by exploiting techniques devel- oped for reasoning in PDLs. In particular, we will adopt automata-based techniques, which have been very successful in studying reasoning for expressive variants of PDL and characterizing their complexity. Functional restrictions are the simplest form of number restrictions considered in Description Logics, and allow one to specify local functionality of roles, i.e., that instances of certain concepts have unique role ﬁllers for a given role By adding

functional restrictions on atomic roles and their inverse to ALCIreg, we obtain the Description Logic ALCFIreg. The PDL corresponding to ALCFIreg is a PDL that extends converse-dpdl [Vardi and Wolper, 1986] with determinism of both atomic programs and their inverse, and such that determinism is no longer a global property, but one that can be imposed locally. Formally, ALCFIreg is obtained from ALCIreg by adding functional restrictions of the form ⩽1 Q, where Q is a basic role, i.e., either an atomic role or the inverse of an atomic role. Such a functional restriction is interpreted as follows:

(⩽1 Q)I = {o ∈I | |{o′ ∈I | (o, o′) ∈QI}| ≤1}.

We show that reasoning in ALCFIreg is in ExpTime, and, since reasoning in ALCreg is already ExpTime-hard, is in fact ExpTime-complete. Without loss of gen- erality we concentrate on concept satisﬁability. We exploit the fact that ALCFIreg hasthetreemodelproperty,whichstatesthatifanALCFIreg conceptC issatisﬁable then it is satisﬁed in an interpretation which has the structure of a (possibly inﬁnite) tree with bounded branching degree (see later). This allows us to make use of tech- niques based on automata on inﬁnite trees. In particular, we make use of two-way alternating automata on inﬁnite trees (2ATAs) introduced by Vardi [1998]. 2ATAs were used by Vardi [1998] to derive a decision procedure for modal µ-calculus with backward modalities. We ﬁrst introduce 2ATAs and then show how they can be used to reason in ALCFIreg.

5.3.1 Automata on inﬁnite trees

Inﬁnite trees are represented as preﬁx-closed (inﬁnite) sets of words over N (the set of positive natural numbers). Formally, an inﬁnite tree is a set of words T ⊆N∗, such that if x·c ∈T , where x ∈N∗and c ∈N, then also x ∈T . The elements of T are called nodes, the empty word ε is the root of T , and for every x ∈T , the nodes x·c, with c ∈N, are the successors of x. By convention we take x·0 = x, and x·i·−1 = x. The branching degree d(x) of a node x denotes the number of successors of x. If the branching degree of all nodes of a tree is bounded by k, we say that the tree has branching degree k. An inﬁnite path P of T is a preﬁx-closed set P ⊆T such that for every i ≥0 there exists a unique node x ∈P with |x| = i. A labeled tree over an alphabet is a pair (T, V ), where T is a tree and V : T → maps each node of T to an element of . Alternating automata on inﬁnite trees are a generalization of nondeterministic automata on inﬁnite trees, introduced by Muller and Schupp [1987]. They allow an elegant reduction of decision problems for temporal and program logics [Emerson and Jutla, 1991; Bernholtz et al., 1994]. Let B(I) be the set of positive Boolean formulae over I built inductively by applying ∧and ∨starting from true false

and elements of I. For a set J ⊆I and a formula ϕ ∈B(I), we say that J satisﬁes ϕ if and only if assigning true to the elements in J and false to those in I \J makes ϕ true. For a positive integer k, let [k] = {−1, 0, 1, . . . , k}. A two-way alter- nating automaton over inﬁnite trees with branching degree k is a tuple A = ⟨ , Q, δ, q0, F⟩, where is the input alphabet, Q is a ﬁnite set of states, δ : Q × →B([k] × Q) is the transition function, q0 ∈Q is the initial state, and F spec- iﬁes the acceptance condition. The transition function maps a state q ∈Q and an input letter σ ∈ to a positive Boolean formula over [k] × Q. Intuitively, if δ(q, σ) = ϕ, then each pair (c, q′) ap- pearing in ϕ corresponds to a new copy of the automaton going to the direction suggested by c and starting in state q′. For example, if k = 2 and δ(q1, σ) = ((1, q2) ∧(1, q3)) ∨((−1, q1) ∧(0, q3)), when the automaton is in the state q1 and is reading the node x labeled by the letter σ, it proceeds either by sending off two copies, in the states q2 and q3 respectively, to the ﬁrst successor of x (i.e., x·1), or by sending off one copy in the state q1 to the predecessor of x (i.e., x·−1) and one copy in the state q3 to x itself (i.e., x·0). A run of a 2ATA A over a labeled tree (T, V ) is a labeled tree (Tr,r) in which every node is labeled by an element of T × Q. A node in Tr labeled by (x, q) describes a copy of A that is in the state q and reads the node x of T . The labels of adjacent nodes have to satisfy the transition function of A. Formally, a run (Tr,r) is a T × Q-labeled tree satisfying:

(i) ε ∈Tr and r(ε) = (ε, q0). (ii) Let y ∈Tr, with r(y) = (x, q) and δ(q, V (x)) = ϕ. Then there is a (possibly empty) set S = {(c1, q1), . . . , (cn, qn)} ⊆[k] × Q such that: • S satisﬁes ϕ and • for all 1 ≤i ≤n, we have that y·i ∈Tr, x·ci is deﬁned, and r(y·i) = (x·ci, qi).

A run (Tr,r) is accepting if all its inﬁnite paths satisfy the acceptance condition.4

Given an inﬁnite path P ⊆Tr, let inf (P) ⊆Q be the set of states that appear inﬁnitely often in P (as second components of node labels). We consider here B¨uchi acceptance conditions. A B¨uchi condition over a state set Q is a subset F of Q, and an inﬁnite path P satisﬁes F if inf (P) ∩F ̸= ∅. The non-emptiness problem for 2ATAs consists in determining, whether a given 2ATA accepts a nonempty set of trees. The results by Vardi [1998] provide the following complexity characterization of non-emptiness of 2ATAs.

Theorem 5.5 ([Vardi, 1998]) Given a 2ATA A with n states and an input alphabet with m elements, deciding non-emptiness of A can be done in time exponential in n and polynomial in m.

4 N diti i i d th ﬁit th f th

5.3.2 Reasoning in ALCFIreg

The (Fischer–Ladner) closure for ALCFIreg extends immediately the analogous notion for converse-pdl (see Subsection 5.2.2), treating functional restrictions as atomic concepts. In particular, the closure CL(C0) of an ALCFIreg concept C0 is deﬁned as the smallest set of concepts such that C0 ∈CL(C0) and such that (assuming ⊔and ∀to be expressed by means of ⊓and ∃, and the inverse operator applied only to atomic roles):5

if C ∈CL(C0) then ¬C ∈CL(C0) (if C is not of the form ¬C′) if ¬C ∈CL(C0) then C ∈CL(C0) if C ⊓C′ ∈CL(C0) then C, C′ ∈CL(C0) if ∃R.C ∈CL(C0) then C ∈CL(C0) if ∃(R ⊔R′).C ∈CL(C0) then ∃R.C, ∃R′.C ∈CL(C0) if ∃(R ◦R′).C ∈CL(C0) then ∃R.∃R′.C ∈CL(C0) if ∃R∗.C ∈CL(C0) then ∃R.∃R∗.C ∈CL(C0) if ∃id(C).C′ ∈CL(C0) then C ∈CL(C0).

The cardinality of CL(C0) is linear in the length of C0. It can be shown, following the lines of the proof in [Vardi and Wolper, 1986] for converse-dpdl, that ALCFIreg enjoys the tree model property, i.e., every satisﬁable concept has a model that has the structure of a (possibly inﬁnite) tree with branching degree linearly bounded by the size of the concept. More precisely, we have the following result.

Theorem 5.6 Every satisﬁable ALCFIreg concept C0 has a tree model with branching degree kC0 equal to twice the number of elements of CL(C0).

This property allows us to check satisﬁability of an ALCFIreg concept C0 by building a 2ATA that accepts the (labeled) trees that correspond to tree models of C0. Let A be the set of atomic concepts appearing in C0, and B = {Q1, . . . , Qn} the set of atomic roles appearing in C0 and their inverses. We construct from C0 a 2ATA AC0 that checks that C0 is satisﬁed at the root of the input tree. We represent in each node of the tree the information about which atomic concepts are true in the node, and about the basic role that connects the predecessor of the node to the node itself (except for the root). More precisely, we label each node with a pair σ = (α, q), where α is the set of atomic concepts that are true in the node, and q = Q if the node is reached from its predecessor through the basic role Q. That is, if Q stands for an atomic role P, then the node is reached from its predecessor through P, and if Q stands for P−, then the predecessor is reached from the node through P. In the root, q = Pdum, where Pdum is a new symbol representing a dummy role.

5 W ll th t C d C′ t d f bit t d R d R′ t d f bit l

Given an ALCFIreg concept C0, we construct an automaton AC0 that accepts trees that correspond to tree models of C0. For technical reasons, it is convenient to consider concepts in negation normal form (i.e., negations are pushed inside as much as possible). It is easy to check that the transformation of a concept into negation normal form can be performed in linear time in the size of the concept. Below, we denote by nnf(C) the negation normal form of C, and by CLnnf(C0) the set {nnf(C) | C ∈CL(C0)}. The automaton AC0 = ( , S, δ, sini, F) is deﬁned as follows.

r The alphabet is = 2A × (B ∪{Pdum}), i.e., the set of pairs whose ﬁrst component is a set of atomic concepts, and whose second component is a basic role or the dummy role Pdum. This corresponds to labeling each node of the tree with a truth assignment to the atomic concepts, and with the role used to reach the node from its predecessor. r The set of states is S = {sini} ∪CLnnf(C0) ∪{Q, ¬Q | Q ∈B}, where sini is the initial state, CLnnf(C0) is the set of concepts (in negation normal form) in the closure of C0, and {Q, ¬Q | Q ∈B} are states used to check whether a basic role labels a node. Intuitively, when the automaton in a state C ∈CLnnf(C0) visits a node x of the tree, this means that the automaton has to check that C holds in x. r The transition function δ is deﬁned as follows. 1. For each α ∈2A, there is a transition from the initial state

δ(sini, (α, Pdum)) = (0, nnf(C0)).

Such a transition checks that the root of the tree is labeled with the dummy role Pdum, and moves to the state that veriﬁes C0 in the root itself. 2. For each (α, q) ∈ and each atomic concept A ∈A, there are transitions

δ(A, (α, q)) = true, if A ∈α false, if A ̸∈α

δ(¬A, (α, q)) = true, if A ̸∈α false, if A ∈α.

Such transitions check the truth value of atomic concepts and their negations in the current node of the tree. 3. For each (α, q) ∈ and each basic role Q ∈B, there are transitions

δ(Q, (α, q)) = true, if q = Q false, if q ̸= Q

δ(¬Q, (α, q)) = true, if q ̸= Q false, if q = Q.

Such transitions check through which role the current node is reached. 4. For the concepts in CLnnf(C0) and each σ ∈ , there are transitions

δ(C ⊓C′, σ) = (0, C) ∧(0, C′)

δ(C ⊔C′, σ) = (0, C) ∨(0, C′) δ(∀Q C σ) = ((0 ¬Q−) ∨( 1 C)) ∧ ((i ¬Q) ∨(i C))

δ(∀(R ⊔R′).C, σ) = (0, ∀R.C) ∧(0, ∀R′.C)

δ(∀(R ◦R′).C, σ) = (0, ∀R.∀R′.C)

δ(∀R∗.C, σ) = (0, C) ∧(0, ∀R.∀R∗.C)

δ(∀id(C).C′, σ) = (0, nnf(¬C)) ∨(0, C′)

δ(∃Q.C, σ) = ((0, Q−) ∧(−1, C)) ∨ 1≤i≤kC0((i, Q) ∧(i, C))

δ(∃(R ⊔R′).C, σ) = (0, ∃R.C) ∨(0, ∃R′.C)

δ(∃(R ◦R′).C, σ) = (0, ∃R.∃R′.C)

δ(∃R∗.C, σ) = (0, C) ∨(0, ∃R.∃R∗.C)

δ(∃id(C).C′, σ) = (0, C) ∧(0, C′).

All such transitions, except for those involving ∀R∗.C and ∃R∗.C, inductively decom- pose concepts and roles, and move to appropriate states of the automaton and nodes of the tree. The transitions involving ∀R∗.C treat ∀R∗.C as the equivalent concept C ⊓∀R.∀R∗.C, and the transitions involving ∃R∗.C treat ∃R∗.C as the equivalent concept C ⊔∃R.∃R∗.C. 5. For each concept of the form ⩽1 Q in CLnnf(C) and each σ ∈ , there is a transition

δ(⩽1 Q, σ) = ((0, Q−) ∧ 1≤i≤kC0(i, ¬Q)) ∨

((0, ¬Q−) ∧ 1≤i< j≤kC0 ((i, ¬Q) ∨( j, ¬Q))).

Such transitions check that, for a node x labeled with ⩽1 Q, there exists at most one node (among the predecessor and the successors of x) reachable from x through Q. 6. For each concept of the form ¬⩽1 Q in CLnnf(C) and each σ ∈ , there is a transition

δ(¬⩽1 Q, σ) = ((0, Q−) ∧ 1≤i≤kC0(i, Q)) ∨  1≤i< j≤kC0((i, Q) ∧( j, Q)).

Such transitions check that, for a node x labeled with ¬⩽1 Q, there exist at least two nodes (among the predecessor and the successors of x) reachable from x through Q.

r The set F of ﬁnal states is the set of concepts in CLnnf(C0) of the form ∀R∗.C. Observe that concepts of the form ∃R∗.C are not ﬁnal states, and this is sufﬁcient to guarantee that such concepts are satisﬁed in all accepting runs of the automaton.

A run of the automaton AC0 on an inﬁnite tree starts in the root, checking that C0 holds there (item 1 above). It does so by inductively decomposing nnf(C0) while appropriately navigating the tree (items 3 and 4) until it arrives at atomic concepts, functional restrictions, and their negations. These are checked locally (items 2, 5, and 6). Concepts of the form ∀R∗.C and ∃R∗.C are propagated using the equivalent concepts C ⊓∀R.∀R∗.C and C ⊔∃R.∃R∗.C, respectively. It is only the propagation of such concepts that may generate inﬁnite branches in a run. Now, a run of the automaton may contain an inﬁnite branch in which ∃R∗.C is always resolved by choosing the disjunct ∃R.∃R∗.C, without ever choosing the disjunct C This inﬁnite branch in the run corresponds to an inﬁnite path in the tree where

R is iterated forever and in which C is never fulﬁlled. However, the semantics of ∃R∗.C requires that C is fulﬁlled after a ﬁnite number of iterations of R. Hence such an inﬁnite path cannot be used to satisfy ∃R∗.C. The acceptance condition of the automaton, which requires that each inﬁnite branch in a run contains a state of the form ∀R∗.C, rules out such inﬁnite branches in accepting runs. Indeed, a run always deferring the fulﬁllment of C will contain an inﬁnite branch where all states have the form ∃R1. · · · ∃Rn.∃R∗.C, with n ≥0 and R1 ◦· · · ◦Rn a postﬁx of R. Observe that the only remaining inﬁnite branches in a run are those that arise by propagating concepts of the form ∀R∗.C indeﬁnitely often. The acceptance condition allows for such branches. Given a labeled tree T = (T, V ) accepted by AC0, we deﬁne an interpreta- tion IT = (I, ·I) as follows. First, we deﬁne for each atomic role P, a re- lation RP as follows: RP = { (x, xi) | xi ∈T and V (xi) = (α, P) for some α ∈ 2A } ∪{(xi, x) | xi ∈T and V (xi) = (α, P−) for some α ∈2A }.Then,usingsuch relations, we deﬁne:

r I = { x | (ε, x) ∈( P(RP ∪R− P))∗}; r AI = I ∩{ x | V (x) = (α, q) and A ∈α, for some α ∈2A and q ∈B ∪{Pdum} }, for each atomic concept A; r PI = (I × I) ∩RP, for each atomic role P.

Lemma 5.7 If a labeled tree T is accepted by AC0, then IT is a model of C0.

Conversely, given a tree model I of C0 with branching degree kC0, we can obtain a labeled tree TI = (T, V ) (with branching degree kC0) as follows:

r T = I; r V (ε) = (α, Pdum), where α = {A | ε ∈AI}; r V (xi) = (α, Q), where α = {A | xi ∈AI} and (x, xi) ∈QI.

Lemma 5.8 If I is a tree model of C0 with branching degree kC0, then TI is a labeled tree accepted by AC0.

From the lemmas above and the tree model property of ALCFIreg (Theorem 5.6), we get the following result.

Theorem 5.9 An ALCFIreg concept C0 is satisﬁable if and only if the set of trees accepted by AC0 is not empty.

From this theorem, it follows that we can use algorithms for non-emptiness of 2ATAs to check satisﬁability in ALCFI It turns out that such a decision

procedure is indeed optimal w.r.t. the computational complexity. The 2ATA AC0 has a number of states that is linear in the size of C0, while the alphabet is ex- ponential in the number of atomic concepts occurring in C0. By Theorem 5.5 we get an upper bound for reasoning in ALCFIreg that matches the ExpTime lower bound.

Theorem 5.10 Concept satisﬁability (and hence logical implication) in ALCFIreg is ExpTime-complete.

Functional restrictions, in the context of expressive Description Logics that in- clude inverse roles and TBox axioms, were originally studied in [De Giacomo and Lenzerini, 1994a; De Giacomo, 1995] using the so called axiom schema in- stantiation technique. The technique is based on the idea of devising an axiom schema corresponding to the property of interest (e.g., functional restrictions) and instantiating such a schema to a ﬁnite (polynomial) number of concepts. A nice illustration of this technique is the reduction of converse-pdl to pdl in [De Gi- acomo, 1996]. Axiom schema instantiation can be used to show that reasoning w.r.t. TBoxes is ExpTime-complete in signiﬁcant subcases of ALCFIreg (such as reasoning w.r.t. ALCFI TBoxes [Calvanese et al., 2001b]). However, it is still open whether it can be applied to show ExpTime-completeness of ALCFIreg. The attempt in this direction presented in [De Giacomo and Lenzerini, 1994a; De Giacomo, 1995] turned out to be incomplete [Zakharyaschev, 2000].

5.4 Qualiﬁed number restrictions

Next we deal with qualiﬁed number restrictions, which are the most general form of number restrictions, and allow one to specify arbitrary cardinality constraints on roles with role ﬁllers belonging to a certain concept. In particular we will consider qualiﬁed number restrictions on basic roles, i.e., atomic roles and their inverse. By adding such constructs to ALCIreg we obtain the Description Logic ALCQIreg. The PDL corresponding to ALCQIreg is an extension of converse-pdl with “graded modalities” [Fattorosi-Barnaba and De Caro, 1985; Van der Hoek and de Rijke, 1995; Tobies, 1999c] on atomic programs and their converse. Formally, ALCQIreg is obtained from ALCIreg by adding qualiﬁed number restrictions of the form ⩽n Q.C and ⩾n Q.C, where n is a nonnegative integer, Q is a basic role, and C is an ALCQIreg concept. Such constructs are interpreted as follows:

(⩽n Q.C)I = {o ∈I | |{o′ ∈I | (o, o′) ∈QI ∧o′ ∈CI}| ≤n} (⩾n Q C)I {o ∈I | |{o′ ∈I | (o o′) ∈QI ∧o′ ∈CI}| ≥n}

Reasoning in ALCQIreg is still ExpTime-complete under the standard assump- tion in Description Logics, that numbers in number restrictions are represented in unary.6 This could be shown by extending the automata-theoretic techniques introduced in Section 5.3 to deal also with qualiﬁed number restrictions. Here we take a different approach and study reasoning in ALCQIreg by exhibiting a reduction from ALCQIreg to ALCFIreg [De Giacomo and Lenzerini, 1995; De Giacomo, 1995]. Since the reduction is polynomial, we get as a result Exp- Time-completeness of ALCQIreg. The reduction is based on the notion of reiﬁ- cation. Such a notion plays a major role in dealing with Boolean combinations of (atomic) roles [De Giacomo and Lenzerini, 1995; 1994c], as well as in extending expressive Description Logics with relations of arbitrary arity (see Section 5.7).

5.4.1 Reiﬁcation of roles

Atomic roles are interpreted as binary relations. Reifying a binary relation means creating for each pair of individuals (o1, o2) in the relation an individual which is connected by means of two special roles V1 and V2 to o1 and o2, respectively. The set of such individuals represents the set of pairs forming the relation. However, the following problem arises: in general, there may be two or more individuals all connected by means of V1 and V2 to o1 and o2 respectively, and thus all representing the same pair (o1, o2). Obviously, in order to have a correct representation of a relation, such a situation must be avoided. Given an atomic role P, we deﬁne its reiﬁed form to be the role

V − 1 ◦id(AP) ◦V2

where AP is a new atomic concept denoting individuals representing the tuples of the relation associated with P, and V1 and V2 denote two functional roles that connect each individual in AP respectively to the ﬁrst and the second component of the tuple represented by the individual. Observe that there is a clear symmetry between the role V − 1 ◦id(AP) ◦V2 and its inverse V − 2 ◦id(AP) ◦V1.

Deﬁnition 5.11 Let C be an ALCQIreg concept. The reiﬁed counterpart ξ1(C) of C is the conjunction of two concepts, ξ1(C) = ξ0(C) ⊓ 1, where:

r ξ0(C) is obtained from the original concept C by (i) replacing every atomic role P by the complex role V − 1 ◦id(AP) ◦V2, where V1 and V2 are new atomic roles (the only ones present after the transformation) and AP is a new atomic concept; (ii) and then

6 In [Tobies, 2001a] techniques for dealing with qualiﬁed number restrictions with numbers coded in binary are presented, and are used to show that even under this assumption reasoning over ALCQI knowledge bases can b d i E T

re-expressing every qualiﬁed number restriction

⩽n (V − 1 ◦id(AP) ◦V2).D as ⩽n V − 1 .(AP ⊓∃V2.D) ⩾n (V − 1 ◦id(AP) ◦V2).D as ⩾n V − 1 .(AP ⊓∃V2.D) ⩽n (V − 2 ◦id(AP) ◦V1).D as ⩽n V − 2 .(AP ⊓∃V1.D) ⩾n (V − 2 ◦id(AP) ◦V1).D as ⩾n V − 2 .(AP ⊓∃V1.D)

r 1 = ∀(V1 ⊔V2 ⊔V − 1 ⊔V − 2 )∗.(⩽1 V1 ⊓⩽1 V2).

The next theorem guarantees that, without loss of generality, we can restrict our attention to models of ξ1(C) that correctly represent relations associated with atomic roles, i.e., models in which each tuple of such relations is represented by a single individual.

Theorem 5.12 If the concept ξ1(C) has a model I then it has a model I′ such that for each (o, o′) ∈(V − 1 ◦id(APi) ◦V2)I′ there is exactly one individual ooo′ such that (ooo′, o) ∈V I′ 1 and (ooo′, o′) ∈V I′ 2 . That is, for all o1, o2, o, o′ ∈I′ such that o1 ̸= o2 and o ̸= o′, the following condition holds:

o1, o2 ∈AI′ Pi ⊃¬((o1, o) ∈V I′ 1 ∧(o2, o) ∈V I′ 1 ∧(o1, o′) ∈V I′ 2 ∧(o2, o′) ∈V I′ 2 ).

The proof of Theorem 5.12 exploits the disjoint union model property: let C be an ALCQIreg concept and I = (I, ·I) and J = (J , ·J ) be two models of C, then also the interpretation I ⊎J = (I ⊎J , ·I ⊎·J ), which is the disjoint union of I and J , is a model of C. We remark that most Description Logics have such a property, which is, in fact, typical of modal logics. Without going into details, we just mention that the model I′ is constructed from I as the disjoint union of several copies of I, in which the extension of role V2 is modiﬁed by exchanging, in those instances that cause a wrong representation of a role, the second component with a corresponding individual in one of the copies of I. By using Theorem 5.12 we can prove the result below.

Theorem 5.13 An ALCQIreg concept C is satisﬁable if and only if its reiﬁed counterpart ξ1(C) is satisﬁable.

5.4.2 Reducing ALCQIreg to ALCFIreg

By Theorem 5.13, we can concentrate on the reiﬁed counterparts of ALCQIreg concepts. Note that these are themselves ALCQIreg concepts, but their special form allows us to convert them into ALCFIreg concepts. Intuitively, we represent the role V −i 1 2 (recall that V is functional while V −is not) by the role

FVi ◦F′ Vi ∗, where FVi and F′ Vi are new functional roles.7 The main point of such a transformationisthatitiseasytoexpressqualiﬁednumberrestrictionsasconstraints on the chain of (FVi ◦F′ Vi ∗)-successors of an individual. Formally, we deﬁne the ALCFIreg-counterpart of an ALCQIreg concept as follows.

Deﬁnition 5.14 Let C be an ALCQIreg concept and ξ1(C) = ξ0(C) ⊓ 1 its rei- ﬁed counterpart. The ALCFIreg-counterpart ξ2(C) of C is the conjunction of two concepts, ξ2(C) = ξ ′ 0(C) ∧ 2, where:

r ξ ′ 0(C) is obtained from ξ0(C) by simultaneously replacing:8

– every occurrence of role Vi in constructs different from qualiﬁed number restrictions by (FVi ◦F′ Vi ∗)−, where FVi and F′ Vi are new atomic roles; – every ⩽n V − i .D by ∀(FVi ◦F′ Vi ∗◦(id(D) ◦F′ Vi +)n).¬D; – every ⩾n V − i .D by ∃(FVi ◦F′ Vi ∗◦(id(D) ◦F′ Vi +)n−1).D. r 2 = ∀( i=1,2(FVi ⊔F′ Vi ⊔F− Vi ⊔F′ Vi −))∗.(θ1 ⊓θ2), with θi of the form:

⩽1 FVi ⊓⩽1 F′ Vi ⊓⩽1 F− Vi ⊓⩽1 F′ Vi −⊓¬(∃F− Vi .⊤⊓∃F′ Vi −.⊤).

Observe that 2 constrains each model I of ξ2(C) so that the relations FI Vi, F′ Vi I, (F− Vi )I, and (F′ Vi −)I are partial functions, and each individual cannot be linked to other individuals by both (F− Vi )I and (F′ Vi −)I. As a consequence, we get that ((FVi ◦F′ Vi ∗)−)I is a partial function. This allows us to reconstruct the extension of Vi, as required. We illustrate the basic relationships between a model of an ALCQIreg concept and the models of its reiﬁed counterpart and ALCFIreg-counterpart by means of an example.

Example 5.15 Consider the concept

C0 = ∃P.(= 2 P−.(= 2 P.⊤))

and consider the model I of C0 depicted in Figure 5.1, in which a ∈CI 0 . Such a model corresponds to a model I′ of the reiﬁed counterpart ξ1(C0) of C0, shown in Figure 5.2. The model I′ of ξ1(C0) in turn corresponds to a model I′′ of the ALCFIreg-counterpart ξ2(C0) of C0, shown in Figure 5.3. Notice that from I′′ we can easily reconstruct I′, and from I′ the model I of the original concept.

It can be shown that ξ1(C) is satisﬁable if and only if ξ2(C) is satisﬁable. Since, as it is easy to see, the size of ξ2(C) is polynomial in the size of C, we get the following characterization of the computational complexity of reasoning in ALCQIreg.

7 The idea of expressing nonfunctional roles by means of chains of functional roles is due to Parikh [1981], who used it to reduce standard pdl to dpdl. 8 H R+ t d f R R∗ d Rn t d f R R ( ti )

a b

P P P P

c d e

Fig. 5.1. A model of the ALCQIreg concept C0 = ∃P.(= 2 P−.(= 2 P.⊤)).

a b

AP 1 AP AP AP 3 V1 V1 V1 V1 2 4

V2 V2 V2 V2

c d e

Fig. 5.2. A model of the reiﬁed counterpart ξ1(C0) of C0.

Theorem 5.16 Concept satisﬁability (and hence logical implication) in ALCQIreg is ExpTime-complete.

5.5 Objects

In this section, we review results involving knowledge about individuals expressed in terms of membership assertions. Given an alphabet O of symbols for individuals, a (membership) assertion has one of the following forms:

C(a) P(a1, a2)

whereC isaconcept, P isanatomicrole,anda,a1,a2 belongtoO.Aninterpretation I isextendedsoastoassigntoeacha ∈O anelementaI ∈I insuchawaythatthe unique name assumption is satisﬁed, i.e., different elements are assigned to different symbols in O. I satisﬁes C(a) if aI ∈CI, and I satisﬁes P(a1, a2) if (aI 1 , aI 2 ) ∈PI. An ABox A is a ﬁnite set of membership assertions, and an interpretation I is called a model of A if I satisﬁes every assertion in A. AknowledgebaseisapairK = (T , A),whereT isaTBox,andAisanABox.An interpretationI iscalledamodelof K ifitisamodelofbothT andA.K issatisﬁable if it has a model, and K logically implies an assertion β, denoted K |= β, where β is either an inclusion or a membership assertion, if every model of K satisﬁes β. Logical implication can be reformulated in terms of unsatisﬁability: e.g., K |= C(a) iff K ∪{¬C(a)} is unsatisﬁable; similarly K |= C1 ⊑C2 iff K ∪{(C1 ⊓¬C2)(a′)} is unsatisﬁable, where a′ does not occur in K. Therefore, we only need a procedure for checking satisﬁability of a knowledge base

a b

AP 1 AP AP AP 2 4 FV1

FV1

F ′ V1 F ′ V1 F ′ V2 3

FV2 FV2

FV2

c d e

Fig. 5.3. A model of the ALCFIreg-counterpart ξ2(C0) of C0.

Next we illustrate the technique for reasoning on ALCQIreg knowledge bases [De Giacomo and Lenzerini, 1996]. The basic idea is as follows: checking the satisﬁability of an ALCQIreg knowledge base K = (T , A) is polynomially reduced to checking the satisﬁability of an ALCQIreg knowledge base K′ = (T ′, A′), whose ABox A′ is made of a single membership assertion of the form C(a). In other words, the satisﬁability of K is reduced to the satisﬁability of the concept C w.r.t. the TBox T ′ of the resulting knowledge base. The latter reasoning service can be realized by means of the method presented in Section 5.4, and, as we have seen, is ExpTime- complete. Thus, by means of the reduction, we get an ExpTime algorithm for satisﬁability of ALCQIreg knowledge bases, and hence for all standard reasoning services on ALCQIreg knowledge bases.

Deﬁnition 5.17 Let K = (T , A) be an ALCQIreg knowledge base. The reduced form of K is the ALCQIreg knowledge base K′ = (T ′, A′) deﬁned as follows. We introduce a new atomic role create, and also for each individual ai, i = 1, . . . , m, occurring in A, a new atomic concept Ai. Then:

A′ = {(∃create.A1 ⊓· · · ⊓∃create.Am)(g)},

where g is a new individual (the only one present in A′), and T ′ = T ∪TA ∪Taux, where:

r TA is constituted by the following inclusion axioms: – for each membership assertion C(ai) ∈A, one inclusion axiom

Ai ⊑C

– for each membership assertion P(ai, a j) ∈A, two inclusion axioms

Ai ⊑ ∃P.A j ⊓⩽1 P.A j A j ⊑ ∃P−.Ai ⊓⩽1 P−.Ai

– for each pair of distinct individuals ai and a j occurring in A, one inclusion axiom

A ⊑ A

r Taux is constituted by one inclusion axiom (U stands for (P1 ⊔· · · ⊔Pn ⊔P1 ⊔· · · ⊔ P− n )∗, where P1, . . . , Pn are all atomic roles in T ∪TA):

Ai ⊓C ⊑∀U.(¬Ai ⊔C)

for each Ai occurring in T ∪TA and each C ∈CLext (T ∪TA), where CLext (T ∪TA) is a suitably extended syntactic closure9 of T ∪TA whose size is polynomially related to the size of T ∪TA [De Giacomo and Lenzerini, 1996].

To understand how the reduced form K′ = (T ′, A′) relates to the original knowl- edge base K = (T , A), ﬁrst observe that the ABox A′ is used to force the exis- tence of the only individual g connected by the role create to one instance of each Ai. It can be shown that this allows us to restrict our attention to models of K′

that represent a graph connected to g, i.e., models I = (I, ·I) of K′ such that I = {g} ∪{s′ | (g, s′) ∈createI ◦( P(PI ∪PI−)∗)}. The TBox T ′ consists of three parts T , TA, and Taux. T is the original inclusion axioms. TA is what we may call a “naive encoding” of the original ABox A as inclusion axioms. Indeed, each individual ai is represented in TA as a new atomic concept Ai (disjoint from the other A j’s), and the membership assertions in the original ABox A are represented as inclusion axioms in TA involving such new atomic concepts. However T ∪TA alone does not sufﬁce to represent faithfully (w.r.t. the reasoning services we are interested in) the original knowledge base, because an individual ai in K is represented by the set of instances of Ai in K′. In order to reduce the satisﬁability of K′ to the satisﬁability of K, we must be able to single out, for each Ai, one instance of Ai representative of ai. For this purpose, we need to include in T ′ a new part, called Taux, which contains inclusion axioms of the form

Ai ⊓C ⊑∀U.(¬Ai ⊔C).

Intuitively, such axioms say that, if one instance of Ai is also an instance of C, then every instance of Ai is an instance of C. Observe that, if we could add an inﬁnite set of axioms of this form, one for each possible concept of the language (i.e., an axiom schema), we could safely restrict our attention to models of K′ with just one instance for every concept Ai, since there would be no way in the logic to distinguish two instances of Ai one from the other. What is shown by De Giacomo and Lenzerini [1996] is that in fact we do need only a polynomial number of such inclusion axioms (as speciﬁed by Taux) in order to be able to identify, for each i, an instance of Ai as representative of ai. This allows us to prove that the existence of a model of K′ implies the existence of a model of K.

9 The syntactic closure of a TBox is the syntactic closure of the concept obtained by internalizing the axioms of th TB

Theorem 5.18 Knowledge base satisﬁability (and hence every standard reasoning service) in ALCQIreg is ExpTime-complete.

Using a similar approach, De Giacomo and Lenzerini [1994a] and De Gia- como [1995] extend ALCQreg and ALCIreg by adding special atomic concepts Aa, called nominals, having exactly one single instance a, i.e., the individual they name. Nominals may occur in concepts exactly as atomic concepts, and hence they con- stitute one of the most ﬂexible ways to express knowledge about single individuals. By using nominals we can capture the “one-of” construct, having the form {a1, . . . , an}, denoting the concept made of exactly the enumerated individu- als a1, . . . , an.10 We can also capture the “ﬁlls” construct, having the form R : a, denoting those individuals having the individual a as a role ﬁller of R.11

(See [Schaerf, 1994b] and references therein for further discussion on these constructs.) Let us denote by ALCQOreg and ALCIOreg the Description Logics result- ing from adding nominals to ALCQreg and ALCIreg respectively. De Giacomo and Lenzerini [1994a] and De Giacomo [1995] polynomially reduce satisﬁability in ALCQOreg and ALCIOreg knowledge bases to satisﬁability of ALCQreg and ALCIreg concepts respectively, hence showing decidability and ExpTime- completeness of reasoning in these logics. ExpTime-completeness does not hold for ALCQIOreg, i.e., ALCQIreg extended with nominals. Indeed, a result by Tobies [1999a; 1999b] shows that reasoning in such a logic is NExpTime-hard. Its decidability remains an open problem. The notion of nominal introduced above has a correspondent in modal logic [Prior, 1967; Bull, 1970; Blackburn and Spaan, 1993; Gargov and Goranko, 1993; Blackburn, 1993]. Nominals have also been studied within the setting of PDLs [Passy and Tinchev, 1985; Gargov and Passy, 1988; Passy and Tinchev, 1991]. The results for ALCQOreg and ALCIOreg are immediately applicable also in the setting of PDLs. In particular, the PDL corresponding to ALCQOreg is standard pdl augmented with nominals and graded modalities (qualiﬁed number restric- tions). It is an extension of deterministic combinatory PDL, dcpdl, which is essen- tially dpdl augmented with nominals. The decidability of dcpdl is established by Passy and Tinchev [1985], who also prove that satisﬁability can be checked in nondeterministic double exponential time. This is tightened by the result above on ExpTime-completeness of ALCQOreg, which says that dcpdl is in fact Exp- Time-complete, thus closing the previous gap between the upper bound and the lower bound. The PDL corresponding to ALCIOreg is converse-pdl augmented

10 Actually, nominals and the one-of construct are essentially equivalent, since a name Aa is equivalent to {a} and {a1, . . . , an} is equivalent to Aa1 ⊔· · · ⊔Aan . 11 Th “ﬁll ” t t R i t d b ∃R A

with nominals, which is also called converse combinatory PDL, ccpdl [Passy and Tinchev, 1991]. Such a logic was not known to be decidable [Passy and Tinchev, 1991]. Hence the results mentioned above allow us to establish the decidability of ccpdl and to precisely characterize the computational complexity of satisﬁability (and hence of logical implication) as ExpTime-complete.

5.6 Fixpoint constructs

Decidable Description Logics equipped with explicit ﬁxpoint constructs have been devised in order to model inductive and coinductive data structures such as lists, streams, trees, etc. [De Giacomo and Lenzerini, 1994d; Schild, 1994; De Giacomo and Lenzerini, 1997; Calvanese et al., 1999c]. Such logics correspond to extensions of the propositional µ-calculus [Kozen, 1983; Streett and Emerson, 1989; Vardi, 1998], a variant of PDL with explicit ﬁxpoints that is used to express temporal properties of reactive and concurrent processes [Stirling, 1996; Emerson, 1996]. Such logics can also be viewed as a well-behaved fragment of ﬁrst-order logic with ﬁxpoints [Park, 1970; 1976; Abiteboul et al., 1995]. Here, we concentrate on the Description Logic µALCQI studied by Calvanese et al. [1999c]. Such a Description Logic is derived from ALCQI by adding least and greatest ﬁxpoint constructs. The availability of explicit ﬁxpoint con- structs allows inductive and coinductive concepts to be expressed in a natural way.

Example 5.19 Consider the concept Tree, representing trees, inductively deﬁned as follows:

(i) An individual that is an EmptyTree is a Tree. (ii) If an individual is a Node, has at most one parent, has some children, and all children are Trees, then such an individual is a Tree.

In other words, Tree is the concept with the smallest extension among those satis- fying the assertions (i) and (ii). Such a concept is naturally expressed in µALCQI by making use of the least ﬁxpoint construct µX.C:

Tree ≡µX.(EmptyTree ⊔(Node ⊓⩽1 child−⊓∃child.⊤⊓∀child.X)).

Example 5.20 Consider the well-known linear data structure, called stream. Streams are similar to lists except that, while lists can be considered as ﬁnite sequences of nodes, streams are inﬁnite sequences of nodes. Such a data structure is captured by the concept Stream, coinductively deﬁned as follows:

(i) An indi id al that is a Stream is a Node and has a single s ccessor hich is a Stream

In other words, Stream is the concept with the largest extension among those satisfying condition (i). Such a concept is naturally expressed in µALCQI by making use of the greatest ﬁxpoint construct νX.C:

Stream ≡νX.(Node ⊓⩽1 succ ⊓∃succ.X).

Let us now introduce µALCQI formally. We make use of the standard ﬁrst- order notions of scope, bound and free occurrences of variables, closed formulae, etc., treating µ and ν as quantiﬁers. The primitive symbols in µALCQI are atomic concepts, (concept) variables, and atomic roles. Concepts and roles are formed according to the following syntax:

C −→A | ¬C | C1 ⊓C2 | ⩾n R.C | µX.C | X R −→P | P−

where A denotes an atomic concept, P an atomic role, C an arbitrary µALCQI concept, R an arbitrary µALCQI role (i.e., either an atomic role or the inverse of an atomic role), n a natural number, and X a variable. The concept C in µX.C must be syntactically monotone, that is, every free occurrence of the variable X in C must be in the scope of an even number of negations [Kozen, 1983]. This restriction guarantees that the concept C denotes a monotonic operator and hence both the least and the greatest ﬁxpoints exist and are unique (see later). In addition to the usual abbreviations used in ALCQI, we introduce the abbre- viation νX.C for ¬µX.¬C[X/¬X], where C[X/¬X] is the concept obtained by replacing all free occurrences of X by ¬X. The presence of free variables prevents us from extending the interpretation function ·I directly to every concept of the logic. For this reason we introduce valuations. A valuation ρ on an interpretation I is a mapping from variables to subsets of I. Given a valuation ρ, we denote by ρ[X/E] the valuation identical to ρ except that ρ[X/E](X) = E. Let I be an interpretation and ρ a valuation on I. We assign meaning to concepts of the logic by associating to I and ρ an extension function ·I ρ, mapping concepts to subsets of I, as follows:

XI ρ = ρ(X) ⊆I

AI ρ = AI ⊆I

(¬C)I ρ = I \ CI ρ (C1 ⊓C2)I ρ = (C1)I ρ ∩(C2)I ρ ⩾n R.CI ρ = {s ∈I | | {s′ | (s, s′) ∈RI and s′ ∈CI ρ } | ≥n}

(µX C)I =  {E ⊆I| CI ⊆E }

Observe that CI ρ[X/E] can be seen as an operator from subsets E of I to subsets of I, and that, by the syntactic restriction enforced on variables, such an operator is guaranteed to be monotonic w.r.t. set inclusion. µX.C denotes the least ﬁxpoint of the operator. Observe also that the semantics assigned to νX.C is

(νX.C)I ρ =  {E ⊆I |E ⊆CI ρ[X/E] }.

Hence νX.C denotes the greatest ﬁxpoint of the operator. In fact, we are interested in closed concepts, whose extension is independent of the valuation. For closed concepts we do not need to consider the valuation explicitly, and hence the notions of concept satisﬁability, logical implication, etc. extend straightforwardly. Exploiting a recent result on ExpTime decidability of modal µ-calculus with converse [Vardi, 1998], and exploiting a reduction technique for quali- ﬁed number restrictions similar to the one presented in Section 5.4, Calvanese etal.[1999c]haveshownthatthesamecomplexityboundholdsalsoforreasoningin µALCQI.

Theorem 5.21 Concept satisﬁability (and hence logical implication) in µALCQI is ExpTime-complete.

For certain applications, variants of µALCQI that allow for mutual ﬁxpoints, denoting least and greatest solutions of mutually recursive equations, are of interest [Schild, 1994; Calvanese et al., 1998c; 1999b]. Mutual ﬁxpoints can be re-expressed by suitably nesting the kind of ﬁxpoints considered here (see, for example, [de Bakker, 1980; Schild, 1994]). It is interesting to notice that, although the resulting concept may be exponentially large in the size of the original concept with mutual ﬁxpoints, the number of (distinct) subconcepts of the resulting concept is polyno- mially bounded by the size of the original one. By virtue of this observation, and using the reasoning procedure of Calvanese et al. [1999c], we can strengthen the above result.

Theorem 5.22 Checking satisﬁability of a closed µALCQI concept C can be done in deterministic exponential time w.r.t. the number of (distinct) subconcepts of C.

Although µALCQI does not have the rich variety of role constructs of ALCQIreg, it is actually an extension of ALCQIreg, since any ALCQIreg con- cept can be expressed in µALCQI using the ﬁxpoint constructs in a suitable way. To express concepts involving complex role expressions it sufﬁces to resort to the

following equivalences:

∃(R1 ◦R2).C = ∃R1.∃R2.C ∃(R1 ⊔R2).C = ∃R1.C ⊔∃R2.C ∃R∗.C = µX.(C ⊔∃R.X) ∃id(D).C = C ⊓D.

Note that, according to such equivalences, we have also that

∀R∗.C = νX.(C ⊓∀R.X).

Calvanese et al. [1995] advocate a further construct corresponding to an implicit form of ﬁxpoint, the so called well-founded concept construct wf (R). Such a con- struct is used to impose well-foundedness of chains of roles, and thus allows one to correctly capture inductive structures. Using explicit ﬁxpoints, wf (R) is expressed as µX.(∀R.X). We remark that, in order to gain the ability to express inductively and coin- ductively deﬁned concepts, it has been proposed to adopt ad hoc semantics for interpreting knowledge bases, speciﬁcally the least ﬁxpoint semantics for ex- pressing inductive concepts and the greatest ﬁxpoint semantics for expressing coinductive ones (see Chapter 2 and also [Nebel, 1991; Baader, 1990a; 1991; Dionne et al., 1992; K¨usters, 1998; Buchheit et al., 1998]). Logics equipped with ﬁxpoint constructs allow statements interpreted according to the least and greatest ﬁxpoint semantics to be mixed in the same knowledge base [Schild, 1994; De Giacomo and Lenzerini, 1997], and thus can be viewed as a generalization of these approaches. Recently, using techniques based on alternating two-way automata, it has been shown that the propositional µ-calculus with converse programs remains Exp- Time-decidable when extended with nominals [Sattler and Vardi, 2001]. This logic corresponds to a Description Logic which could be called µALCIO.

5.7 Relations of arbitrary arity

A limitation of traditional Description Logics is that only binary relationships between instances of concepts can be represented, while in some real world sit- uations it is required to model relationships among more than two objects. Such relationships can be captured by making use of relations of arbitrary arity instead of (binary) roles. Various extensions of Description Logics with relations of ar- bitrary arity have been proposed [Schmolze, 1989; Catarci and Lenzerini, 1993; De Giacomo and Lenzerini, 1994c; Calvanese et al., 1997; 1998a; Lutz et al., 1999]. We concentrate on the Description Logic DLR [Calvanese et al., 1997; 1998a], which represents a natural generalization of traditional Description Logics towards

n-ary relations. The basic elements of DLR are atomic relations and atomic con- cepts, denoted by P and A respectively. Arbitrary relations, of given arity between 2 and nmax, and arbitrary concepts are formed according to the following syntax:

R −→⊤n | P | ($i/n: C) | ¬R | R1 ⊓R2 C −→⊤1 | A | ¬C | C1 ⊓C2 | ∃[$i]R | ⩽k [$i]R

where i denotes a component of a relation, i.e., an integer between 1 and nmax, n denotes the arity of a relation, i.e., an integer between 2 and nmax, and k denotes a nonnegative integer. Concepts and relations must be well-typed, which means that only relations of the same arity n can be combined to form expressions of type R1 ⊓R2 (which inherit the arity n), and i ≤n whenever i denotes a component of a relation of arity n. The semantics of DLR is speciﬁed through the usual notion of interpretation I = (I, ·I), where the interpretation function ·I assigns to each concept C a subset CI of I, and to each relation R of arity n a subset RI of (I)n, such that the following conditions are satisﬁed:

⊤I n ⊆ (I)n

PI ⊆ ⊤I n (¬R)I = ⊤I n \ RI

(R1 ⊓R2)I = RI 1 ∩RI 2 ($i/n: C)I = {(d1, . . . , dn) ∈⊤I n | di ∈CI}

⊤I 1 = I

AI ⊆ I

(¬C)I = I \ CI

(C1 ⊓C2)I = CI 1 ∩CI 2 (∃[$i]R)I = {d ∈I | ∃(d1, . . . , dn) ∈RI. di = d} (⩽k [$i]R)I =  d ∈I | | {(d1, . . . , dn) ∈RI 1 | di = d |} ≤k}

where P, R, R1, and R2 have arity n. Observe that ⊤1 denotes the interpretation domain, while ⊤n, for n > 1, does not denote the n-cartesian product of the domain, but only a subset of it, that covers all relations of arity n that are introduced. As a consequence, the “¬” construct on relations expresses difference of relations rather than complement. The construct ($i/n: C) denotes all tuples in ⊤n that have an instance of concept C as their ith component, and therefore represents a kind of selection. Existential quantiﬁcation and number restrictions on relations are a natural generalization of the corresponding constructs using roles. This can be seen by observing that, while for roles the “direction of traversal” is implicit, for a relation one needs to explicitly say which component is used to “enter” a tuple and which component is used to “exit” it

DLR is in fact a proper generalization of ALCQI. The traditional DL constructs can be re-expressed in DLR as follows:

∃P.C as ∃[$1](P ⊓($2/2: C)) ∃P−.C as ∃[$2](P ⊓($1/2: C)) ∀P.C as ¬∃[$1](P ⊓($2/2: ¬C)) ∀P−.C as ¬∃[$2](P ⊓($1/2: ¬C)) ⩽k P.C as ⩽k [$1](P ⊓($2/2: C)) ⩽k P−.C as ⩽k [$2](P ⊓($1/2: C)).

Observe that the constructs using direct and inverse roles are represented in DLR by using binary relations and explicitly specifying the direction of traversal. A TBox in DLR is a ﬁnite set of inclusion axioms on both concepts and relations of the form

C ⊑C′ R ⊑R′

where R and R′ are two relations of the same arity. The notions of an interpretation satisfying an assertion, and of model of a TBox are deﬁned as usual. The basic technique used in DLR to reason on relations is reiﬁcation (see Subsection 5.4.1), which allows one to reduce logical implication in DLR to logi- cal implication in ALCQI. Reiﬁcation for n-ary relations is similar to reiﬁcation of roles (see Deﬁnition 5.11): a relation of arity n is reiﬁed by means of a new concept and n functional roles f1, . . . , fn. Let the ALCQI TBox T ′ be the reiﬁed counterpart of a DLR TBox T . A tuple of a relation R in a model of T is repre- sented in a model of T ′ by an instance of the concept corresponding to R, which is linked through f1, . . . , fn respectively to n individuals representing the compo- nents of the tuple. In this case reiﬁcation is further used to encode Boolean con- structs on relations into the corresponding constructs on the concepts representing relations. As for reiﬁcation of roles (see Subsection 5.4.1), performing the reiﬁcation of relations requires some care, since the semantics of a relation rules out that there may be two identical tuples in its extension, i.e., two tuples constituted by the same components in the same positions. In the reiﬁed counterpart, on the other hand, one cannot explicitly rule out (e.g., by using speciﬁc axioms) the existence of two individuals o1 and o2 “representing” the same tuple, i.e., that are connected through f1, . . . , fn to exactly the same individuals denoting the components of the tuple. A model of the reiﬁed counterpart T ′ of T in which this situation occurs may not cor- respond directly to a model of T , since by collapsing the two equivalent individuals into a tuple, axioms may be violated (e.g., cardinality constraints). However, also in this case the analog of Theorem 5.12 holds, ensuring that from any model of T ′

one can construct a new one in which no two individuals represent the same tuple

Therefore one does not need to take this constraint explicitly into account when reasoning on the reiﬁed counterpart of a knowledge base with relations. Since reiﬁ- cation is polynomial, from ExpTime-decidability of logical implication in ALCQI (and ExpTime-hardness of logical implication in ALC) we get the following characterization of the computational complexity of reasoning in DLR [Calvanese et al., 1997].

Theorem 5.23 Logical implication in DLR is ExpTime-complete.

DLR can be extended to include regular expressions built over projections of relations on two of their components, thus obtaining DLRreg. Such a logic, which represents a generalization of ALCQIreg, allows the internalization of a TBox. ExpTime-decidability (and hence completeness) of DLRreg can again be shown by exploiting reiﬁcation of relations and reducing logical implication to concept satisﬁability in ALCQIreg [Calvanese et al., 1998a]. Recently, DLRreg has been extended to DLRµ, which includes explicit ﬁxpoint constructs on concepts, like those introduced in Section 5.6. The ExpTime-decidability result extends to DLRµ as well [Calvanese et al., 1999c]. Recently it has been observed that guarded fragments of ﬁrst-order logic [Andr´eka et al., 1996; Gr¨adel, 1999] (see Subsection 4.2.1), which include n-ary relations, share with Description Logics the “locality” of quantiﬁcation. This makes them of interest as extensions of Description Logics with n-ary relations [Gr¨adel, 1998; Lutz et al., 1999]. Such Description Logics are incomparable in expres- sive power with DLR and its extensions: On the one hand the Description Log- ics corresponding to guarded fragments allow one to refer, by the use of explicit variables, to components of relations in a more ﬂexible way than is possible in DLR. On the other hand such Description Logics lack number restrictions, and extending them with number restrictions leads to undecidability of reasoning. Also, reasoning in the guarded fragments is in general NExpTime-hard [Gr¨adel, 1998; 1999] and thus more difﬁcult than in DLR and its extensions, although PSpace- complete fragments have been identiﬁed [Lutz et al., 1999].

5.7.1 Boolean constructs on roles and role inclusion axioms

Observe also that DLR (and DLRreg) allows Boolean constructs on relations (with negation interpreted as difference) as well as relation inclusion axioms R ⊑R′. In fact, DLR (resp. DLRreg) can be viewed as a generalization of ALCQI (resp. ALCQIreg) extended with Boolean constructs on atomic and inverse atomic roles. Such extensions of ALCQI were ﬁrst studied in [De Giacomo and Lenz- erini 1994c; De Giacomo 1995] where logical implication was shown to be

ExpTime-complete by a reduction to ALCQI (resp. ALCQIreg). The logics above do not allow atomic roles to be combined with inverse roles in Boolean combina- tions and role inclusion axioms. Tobies [2001a] shows that, for ALCQI extended with arbitrary Boolean combinations of atomic and inverse atomic roles, logical implication remains in ExpTime. Note that, in all logics above, negation on roles is interpreted as difference. For results on the impact of full negation on roles see [Lutz and Sattler, 2001; Tobies, 2001a]. Horrocks et al. [2000b] investigate reasoning in SHIQ, which is ALCQI ex- tended with roles that are transitive and with role inclusion axioms on arbitrary roles (direct, inverse, and transitive). SHIQ does not include reﬂexive–transitive closure. However, transitive roles and role inclusions allow a universal role to be expressed (in a connected model), and hence allow TBoxes to be internalized. Satis- ﬁability and logical implication in SHIQ are ExpTime-complete [Tobies, 2001a]. The importance of SHIQ lies in the fact that it is the logic implemented by the current state-of-the-art DL-based systems (see Chapters 8 and 9).

5.7.2 Structured objects

An alternative way to overcome the limitations that result from the restriction to binary relationships between concepts, is to consider the interpretation domain as being constituted by objects with a complex structure, and extend the Description Logics with constructs that allow one to specify such a structure [De Giacomo and Lenzerini, 1995]. This approach is in the spirit of object-oriented data models used in databases [Lecluse and Richard, 1989; Bancilhon and Khoshaﬁan, 1989; Hull, 1988], and has the advantage, with respect to introducing relationships, that all aspects of the domain to be modeled can be represented in a uniform way, as concepts whose instances have certain structures. In particular, objects can either be unstructured or have the structure of a set or of a tuple. For objects having the structure of a set a particular role allows one to refer to the members of the set, and similarly each component of a tuple can be referred to by means of the (implicitly functional) role that labels it. In general, reasoning over structured objects can have a very high computational complexity [Kuper and Vardi, 1993]. However, reasoning over a signiﬁcant frag- ment of structuring properties can be reduced in polynomial time to reasoning in traditional Description Logics, again by exploiting reiﬁcation to deal with tuples and sets. Thus, for such a fragment, reasoning can be done in ExpTime [De Giacomo and Lenzerini, 1995]. An important aspect in exploiting Description Logics for reasoning over structured objects is being able to limit the depth of the structure of an object to avoid inﬁnite nesting of tuples or sets. This requires the use of a well founded construct which is a restricted form of ﬁxpoint (see Section 5 6)

5.8 Finite model reasoning

For expressive Description Logics, in particular for those containing inverse roles and functionality, a TBox may admit only models with an inﬁnite domain [Cosmadakis et al., 1990; Calvanese et al., 1994]. Similarly, there may be TBoxes in which a certain concept can be satisﬁed only in an inﬁnite model. This is illus- trated in the following example by Calvanese [1996c].

Example 5.24 Consider the TBox

FirstGuard ⊑ Guard ⊓∀shields−.⊥ Guard ⊑ ∃shields ⊓∀shields.Guard ⊓⩽1 shields−.

In a model of this TBox, an instance of FirstGuard can have no shields-predecessor, while each instance of Guard can have at most one. Therefore, the existence of an instance of FirstGuard implies the existence of an inﬁnite sequence of instances of Guard, each one connected through the role shields to the following one. This means that FirstGuard can be satisﬁed in an interpretation with a domain of arbitrary cardinality, but not in interpretations with a ﬁnite domain.

Note that the TBox above is expressed in a very simple Description Logic, in particular AL (see Chapter 2) extended with inverse roles and functionality. A logic is said to have the ﬁnite model property if every satisﬁable formula of the logic admits a ﬁnite model, i.e., a model with a ﬁnite domain. The example above shows that virtually all Description Logics including functionality, inverse roles, and TBox axioms (or having the ability to internalize them) lack the ﬁnite model property.Theexampleshowsalsothattolosetheﬁnitemodelproperty,functionality in only one direction is sufﬁcient. In fact, it is well known that converse-dpdl, which corresponds to a fragment of ALCFIreg, lacks the ﬁnite model property [Kozen and Tiuryn, 1990; Vardi and Wolper, 1986]. For all logics that lack the ﬁnite model property, reasoning with respect to unrestricted and ﬁnite models are fundamentally different tasks, and this needs to be taken explicitly into account when devising reasoning procedures. Restricting reasoning to ﬁnite domains is not common in knowledge representation. However, it is typically of interest in databases, where one assumes that the data available are always ﬁnite [Calvanese et al., 1994; 1999e]. When reasoning w.r.t. ﬁnite models, some properties that are essential for the techniques developed for unrestricted model reasoning in expressive Description Logics fail. In particular, all reductions exploiting the tree model property (or similar properties that are based on “unraveling” structures) [Vardi, 1997] cannot be applied since this property does not hold when only ﬁnite models are considered

An intuitive justiﬁcation can be given by observing that, whenever a (ﬁnite) model contains a cycle, the unraveling of such a model into a tree generates an inﬁnite structure. Therefore alternative techniques have been developed. In this section, we study decidability and computational complexity of ﬁnite model reasoning over TBoxes expressed in various sublanguages of ALCQI. Speciﬁcally, by using techniques based on reductions to linear programming prob- lems, we show that ﬁnite concept satisﬁability w.r.t. to ALUNI TBoxes12 consti- tuted by inclusion axioms only is ExpTime-complete [Calvanese et al., 1994], and that ﬁnite model reasoning in arbitrary ALCQI TBoxes can be done in determin- istic double exponential time [Calvanese, 1996a].

5.8.1 Finite model reasoning using linear inequalities

A procedure for ﬁnite model reasoning must speciﬁcally address the presence of number restrictions, since it is only in their presence that the ﬁnite model property fails. We discuss a method which is indeed based on an encoding of number restric- tions into linear inequalities, and which generalizes the one developed by Lenzerini and Nobili [1990] for the Entity–Relationship model with disjoint classes and rela- tionships (hence without IS-A). We ﬁrst describe the idea underlying the reasoning technique in a simpliﬁed case. In the next subsection we show how to apply the tech- nique to various expressive Description Logics [Calvanese and Lenzerini, 1994b; 1994a; Calvanese et al., 1994; Calvanese, 1996a]. Consider an ALNI TBox13 T containing the following axioms: for each pair of distinct atomic concepts A and A′, an axiom A ⊑¬A′; and for each atomic role P, an axiom of the form ⊤⊑∀P.A2 ⊓∀P−.A1, for some atomic concepts A1 and A2 (not necessarily distinct). Such axioms enforce that in all models of T the following hold:

P1: The atomic concepts have pairwise disjoint extensions. P2: Each role is “typed”, which means that its domain is included in the extension of an atomic concept A1, and its codomain is included in the extension of an atomic concept A2.

AssumefurtherthattheonlyadditionalaxiomsinT areusedtoimposecardinality constraints on roles and inverse roles, and are of the form

⊤ ⊑ ⩾m1 P ⊓⩽n1 P ⊤ ⊑ ⩾m2 P−⊓⩽n2 P−

where m1, n1, m2, and n2 are positive integers with m1 ≤n1 and m2 ≤n2.

12 ALUNI is the Description Logic obtained by extending ALUN (see Chapter 2) with inverse roles. 13 ALNI i th D i ti L i bt i d b t di ALN ( Ch t 2) ith i l

Due to the fact that properties P1 and P2 hold, the local conditions imposed by number restrictions on the number of successors of each individual are reﬂected into global conditions on the total number of instances of atomic concepts and roles. Speciﬁcally, it is not difﬁcult to see that, for a model I of such a TBox, and for each P, A1, A2, m1, m2, n1, and n2 as above, the cardinalities of PI, AI 1, and AI 2 must satisfy the following inequalities:

m1 · |AI 1| ≤ |PI| ≤ n1 · |AI 1|

m2 · |AI 2| ≤ |PI| ≤ n2 · |AI 2|.

On the other hand, consider the system T of linear inequalities containing for each atomic role P typed by A1 and A2 the inequalities

m1 · Var(A1) ≤ Var(P) ≤ n1 · Var(A1) m2 · Var(A2) ≤ Var(P) ≤ n2 · Var(A2) (5.1)

where we denote by Var(A) and Var(P) the unknowns, ranging over the non- negative integers, corresponding to the atomic concept A and the atomic role P respectively. It can be shown that, if the only axioms in T are those mentioned above, then certain non-negative integer solutions of T (called acceptable solutions) can be put into correspondence with ﬁnite models of T . More precisely, for each acceptable solution S, one can construct a model of T in which the cardinality of each concept or role X is equal to the value assigned by S to Var(X) [Lenzerini and Nobili, 1990; Calvanese et al., 1994; Calvanese, 1996c]. Moreover, given T , it is possible to verify, in time polynomial in its size, whether it admits an acceptable solution. This property can be exploited to check ﬁnite satisﬁability of an atomic concept A w.r.t. a TBox T as follows:

(i) Construct the system T of inequalities corresponding to T . (ii) Add to T the inequality Var(A) > 0, which enforces that the solutions correspond to models in which the cardinality of the extension of A is positive. (iii) Check whether T admits an acceptable solution.

Observe that for simple TBoxes of the form described above, this method works in polynomial time, since (i) T is of size polynomial in the size of T , and can also be constructed in polynomial time, and (ii) checking the existence of acceptable solutions of T can be done in time polynomial in its size. Notice also that the applicability of the technique heavily relies on conditions P1 and P2, which ensure that from an acceptable solution of  a model of T can be constructed

5.8.2 Finite model reasoning in expressive Description Logics

The method we have presented above is not directly applicable to more complex languages or TBoxes not respecting the particular form above. In order to extend it to more general cases we make use of the following observation: Linear inequalities capture global constraints on the total number of instances of concepts and roles. So we have to represent local constraints expressed by number restrictions by means of global constraints. This can be done only if P1 and the following generalization of P2 hold:

P′ 2: For each atomic role P and each concept expression C appearing in T , the domain of P is either included in the extension of C or disjoint from it. Similarly for the codomain of P.

This condition guarantees that, in a model, all instances of a concept “behave” in the same way, and thus the local constraints represented by number restrictions are indeed correctly captured by the global constraints represented by the system of inequalities. It is possible to enforce conditions P1 and P′ 2 for expressive Description Logics, by ﬁrst transforming the TBox, and then deriving the system of inequalities from the transformed version. We brieﬂy sketch the technique to decide ﬁnite concept sat- isﬁability in ALUNI TBoxes consisting of specializations, i.e., inclusion axioms in which the concept on the left-hand side is atomic. A detailed account of the technique and an analysis of its computational complexity has been presented by Calvanese [1996c]. First of all, it is easy to see that, by introducing at most a linear number of new atomic concepts and TBox axioms, we can transform the TBox into an equivalent one in which the nesting of constructs is eliminated. Speciﬁcally, in such a TBox the concept on the right-hand side of an inclusion axiom is of the form L, L1 ⊔L2, ∀R.L, ⩾n R, or ⩽n R, where L is an atomic or negated atomic concept. For example, given the axiom

A ⊑C1 ⊔C2

where C1 and C2 do not have the form above, we introduce two new atomic concepts AC1 and AC2, and replace the axiom above by the following ones:

A ⊑ AC1 ⊔AC2 AC1 ⊑ C1 AC2 ⊑ C2.

Then, to ensure that conditions P1 and P′ 2 are satisﬁed, we use instead of atomic concepts,setsofatomicconcepts,calledcompoundconcepts14 andinsteadofatomic

14 A i il t h i ll d i d i i th d b Ohlb h d K hl [1999]

roles, so called compound roles. Each compound role is a triple (P, C1, C2) con- sisting of an atomic role P and two compound concepts C1 and C2. Intuitively, the instances of a compound concept C are all those individuals of the domain that are instances of all concepts in C and are not instances of any concept not in C. A compound role (P, C1, C2) is interpreted as the restriction of role P to the pairs whose ﬁrst component is an instance of C1 and whose second component is an instance of C2. Thismeansthattwodifferentcompoundconceptshavenecessarilydisjointexten- sions, and hence that the property corresponding to P1 holds. The same observation holds for two different compound roles (P, C1, C2) and (P, C′ 1, C′ 2) that corre- spond to the same role P. Moreover, for compound roles, the property correspond- ing to property P2 holds by deﬁnition, and, considering that the TBox contains only specializations and that nesting of constructs has been eliminated, P′ 2 also holds. We ﬁrst consider the set T ′ of axioms in the TBox that do not involve number restrictions. Such axioms force certain compound concepts and compound roles to be inconsistent, i.e., have an empty extension in all interpretations that satisfy T ′. For example, the axiom A1 ⊑¬A2 makes all compound concepts that contain both A1 and A2 inconsistent. Similarly, the axiom A1 ⊑∀P.A2 makes all compound roles (P, C1, C2) such that C1 contains A1 and C2 does not contain A2 inconsistent. Checking whether a given compound concept is inconsistent essentially amounts to evaluating a propositional formula in a given propositional model (the one corre- sponding to the compound concept), and hence can be done in time polynomial in the size of the TBox. Similarly, one can check in time polynomial in the size of the TBox whether a given compound role is inconsistent. Observe, however, that since the total number of compound concepts and roles is exponential in the number of atomic concepts in the TBox, doing the check for all compound concepts and roles takes in general exponential time. Once the consistent compound concepts and roles have been determined, we can introduce for each of them an unknown in the system of inequalities (the inconsistent compound concepts and roles are discarded). The axioms in the TBox involving number restrictions are taken into account by encoding them into suitable linear inequalities. Such inequalities are derived in a way similar to inequalities (5.1), except that now each inequality involves one unknown corresponding to a compound concept and a sum of unknowns corresponding to compound roles. Then, to check ﬁnite satisﬁability of an atomic concept A, we can add to the system the inequality



A Var( C) ≥1

which forces the extension of A to be nonempty. Again, if the system admits an acceptable solution, then we can construct from such a solution a ﬁnite model of the TBox in which A is satisﬁed; if no such solution exists, then A is not ﬁnitely satisﬁable. To check ﬁnite satisﬁability of an arbitrary concept C, we can introduce a new concept name A, add to the TBox the axiom A ⊑C, and then check the satisﬁability of A. Indeed, if A is ﬁnitely satisﬁable, then so is C. Conversely, if the original TBox admits a ﬁnite model I in which C has a nonempty extension, then we can simply extend I to A by interpreting A as CI, thus obtaining a ﬁnite model of the TBox plus the additional axiom in which A is satisﬁed. The system of inequalities can be effectively constructed in time exponential in the size of the TBox, and checking for the existence of acceptable solutions is polynomial in the size of the system [Calvanese et al., 1994; Calvanese, 1996a]. Moreover,sinceverifyingconceptsatisﬁabilityisalreadyExpTime-hardforTBoxes consisting of specializations only and expressed in the much simpler language ALU [Calvanese, 1996b], the above method provides a computationally optimal reasoning procedure.

Theorem 5.25 Finite concept satisﬁability in ALUNI TBoxes consisting of spe- cializations only is ExpTime-complete.

The method can be extended to decide ﬁnite concept satisﬁability for a wider class of TBoxes, in which a negated atomic concept and, more generally, an arbi- trary Boolean combination of atomic concepts may appear on the left-hand side of axioms. In particular, this makes it possible to deal also with knowledge bases con- taining deﬁnitions of concepts that are Boolean combinations of atomic concepts, and to reason on such knowledge bases in deterministic exponential time. Since ALUNI is not closed under negation, we cannot immediately reduce logical im- plication to concept satisﬁability. However, the technique presented above can be adapted in speciﬁc cases to decide also ﬁnite logical implication in deterministic exponential time [Calvanese, 1996c]. A further extension of the above method can be used to decide logical im- plication in ALCQI. The technique uses two successive transformations on the TBox, each of which introduces a worst-case exponential blowup, and a ﬁnal poly- nomial encoding into a system of linear inequalities [Calvanese, 1996c; 1996a].

Theorem 5.26 Logical implication w.r.t. ﬁnite models in ALCQI can be decided in worst-case deterministic double exponential time.

For more expressive Description Logics, and in particular for all those Descrip- tion Logics containing the construct for reﬂexive–transitive closure of roles, the decidability of ﬁnite model reasoning is still an open problem Decidability of

ﬁnite model reasoning for C2, i.e., ﬁrst-order logic with two variables and counting quantiﬁers (see also Chapter 4, Section 4.2) was shown recently [Gr¨adel et al., 1997b]. C2 is a logic that is strictly more expressive than ALCQI TBoxes, since it allows one, for example, to impose cardinality restrictions on concepts [Baader et al., 1996] or to use the full negation of a role. However, apart from decidability, no complexity bound is known for ﬁnite model reasoning in C2. Techniques for ﬁnite model reasoning have also been studied in databases. In the relational model, the interaction between inclusion dependencies and functional dependencies causes the loss of the ﬁnite model property, and ﬁnite implication of dependencies under various assumptions has been investigated by Cosmadakis et al. [1990]. A method for ﬁnite model reasoning has been presented by Calvanese and Lenzerini [1994b; 1994a] in the context of a semantic and an object-oriented database model, respectively. The reasoning procedure, which represents a direct generalization of the one discussed above to relations of arbitrary arity, does not exploit reiﬁcation to handle relations (see Section 5.7) but directly encodes the constraints on them into a system of linear inequalities.

5.9 Undecidability results

Several additional DL constructs besides those discussed in the previous sections have been proposed in the literature. In this section we present the most important of these extensions, discussing how they inﬂuence decidability, and what modiﬁca- tions to the reasoning procedures are needed to take them into account. In particular, we discuss Boolean constructs on roles, variants of role-value-maps or role agree- ments, and number restrictions on complex roles. Most of these constructs lead to undecidability of reasoning, if used in an unrestricted way. Roughly speaking, this is mainly due to the fact that the tree model property is lost [Vardi, 1997].

5.9.1 Boolean constructs on complex roles

In those Description Logics that include regular expressions over roles, such as ALCQIreg, since regular languages are closed under intersection and complemen- tation, the intersection of roles and the complement of a role are already expressible, if we consider them applied to the set of role expressions. Here we consider the more common approach in PDLs, namely to regard Boolean operators as applied to the binary relations denoted by complex roles. The logics thus obtained are more expressive than traditional pdl [Harel, 1984] and reasoning is usually harder. We notice that the semantics immediately implies that intersection of roles can be expressed by means of union and complementation

Satisﬁability in pdl augmented with intersection of arbitrary programs is decidable in deterministic double exponential time [Danecki, 1984], and so is satis- ﬁability in ALCreg augmented with intersection of complex roles, even though these logics have neither the tree model nor the ﬁnite model property. On the other hand, satisﬁability in pdl augmented with complementation of programs is undecidable [Harel, 1984], and so is reasoning in ALCreg augmented with complementation of complex roles. Also, dpdl augmented with intersection of complex roles is highly undecidable [Harel, 1985; 1986], and since global functionality of roles (which corresponds to determinism of programs) can be expressed by means of local func- tionality, the undecidability carries over to ALCF reg augmented with intersection of roles. These proofs of undecidability make use of a general technique based on the reduction from the unbounded tiling (or domino) problem [Berger, 1966; Robinson, 1971], which is the problem of checking whether a quadrant of the integer plane can be tiled using a ﬁnite set of tile type – i.e., square tiles with a color on each side – in such a way that adjacent tiles have the same color on the sides that touch.15 We sketch the idea of the proof using the terminology of Description Logics, instead of that of PDLs. The reduction uses two roles right and up which are globally functional (i.e., ⩽1 right, ⩽1 up) and denote pairs of tiles that are adjacent in the x and y directions, respectively. By means of intersection of roles, right and up are constrained to effectively deﬁne a two-dimensional grid. This is achieved by imposing for each point of the grid (i.e., reachable through right and up) that by following right ◦up one reaches a point reached also by following up ◦right:

∀(right ⊔up)∗.∃((right ◦up) ⊓(up ◦right)).

To enforce this condition, the use of intersection of compositions of atomic roles is essential. Reﬂexive–transitive closure (i.e., ∀(right ⊔up)∗.C) is then also exploited to impose the required constraints on all tiles of the grid. Observe that, in the above reduction, one can use TBox axioms instead of reﬂexive–transitive closure to enforce the necessary conditions in every point of the grid. The question arises whether decidability can be preserved if one restricts Boolean operations to basic roles, i.e., atomic roles and their inverse. This is indeed the case if complementation of basic roles is used only to express difference of roles, as demonstrated by the ExpTime decidability of DLR and its extensions, in which intersection and difference of relations are allowed (see Section 5.7).

15 In fact the reduction is from the 1 1-complete – and thus highly undecidable – recurring tiling problem [Harel, 1986] h dditi ll i th t t i til i ﬁit l ft th i

5.9.2 Role-value-maps

Another construct, which stems from frame systems, and which provides an additional useful means to specify structural properties of concepts, is the so called role-value-map [Brachman and Schmolze, 1985], which comes in two forms: An equality role-value-map, denoted R1 = R2, represents the individuals o such that the set of individuals that are connected to o via role R1 equals the set of individu- als connected to o via role R2. The second form of role-value-map is containment role-value-map, denoted R1 ⊆R2, whose semantics is deﬁned analogously, using set inclusion instead of set equality. Using these constructs, one can denote, for example, by means of owns ◦madein ⊆livesin the set of all persons that own only products manufactured in the country they live in. When role-value-maps are added, the logic loses the tree model property, and this construct leads immediately to undecidability of reasoning when applied to role chains (i.e., compositions of atomic roles). For ALCreg, this can be shown by a reduction from the tiling problem in a similar way to that used in [Harel, 1985] for dpdl with intersection of roles. In this case, the concept right ◦up = up ◦right involving role-value-map can be used instead of role intersection to deﬁne the constraints on the grid. The proof is slightly more involved than that for dpdl, since one needs to take into account that the roles right and up are not functional (while in dpdl all programs/roles are functional). However, undecidability holds already for concept subsumption (with respect to an empty TBox) in AL (in fact FL−) augmented with role-value-maps, where the roles involved are compositions of atomic roles [Schmidt-Schauß, 1989] – see Chapter 3 for the details of the proof. As for role intersection, in order to show undecidability, it is necessary to apply role-value-maps to compositions of roles. Indeed, if the application of role-value-maps is restricted to Boolean combinations of basic roles, it can be added to ALCQIreg without inﬂuencing decidability and worst-case complexity of reasoning. This follows directly from the decidability results for the extension with Boolean constructs on atomic and inverse atomic roles (captured by DLR). Indeed, R1 ⊆R2 is equivalent to ∀(R1 ⊓¬R2).⊥, and thus can be expressed using difference of roles. We observe also that universal and existential role agreements introduced in [Hanschke, 1992], which allow one to deﬁne concepts by posing vari- ous types of constraints that relate the sets of ﬁllers of two roles, can be expressed by means of intersection and difference of roles. Thus reasoning in the presence of role agreements is decidable, provided these constructs are applied only to basic roles.

5.9.3 Number restrictions on complex roles

In ALCFIreg, the use of (qualiﬁed) number restrictions is restricted to atomic and inverse atomic roles which guarantees that the logic has the tree model property

This property is lost, together with decidability, if functional restrictions may be imposed on arbitrary roles. The reduction to show undecidability is analogous to the one used for intersection of roles, except that now functionality of a complex role (i.e., ⩽1 (right ◦up) ⊔(up ◦right)) is used instead of role intersection to deﬁne the grid. An example of decidable logic that does not have the tree model property is obtained by allowing the use of role composition (but not transitive closure) inside number restrictions. Let us denote by N(X), where X is a subset of {⊔, ⊓, ◦,−}, unqualiﬁed number restrictions on roles that are obtained by applying the role constructs in X to atomic roles. Let us denote by ALCN(X) the Description Logic obtained by extending ALC (see Chapter 2) with number restrictions in N(X). As shown by Baader and Sattler [1999], concept satisﬁability is decidable for the logic ALCN(◦), even when extended with number restrictions on union and intersection of role chains of the same length. Notice that decidability for ALCN(◦) holds only for reasoning on concept expressions and is lost if one considers reasoning with respect to a TBox (or alternatively adds transitive closure of roles) [Baader and Sattler, 1999]. Reasoning even with respect to the empty TBox is undecidable if one adds to ALCN number restrictions on more complex roles. In particular, this holds for ALCN(⊓, ◦) (if no constraints on the lengths of the role chains are imposed) and for ALCN(⊔, ◦,−) [Baader and Sattler, 1999]. The reductions again exploit the tiling problem, and make use of number restrictions on complex roles to simulate a universal role that is used for imposing local conditions on all points of the grid. Summing up, we can state that the borderline between decidability and unde- cidability of reasoning in the presence of number restrictions on complex roles has been traced quite precisely, although there are still some open problems. E.g., it is not known whether concept satisﬁability in ALCN(⊔, ◦) is decidable (although logical implication is undecidable) [Baader and Sattler, 1999].

6

Extensions to Description Logics

FRANZ BAADER RALF K ¨USTERS FRANK WOLTER

Abstract

This chapter considers, on the one hand, extensions of Description Logics by fea- tures not available in the basic framework, but considered important for using Description Logics as a modeling language. In particular, it addresses the exten- sions concerning: concrete domain constraints; modal, epistemic, and temporal operators; probabilities and fuzzy logic; and defaults. On the other hand, it considers non-standard inference problems for Description Logics, i.e., inference problems that – unlike subsumption or instance checking – are not available in all systems, but have turned out to be useful in applications. In particular, it addresses the non-standard inference problems: least common subsumer and most speciﬁc concept; uniﬁcation and matching of concepts; and rewriting.

6.1 Introduction

Chapter 2 introduces the language ALCN as a prototypical Description Logic, deﬁnes the most important reasoning tasks (like subsumption, instance checking, etc.), and shows how these tasks can be realized with the help of tableau-based algorithms. For many applications, the expressive power of ALCN is not sufﬁcient to express the relevant terminological knowledge of the application domain. Some of the most important extensions of ALCN by concept and role constructs have already been brieﬂy introduced in Chapter 2; these and other extensions have then been treated in more detail in Chapter 5. All these extensions are “classical” in the sense that their semantics can easily be deﬁned within the model-theoretic framework introduced in Chapter 2. Although combinations of these constructs may lead to very expressive Description Logics (the unrestricted combination even to undecidable ones) all the Description Logics obtained this way can only be used

to represent time-independent, objective, and certain knowledge. In addition, they do not allow “built-in data structures” like numerical domains. The “nonclassical” language extensions considered in the ﬁrst part of this chap- ter try to overcome some of these deﬁciencies. The extension by concrete domains allows us to integrate numerical and other domains in a schematic way into De- scription Logics. The extension of Description Logics by modal operators allows the representation of time-dependent and subjective knowledge (e.g., knowledge about knowledge and belief of intelligent agents). Description Logics that can ex- plicitly represent time have also been introduced outside the modal framework. The extension by epistemic operators provides a model-theoretic semantics for rules; it can be used to impose “local” closed world assumptions, and to integrate integrity constraints into Description Logics. In order to represent vague and un- certain knowledge, different approaches based on probabilistic, possibilistic, and fuzzy logics have been proposed. Finally, non-monotonic Description Logics are obtained by the integration of defaults into Description Logics. When building and maintaining large DL knowledge bases, inference services like subsumption and satisﬁability are very helpful, but in general not quite sufﬁ- cient for an adequate support of the knowledge engineer. For this reason, some DL systems (e.g., Classic) provide their users with additional system services, which can formally be reconstructed as new types of inference problems. In the second part of this chapter we will motivate and introduce the most prominent of these “non-standard” inference problems, and try to give an intuition on how they can be solved.

6.2 Language extensions

The extensions introduced in this section are “nonclassical” in the sense that deﬁn- ing their semantics is not obvious and requires an extension of the model-theoretic framework considered until now; for many (but not all) of these extensions, non- classical logics (such as modal and non-monotonic logics) are employed to provide the right framework.

6.2.1 Concrete domains

A drawback that all Description Logics introduced until now share is that all the knowledge must be represented on the abstract logical level. In many applications, one would like to be able to refer to concrete domains and predeﬁned predicates on these domains when deﬁning concepts. An example of such a concrete domain could be the set of nonnegative integers, with predicates such as ≥(greater or equal)

the concept Woman. The ﬁrst idea could be to use the concept description Human ⊓ Female for this purpose. However, a newborn female baby would probably not be called a woman, and neither would a three-year-old toddler. Thus, as an additional property, one could require that a female human being should be old enough (e.g., at least 18) to be called a woman. In order to express this property, one would like to introduce a new (functional) role has-age, and deﬁne Woman by an expression of the form Human ⊓Female ⊓∃has-age.≥18. Here ≥18 stands for the unary predicate {n | n ≥18} of all nonnegative integers greater than or equal to 18. Stating such properties directly with reference to a given numerical domain seems to be easier and more natural than encoding them somehow into abstract concept expressions. In addition, such a direct representation makes it possible to use existing reasoners for the concrete domain. For example, we could have also decided to introduce a new atomic concept AtLeast18 to express the property of being at least 18 years old. However, if for some reason we also need the property of being at least 21 years old, we must make sure that the appropriate subsumption relationship between AtLeast18 and AtLeast21 is asserted as well. While this could still be done by adding appropriate inclusion axioms, it does not appear to be an elegant solution, and it would still not take care of other relationships, e.g., the fact that AtLeast18 ⊓AtMost16 is unsatisﬁable. In contrast, an appropriate reasoner for intervals of nonnegative integers would automatically take care of these relationships. The need for such a language extension was already evident to the designers of early DL systems such as Meson [Edelmann and Owsnicki, 1986; Patel-Schneider et al., 1990], K-Rep [Mays et al., 1988; 1991a], and Classic [Brachman et al., 1991; Borgida and Patel-Schneider, 1994]: in addition to abstract individuals, these systems also allow one to refer to “concrete” individuals such as numbers and strings. Both the Classic and the K-Rep reasoner can deal correctly with intervals, whereas in Meson the user had to supply the adequate relationships between the concrete predicates in a separate hierarchy. All these approaches are, however, ad hoc in the sense that they are restricted to a speciﬁc collection of concrete objects. In contrast, Baader and Hanschke [1991a] propose a scheme for integrating (almost) arbitrary concrete domains into Description Logics. This extension was designed such that

r it still has a formal declarative semantics that is very close to the usual semantics employed for Description Logics; r it is possible to combine the tableau-based algorithms available for Description Logics with existing reasoning algorithms in the concrete domain in order to obtain the appro- priate algorithms for the extension; r it provides a scheme for extending Description Logics by various concrete domains rather

In the following, we will ﬁrst introduce the original proposal by Baader and Hanschke, and then describe two extensions of this proposal [Hanschke, 1992; Haarslev et al., 1999].

6.2.1.1 The family of Description Logics ALC(D)

Before we can deﬁne the members of this family of Description Logics, we must formalize the notion of a concrete domain.

Deﬁnition 6.1 A concrete domain D consists of a set D, the domain of D, and a set pred(D), the predicate names of D. Each predicate name P ∈pred(D) is associated with an arity n, and an n-ary predicate PD ⊆(D)n.

Let us illustrate this deﬁnition by examples of interesting concrete domains. Let us start with some numerical ones:

r The concrete domain N, which we have employed in our introductory example, has the set N of all nonnegative integers as its domain, and pred(N) consists of the binary predicate names <, ≤, ≥, > and the unary predicate names <n, ≤n, ≥n, >n for n ∈N, which are interpreted by predicates on N in the obvious way. r The concrete domain R has the set R of all real numbers as its domain, and the predicates of R are given by formulae that are built by ﬁrst-order means (i.e., by using Boolean con- nectives and quantiﬁers) from equalities and inequalities between integer polynomials in several indeterminates. For example, x + z2 = y is an equality between the polynomials p(x, z) = x + z2 and q(y) = y; and x > y is an inequality between very simple poly- nomials. From these equalities and inequalities one can for instance build the formulae ∃z.(x + z2 = y) and ∃z.(x + z2 = y) ∨(x > y). The ﬁrst formula yields a predicate name of arity 2 (since it has two free variables), and it is easy to see that the associated predicate is {(r, s) | r and s are real numbers and r ≤s}. Consequently, the predicate associated to the second formula is {(r, s) | r and s are real numbers} = R × R. r The concrete domain Z is deﬁned just like R, with the only difference that Z is the set of all integers instead of all real numbers.

In addition to numerical domains, Deﬁnition 6.1 also captures more abstract do- mains:

r A given (ﬁxed) relational database DB can be seen as a concrete domain DB, whose domain is the set of atomic values occurring in DB, and whose predicates are the relations that can be deﬁned over DB using a query language (such as SQL). r One can also consider Allen’s interval calculus [Allen, 1983] as concrete domain IC. Here IC consists of time intervals, and the predicates are built from Allen’s basic interval relations (such as before, after, . . . ) with the help of Boolean connectives. r Instead of time intervals one can also consider spatial regions (e.g., in R × R), and use as predicates Boolean combinations of the basic relations of the Region Connection Calc l s

Although the syntax and semantics of Description Logics extended by concrete domains could be deﬁned with the general notion of a concrete domain introduced in Deﬁnition 6.1, the requirement that the extended language should still have decidable reasoning problems adds some additional restrictions. To be able to compute the negation normal form of concepts in the extended language, we must require that the set of predicate names of the concrete domain is closed under negation, i.e., if P is an n-ary predicate name in pred(D) then there has to exist a predicate name Q in pred(D) such that QD = (D)n \ PD. We will refer to this predicate name by P. In addition, we need a unary predicate name that denotes the predicate D. The domain N from above satisﬁes these two properties since, e.g., <n = ≥n and (≥0)N = N. Letusnowclarifywhatkindofreasoningmechanismsarerequiredintheconcrete domain. Let P1, . . . , Pk be k (not necessarily different) predicate names in pred(D) of arities n1, . . . , nk. We consider the conjunction

k

i=1 Pi(x(i)).

Here x(i) stands for an ni-tuple (x(i) 1 , . . . , x(i) ni ) of variables. It is important to note that neither all variables in one tuple nor those in different tuples are assumed to be distinct. Such a conjunction is said to be satisﬁable iff there exists an assignment of elements of D to the variables such that the conjunction becomes true in D. We will call the problem of deciding satisﬁability of ﬁnite conjunctions of this form the satisﬁability problem for D.

Deﬁnition 6.2 The concrete domain D is called admissible iff (i) the set of its predicate names is closed under negation and contains a name ⊤D for D, and (ii) the satisﬁability problem for D is decidable.

With the exception of Z, all the concrete domains introduced above are admissible. For example, decidability of the satisﬁability problem for R is a consequence of Tarski’s decidability result for real arithmetic [Tarski, 1951; Collins, 1975]. In contrast, the undecidability of the satisﬁability problem for Z is a consequence of the undecidability of Hilbert’s 10th problem [Matiyasevich, 1971; Davis, 1973]. In the following, we will take the language ALC as the (prototypical) starting point of our extension.1 In the following, let D be an arbitrary (but ﬁxed) concrete domain. The interface between ALC and the concrete domain is inspired by the agreement construct between chains of functional roles (see Chapter 2, Subsection 2.4.3). With this construct one can, for example, express the concept

of all women whose father and husband are of the same age by the expression Woman ⊓has-father ◦has-age .= has-husband ◦has-age. However, one cannot express that the husband is even older than the father. This becomes possible if we take the concrete domain N. Then we can simply write

Woman ⊓∃(has-father ◦has-age, has-husband ◦has-age).<.

More generally, our extension, called ALC(D), will allow us to state that a tuple of chains of functional roles satisﬁes a (not necessarily binary) predicate, which is provided by the concrete domain in question. Thus, ALC(D) extends ALC in two respects. First, the set of role names is now assumed to be partitioned into a set of functional roles and a set of ordinary roles. Both types of roles are allowed to occur in value restrictions and in the existential quantiﬁcation construct. In addition, there is a new constructor, called existential predicate restriction, which is deﬁned by adding to the syntax rules for ALC the rule

C, D −→∃(u1, . . . , un).P,

where P is an n-ary predicate of D and u1, . . . , un are chains of functional roles. When considering ALC(D)-ABoxes, one must distinguish between names for ab- stract and for concrete individuals. Concrete predicates P ∈pred(D) give rise to additional ABox assertions of the form P(x1, . . . , xn), where x1, . . . , xn are names for concrete individuals.

Deﬁnition 6.3 An interpretation I for ALC(D) consists of a set I, the abstract domain of the interpretation, and an interpretation function. The abstract domain and the given concrete domain must be disjoint, i.e., D ∩I = ∅. As before, the interpretation function associates with each concept name a subset of I and with each ordinary role name a binary relation on I. The new feature is that the functional roles are now interpreted by partial functions from I into I ∪D. If u = f1 ◦· · · ◦fn is a chain of functional roles, then uI denotes the composition f I 1 ◦· · · ◦f I n of the partial functions f I 1 , . . . , f I n . The semantics of the usual ALC-constructors is deﬁned as before. In particular, this means that complex concept descriptions are always interpreted as subsets of the abstract domain I. The existential predicate restriction is interpreted as follows:

(∃(u1, . . . , un).P)I = {x ∈I | there exist r1, . . . ,rn ∈D such that uI 1(x) = r1, . . . , uI n(x) = rn and (r1, . . . ,rn) ∈PD}.

Above, we have already seen two examples of concepts of ALC(N). The fol- lowing ALC(R)-concepts describe rectangles and squares in R × R:

Rectangle = ∃(x, y, b, h).rectangle-cond, Square = Rectangle ⊓∃(b, h).equal,

where the concrete predicates rectangle-cond and equal are deﬁned as equal(x, y) ⇔x = y and rectangle-cond(x, y, b, h) ⇔b > 0 ∧h > 0. In rectangle-cond, the ﬁrst two arguments are assumed to express the x and y coordi- nates of the lower left corner of the rectangle, while the third and fourth argument express the breadth and height of the rectangle. We leave it to the reader to deﬁne the concept “pairs of rectangles” where the first component is a square that is contained in the second component. A tableau-based algorithm for deciding consistency of ALC(D)-ABoxes for admissible D was introduced in [Baader and Hanschke, 1991b]. The algorithm has an additional rule that treats existential predicate restrictions according to their semantics. The main new feature is that, in addition to the usual “abstract” clashes, there may be concrete ones, i.e., one must test whether the given combination of concrete predicate assertions is non-contradictory. This is the reason why we must require that the satisﬁability problem for D is decidable. As described in [Baader and Hanschke, 1991b], the algorithm is not in PSpace. Using techniques similar to the ones employed for ALC it can be shown, however, that the algorithm can be modiﬁed such that it needs only polynomial space [Lutz, 1999b], provided that the satisﬁability procedure for D is in PSpace. In the presence of acyclic TBoxes, reasoning in ALC(D) may become NExpTime-hard even for rather simple concrete domains with a polynomial satisﬁability problem [Lutz, 2001b]. This technique of combining a tableau-based algorithm for the Description Log- ics with a satisﬁability procedure for the concrete domain can be extended to more expressive Description Logics (e.g., ALCN and ALCN with agreements and disagreements). However, this is not true for arbitrary Description Logics with tableau-based decision procedures. For example, the technique does not work if the tableau-based algorithm requires some sort of blocking (see Chapter 2, Sub- section 2.3.2.4) to ensure termination. Technically, the problem is that concrete predicates can be used to state properties concerning different individuals in the ABox, and that blocking, which is concerned only with the properties of a single individual, cannot take this into account. The main idea underlying an undecid- ability proof for such a logic is that elements of the concrete domain (e.g., R) can encode conﬁgurations of a Turing machine and that one can deﬁne a concrete predicate stating that one conﬁguration is a direct successor of the other. Finally, the Description Logic must provide some means of representing sequences of con- ﬁgurations of arbitrary length which is usually the case for Description Logics

requiring blocking. More concretely, it was shown in [Baader and Hanschke, 1992] (by reduction from Post’s correspondence problem) that satisﬁability of concepts becomes undecidable if transitive closure (of a single functional role) is added to ALC(R). Post’s correspondence problem can also be used to show undecidability of ALC(R) with general inclusion axioms, although one cannot use exactly the same reduction as for transitive closure (see [Haarslev et al., 1998] for a similar reduction). A notable exception to the rule of thumb that concrete domains together with general inclusion axioms lead to undecidability has recently been shown by Lutz [2001a], who combines ALC with the concrete domain of rational numbers with equality and inequality predicates.

6.2.1.2 Predicate restrictions on role chains

The role chains occurring in predicate restrictions of ALC(D) are restricted to chains of functional roles. In [Hanschke, 1992] this restriction was removed. To be more precise, the syntax rules for ALC are extended by the two rules

C, D −→∃(u1, . . . , un).P | ∀(u1, . . . , un).P,

where P is an n-ary predicate of D and u1, . . . , un are chains of (not necessarily functional) roles. In this setting, ordinary roles are also allowed to have ﬁllers in the concrete domain, i.e., both functional and ordinary roles are interpreted as subsets of I × (I ∪D). Of course, functional roles must still be be interpreted as partial functions. The extension of the predicate restrictions is deﬁned as

(∃(u1, . . . , un).P)I = {x ∈I | there exist r1, . . . ,rn ∈D such that (x,r1) ∈uI 1, . . . , (x,rn) ∈uI n and (r1, . . . ,rn) ∈PD},

(∀(u1, . . . , un).P)I = {x ∈I | for all r1, . . . ,rn: (x,r1) ∈uI 1, . . . , (x,rn) ∈uI n implies (r1, . . . ,rn) ∈PD}.

Using the universal predicate restriction one can, for example, deﬁne the concept of parents all of whose children are younger than 4 by the description

Parent ⊓∀has-child ◦has-age. ≤4 .

Hanschke [1992] shows that an extension of the Description Logic we have just in- troduced still has a decidable ABox consistency problem, provided that the concrete domain D is admissible.

6.2.1.3 Predicate restrictions deﬁning roles

In [Haarslev et al., 1998; 1999], ALC(D) was extended in a different direction: predicate restrictions can now also be used to deﬁne new roles. To be more precise, if P is a predicate of D of arity n + m and u u and v v are chains

of functional roles, then

∃(u1, . . . , un)(v1, . . . , vm).P

is a complex role. These complex roles may be used both in value restrictions and in the existential quantiﬁcation construct. The semantics of complex roles is deﬁned as

(∃(u1, . . . , un)(v1, . . . , vm).P)I =

{(x, y) ∈I × I | there exist r1, . . . ,rn, s1, . . . , sm ∈D such that uI 1(x) = r1, . . . , uI n(x) = rn, vI 1 (y) = s1, . . . , vI m(y) = sm and (r1, . . . ,rn, s1, . . . , sm) ∈PD}.

For example, the complex role ∃(has-age)(has-age).> consists of all pairs of individuals having an age such that the ﬁrst is older than the second. Unfortunately, it has turned out that the full logic obtained by this extension has an undecidable satisﬁability problem [Haarslev et al., 1998]. To overcome this problem, Haarslev et al. [1999] deﬁne syntactic restrictions on concepts such that the restricted language (i) is closed under negation, and (ii) has a decidable ABox consistency problem. Consequently, the subsumption and the instance problem are alsodecidable.ThecomplexityofreasoninginthisDescriptionLogicisinvestigated in [Lutz, 2001b]. As in the case of acyclic TBoxes, rather simple concrete domains can already make reasoning NExpTime-hard.

An approach for integrating arithmetic reasoning into Description Logics that considerably differs from the concrete domain approach described above was pro- posed by Ohlbach and Koehler [1999].

6.2.2 Modal extensions

Although the Description Logics discussed so far provide a wide choice of con- structors, usually they are intended to represent only static knowledge and are not able to express various dynamic aspects such as time-dependence, beliefs of dif- ferent agents, obligations, etc. For example, in every standard description language we can deﬁne a concept “good car” as, say, a car with an air-conditioner:

GoodCar ≡Car ⊓∃part.Airconditioner. (6.1)

However, we have no means to represent the subtler knowledge that only John believes (6.1) to be the case, while Mary does not think so:

[John believes](6.1) ∧¬[Mary believes](6.1).

Nor can we express the fact that (6.1) holds now, but in the future the notion of a good car may change (since, for instance, all cars will have air conditioners):

(6 1) ∧⟨eventually⟩ (6 1)

A way to bridge this gap seems quite clear and will be discussed in this and the next section: one can simply combine a Description Logic with a suitable modal language treating belief, temporal, deontic or some other intensional operators. However, there are a number of parameters that determine the design of a modal extension of a given Description Logic. (I) First, modal operators can be applied to different kinds of well-formed ex- pressions of the Description Logic. One may apply them only to conceptual and assertional axioms, thereby forming new axioms of the form

[John believes](GoodCar ≡Car ⊓∃part.Airconditioner),

[Mary believes] ⟨eventually⟩(Rich(JOHN)).

Modal operators may also be applied to concepts in order to form new ones:

[John believes]expensive

i.e., the concept of all objects John believes to be expensive, or

HumanBeing ⊓∃child.[Mary believes] ⟨eventually⟩GoodStudent

i.e., the concept of all human beings with a child that Mary believes will eventually be a good student. By allowing applications of modal operators to both concepts and axioms we obtain expressions of the form

[John believes](GoodCar ≡[Mary believes]GoodCar)

i.e., John believes that a car is good if and only if Mary thinks so. Finally, one can supplement the options above with modal operators applicable to roles. For example, using the temporal operator [always] (in future) and the role loves, we can form the new role [always]loves (which is understood as a relation between objects x and y that holds if and only if x will always love y) to say

(∃[always]loves.Woman)(JOHN)

i.e., John will always love the very same woman (but perhaps not only her), which is not the same as ([always]∃loves.Woman)(JOHN). (II) All these languages are interpreted with the help of the possible worlds se- mantics, in which the accessibility relations between worlds (or points in time, . . . ) treat the modal operators, and the worlds themselves are Description Logic inter- pretations. Thepropertiesofthemodaloperatorsaredeterminedbytheconditionsweimpose on the corresponding accessibility relations. For example, by imposing no condition at all we obtain what is known as the minimal normal modal logic K – although of deﬁnite theoretical interest it does not have the properties required to model

operators like [agent A knows], ⟨eventually⟩, etc. In the temporal case, depending on the application domain we may assume time to be linear and discrete (for example, the usual strict ordering of the natural numbers), or branching, or dense, etc. (see [Gabbay et al., 1994; van Benthem, 1996]). Moreover, we have the possibility to work with intervals instead of points in time (see Subsection 6.2.4). In epistemic logic, transitivity of the accessibility relation for agent A’s knowledge means what is called positive introspection (A knows what A knows), euclideanness corresponds to negative introspection (A knows what A does not know), and reﬂexivity means that everything known by A is true; see Subsection 6.2.3 for a formulation of these principles in terms of Description Logics. For more information and further references consult [Fagin et al., 1995; Meyer and van der Hoek, 1995]. (III) When connecting worlds – that is, ordinary interpretations of the pure description language – by accessibility relations, we are faced with the problem of connecting their objects. Depending on the particular application, we may assume worlds to have arbitrary domains (the varying domain assumption), or we may assume that the domain of a world accessible from a world w contains the domain of w (the expanding domain assumption), or that all the worlds share the same domain (the constant domain assumption); see [van Benthem, 1996] for a discussion in the context of ﬁrst-order temporal logic. Consider, for instance, the following axioms:

¬[agent A knows](Unicorn ≡⊥), ([agent A knows]¬Unicorn) ≡⊤.

The former means that agent A does not know that unicorns do not exist, while according to the latter, for every existing object, A knows that it is not a unicorn. Such a situation can be modeled under the expanding domain assumption, but these two formulas cannot be simultaneously satisﬁed in a model with constant domains. (IV) Finally, one should take into account the difference between global (or rigid) and local (or ﬂexible) symbols. In our context, the former are the symbols which have the same extension in every world in the model under consideration, while the latter are those whose interpretation is not ﬁxed. Again the choice between these depends on the application domain: if the knowledge base is talking about employees of a company then the name John Smith should probably denote the same person no matter what world we consider, while President of the company may refer to different persons in different worlds. For a more detailed discussion consult, e.g., [Fitting, 1993; Kripke, 1980]. To describe the syntax and semantics more precisely we brieﬂy introduce the modal extension Ln ALC of ALC with n unary modal operators ✷1, . . . , ✷n, and their duals ✸ ✸

Deﬁnition 6.4 (Concepts, roles, axioms) Concepts and roles of Ln ALC are deﬁned inductively as follows: all concept names are concepts, and if C, D are concepts, R is a role, and ✸i is a modal operator, then C ⊓D, ¬C, ✸iC, and ∃R.C are concepts.2 All role names are roles, and if R is a role, then ✷i R and ✸i R are roles. Let C and D be concepts, R a role, and a, b object names. Then expressions of the form C ≡D, R(a, b), and C(a) are axioms. If ϕ and ψ are axioms then so are ✸iϕ, ¬ϕ, and ϕ ∧ψ.

We remind the reader that models of a propositional modal language are based on Kripke frames, i.e., structures of the form F = ⟨W, ✁1, . . . , ✁n⟩in which each ✁i is a binary (accessibility) relation on the set of worlds W. What is going on inside the worlds is of no importance in the propositional framework (see, e.g., [Chagrov and Zakharyaschev, 1997] for more information on propositional modal logics). Models of Ln ALC are also constructed on Kripke frames; however, in this case their worlds come equipped with interpretations of ALC.

Deﬁnition 6.5 (model) A model of Ln ALC based on a frame F = ⟨W, ✁1, . . . , ✁n⟩ is a pair M = ⟨F, I⟩in which I is a function associating with each w ∈W an ALC-interpretation

I(w) = ⟨I,w, ·I,w⟩.

M has constant domain iff I(v) = I(w), for all v, w ∈W. M has expanding domains iff I(v) ⊆I(w) whenever v ✁i w, for some i.

Deﬁnition 6.6 For a model M = ⟨F, I⟩and a world w in it, the extensions C I,w

and RI,w, and the satisfaction relation w |= ϕ (ϕ an axiom) are deﬁned inductively. The interesting new steps of the deﬁnition are:

(i) x ∈(✸iC)I,w iff ∃v. v ✄i w and x ∈C I,v; (ii) (x, y) ∈(✸i R)I,w iff ∃v. v ✄i w and (x, y) ∈RI,v; (iii) w |= ✸iϕ iff ∃v. v ✄i w and v |= ϕ.

An axiom ϕ (resp. a concept C) is satisﬁable in a class of models M if there is a model M ∈M and a world w in M such that w |= ϕ (resp. C I,w ̸= ∅).

Given a class of frames K, the satisﬁability problems for axioms and concepts in K are the most important reasoning tasks; others are reducible to them (see [Wolter and Zakharyaschev, 1998; 1999b]). Notice that the satisﬁability problem for concepts is reducible to that for axioms since ¬(C ≡⊥) is satisﬁable iff C is satisﬁable.

2 Note that value restrictions (the modal box operators ✷i) need not explicitly be included here since they can be d i ti d i t ti l t i ti (th d l di d t ✸)

Also, the satisﬁability problem for models with expanding or varying domain is reducible to that for models with constant domain (see [Wolter and Zakharyaschev, 1998]). We are now going to survey brieﬂy the state of the art in the ﬁeld. We will restrict ourselves ﬁrst to modal Description Logics which are not temporal logics. The latter will be considered in Subsection 6.2.4. Chronologically, the ﬁrst investigations of modal Description Logics are [Laux, 1994; Gr¨aber et al., 1995; Baader and Laux, 1995; Baader and Ohlbach, 1993; 1995]. The papers [Laux, 1994; Gr¨aber et al., 1995] construct multi-agent epistemic Description Logics in which the belief operators apply only to axioms; the accessibility relations are transitive, serial, and euclidean. The decidability of the satisﬁability problem for axioms follows immediately from the decidability of both the propositional fragment of the logic and ALC, because in languages without modalized concepts and roles there is no interaction between the modal operators and role quantiﬁcation (see [Finger and Gabbay, 1992]). Baader and Laux [1995] introduce a Description Logic in which modal operators can be applied to both axioms and concepts (but not to roles); it is interpreted in models with arbitrary accessibility relations under the expanding domain assumption. The decidability of the satisﬁability problem for axioms is proved by constructing a complete tableau calculus. This tableau calculus was modiﬁed and extended for checking satisﬁability in models with constant domain in [Lutz et al., 2002]. It decides satisﬁability in constant domain models in NExpTime, which matches the lower bound established in [Mosurovic and Zakharyaschev, 1999] (see also [Gabbay et al., 2002]). The papers [Wolter and Zakharyaschev, 1998; 1999a; 1999c; 1999b; Wolter, 2000; Mosurovic and Zakharyaschev, 1999] investigate the decision problem for various families of modal Description Logics in detail. For example, in [Wolter and Zakharyaschev,1999c;1999b]itisshownthatthesatisﬁabilityproblemforarbitrary axioms (possibly containing modalized roles) is decidable in the class of all frames and in the class of polymodal S5-frames – frames in which all accessibility relations are equivalence relations – based on constant, expanding, and varying domains. It becomes undecidable, however, if common-knowledge epistemic operators (in the sense of [Fagin et al., 1995]) are added to the language or if the class of frames consists of the ﬂow of time ⟨N, <⟩. In [Wolter and Zakharyaschev, 1999a; 1998] it is shown that for expressive modal languages – like logics with common knowledge operators or Propositional Dynamic Logics – the satisﬁability problem for axioms becomesdecidablewhenmodalizedrolesarenotincluded.Wolter[2000]showsthat the satisﬁability problem for concepts interpreted in frames with global (i.e., world- independent) roles is decidable for expressive modal logics based on ALC while the satisﬁability problem for axioms is undecidable for them. However, even the complexity of the satisﬁability problem for concepts becomes non elementary for

these logics [Gabbay et al., 2002]. In fact, for various decidable modal Description Logics only computationally non-elementary decision procedures are known and the precise complexity has not yet been determined (consult [Gabbay et al., 2002] for further results). The papers [Baader and Ohlbach, 1993; 1995] introduce a multi-dimensional description language that is even more expressive than Ln ALC (but without object names). Roughly, in this approach each dimension (object, time, belief, etc.) is representedbyaset Di (ofobjects,momentsoftime,possibleworlds,etc.),concepts are interpreted as subsets of the cartesian product n i=1 Di, and roles of dimension i as binary relations between n-tuples that may differ only in the ith coordinate. One can quantify over both roles and concepts, in any dimension. Thus, in contrast to Ln ALC arbitrarily many dimensions are considered and no dimension is labeled as the “modal” or “ALC”-one. This language has turned out to be extremely expressive. The satisﬁability problem for the full language is known to be undecidable and even for natural fragments no sound and complete reasoning procedures have appeared. Baader and Ohlbach [1995] provide only a sound satisﬁability-checking algorithm for such a fragment.

6.2.3 Epistemic operators

The systems Classic and Loom make it possible for their users to include proce- dural rules into knowledge bases (see also Chapter 2, Subsection 2.2.5). Such rules take the form

C ⇒D,

where C and D are concepts. The meaning of a procedural rule is different from the meaning of an inclusion axiom: while C ⊑D represents conceptual knowledge and says that – no matter what is known about individuals – the concept D subsumes C, the rule C ⇒D represents the incidental fact that “if an individual is known to be an instance of C, then we can conclude that it is an instance of D”. Consider the following example: suppose a knowledge base  consists of

GreatLogician ⊑Professor, ¬Professor(a).

Obviously we can derive ¬GreatLogician(a) from . In this representation we assume a conceptual relation between the terms ‘professor’ and ‘great logician’. More appropriate, however, seems to be the weaker claim that people who are known to be great logicians are professors: let ′ be the knowledge base which results from  when GreatLogician ⊑Professor is replaced with

GreatLogician ⇒Professor

The assertion ¬GreatLogician(a) turns out not to be derivable from ′. The pro- cedural explanation for this phenomenon is this: in the knowledge base ′ we do not ﬁnd an individual belonging to the concept GreatLogician. Therefore the rule GreatLogician ⇒Professor does not “ﬁre” and nothing new about the world is derivable by using it. However, Description Logic is aiming at an extensional semantics for frame-based systems, hence it would be desirable to have a precise model-theoretic explanation of the behavior of procedural rules as well. It turns out that adding an epistemic operator together with a possible worlds se- mantics interpreting it provides us with the required models. Integrating the operator K – ‘the knowledge base knows that’ – into ALC will allow us to rephrase the rule GreatLogician ⇒Professor by the inclusion axiom KGreatLogician ⊑Professor, which says that all objects that are known to be great logicians are professors. Ac- tually, it will turn out that extensions of Description Logics by means of epistemic operators are useful in other contexts as well. We postpone their discussion until we have introduced some technical prerequisites. We will follow [Donini et al., 1992b; 1998a], where the extension of ALC by epistemic operators was introduced and investigated. Formulated in terms of Subsection 6.2.2, we consider the language L1 ALC in which the modal operator ✷1 (now denoted by K) can be applied to concepts and roles but not to axioms. Following [Donini et al., 1998a] we call this language ALCK. The following principles are assumed to govern the epistemic operator (we formulate them here for K applied to concepts; the formulation for roles is similar):

r KC ⊑C (only true facts are known: if an object is known to be an instance of C, then it is an instance of C); r KC ⊑KKC (positive introspection: if it is known that an object is an instance of C, then this is known); r ¬KC ⊑K¬KC (negative introspection: if it is not known whether an object is an instance of C, then this is known).

These principles are valid in all models based on a Kripke frame F = ⟨W, ✁⟩iff F is an S5-frame, or, equivalently, if ✁is the universal relation on W, i.e., ✁= W × W. So, we consider frames of the form ⟨W, W × W⟩only. We assume also that:

r it is known which object an object name denotes (so, object names are assumed to be global (or rigid) designators), r the set of existing objects  is known and countably inﬁnite (so, we adopt the constant domain assumption).

These assumptions together allow us to simplify the possible worlds semantics considerably: we can identify the set of worlds W with a set of interpretations M

(all having the same countably inﬁnite domain  and the same interpretation of the object names) and the accessibility relation is implicitly given as the universal relation on M. Hence, we call any set of interpretations M satisfying these con- straints a model (for ALCK) and can deﬁne the extensions CI,M and RI,M of a concept C and a role R in an interpretation I in M as follows:

AI,M = AI for atomic concepts A PI,M = PI for atomic roles P (¬C)I,M =  \ CI,M

(C1 ⊓C2)I,M = CI,M 1 ∩CI,M 2 (∃R.C)I,M = {a ∈ | ∃b. (a, b) ∈RI,M ∧b ∈CI,M} (KC)I,M = 

J ∈M CJ ,M ( = {a ∈ | ∀J ∈M. a ∈CJ ,M})

(KR)I,M = 

J ∈M RJ ,M ( = {(a, b) ∈ | ∀J ∈M. (a, b) ∈RJ ,M}).

So, KC comprises the set of all objects that are instances of C in every world regarded as possible. An ALCK-knowledge base  consists of a set of inclusion axioms and ABox assertions whose concepts and roles are in ALCK. A model M satisﬁes  (is a -model) iff all inclusion and membership assertions of  are true in every I ∈M. So far, we have introduced a rather simple version of the epistemic extensions of ALC discussed in Subsection 6.2.2. In the present subsection, however, we are not interested in the satisﬁability of epistemic knowledge bases, but in a relation |= between knowledge bases and assertions such that  |= ϕ iff a knowledge base knows ϕ under the assumption that “all the knowledge base knows is ”. For example, if  is empty (the knowledge base knows nothing), then both ¬KC(a) and ¬K¬C(a)shouldbederivable,sincetheknowledgebasedoesnotknowwhethera is an instance of C or not. On the semantic level this means that we are not interested in arbitrary models satisfying  but only in those -models that refute as many ALC- assertions as possible. In other words, we consider -models only with as many worlds as possible (corresponding to the intuition that more worlds are regarded as possible if less is known). For example, if  is empty, then the intended models comprise all interpretations (with a ﬁxed domain and interpretation of the object names), since all interpretations are regarded as possible by an empty knowledge base. Here are the precise deﬁnitions:

Deﬁnition 6.7 An epistemic model for  is a maximal non-empty set of interpre- tations M satisfying . The knowledge base  logically implies an assertion ϕ,

Consequently, |= is a non-monotonic consequence relation: although ∅|= (¬KC ∧¬K¬C)(a), we have C(a) |= KC(a). On the propositional level, this type of reasoning is known as ground non-monotonic S5 (see [Donini et al., 1995; 1997c; Nardi and Rosati, 1995]). Reasoning with arbitrary ALCK-knowledge bases has not been investigated. In fact, all applications considered in the literature require only very small fragments of ALCK. In what follows, we shall brieﬂy introduce two such fragments and some of their applications.

6.2.3.1 ALCK as a query language

We ﬁrst conﬁne ourselves to knowledge bases that are ordinary ALC-ABoxes. Hence, the epistemic operator K can be used only in queries. Recall that concept languages can be applied as query languages in a straightforward manner: the an- swer set of a query consisting of a concept C to a knowledge base  comprises the set of individuals a with  |= C(a). Queries with epistemic operators enable us to extract the knowledge which the knowledge base has about its own knowl- edge. Consider, for example, the knowledge base  = {∃friend.Male(SUSAN)}, which contains incomplete information about Susan. Applications of K to different concepts and roles in ∃friend.Male enable us to form a variety of different queries:

r ∃friend.Male; clearly, the answer to this query is {SUSAN}. r ∃friend.KMale; the answer set is empty, since no known male is a friend of Susan. r ∃Kfriend.Male; the answer set is empty since we do not ﬁnd a male individual who is known to be a friend of Susan. r K∃friend.Male; the answer set is {SUSAN} since the knowledge base knows that Susan has a friend who is male.

Observe that, for ′ = ∪{friend(SUSAN, BOB), Male(BOB)}, the answer set would consist of SUSAN in all four cases. We refer the reader to [Donini et al., 1992b; 1998a] for more examples. Epistemic queries can also be used to formulate integrity constraints. Recall that integrity constraints can be viewed as epistemic sentences that state what a knowledge base must know about the world [Reiter, 1990]. For example, suppose that we want to rule out those knowledge bases that are uncertain about whether a given course is a course for undergraduates or graduates. This can be expressed using the query

¬KCourse ⊔(KUndergraduate ⊔KGraduate). (6.2)

A knowledge base satisﬁes the integrity constraint iff it logically implies the as- sertion (6.2)(a), for every object name a appearing in it. Observe, by the way, that the query ¬Course ⊔(Undergraduate ⊔Graduate) has a different meaning:

(Undergraduate ⊔Graduate))(a). We refer the reader to [Levesque, 1984; Lifs- chitz, 1991; Reiter, 1990] for a discussion of the use of epistemic queries in general. What is the computational complexity of querying ALC-ABoxes by means of ALCK-concepts? The following result is proved in [Donini et al., 1992b; 1998a]:

Theorem 6.8 There is an algorithm for deciding, given an ALC-ABox , an object name a, and an ALCK-concept C, whether |= C(a). More precisely, the problem |= C(a) is PSpace-complete (w.r.t. the size of C and ).

Recall that querying ALC-ABoxes with ALC-concepts is PSpace-complete as well [Hollunder, 1996]. Thus, the additional epistemic operators in queries do not cause any increase of the computational complexity.

6.2.3.2 Semantics for procedural rules

To capture the meaning of procedural rules as discussed above (and in Chapter 2, Section 2.2.5), we must admit assertions of the form KC ⊑D in the knowledge base. A rule ABox consists of an ALC-ABox and a set of sentences of the form

KC ⊑D,

where C, D are ALC-concepts and C is not equivalent to ⊤(the reason for this technical condition will be discussed below). Fortunately, the additional inclusion axioms again do not lead to any increase of the complexity [Donini et al., 1992b; 1998a].

Theorem 6.9 There is an algorithm for deciding, given a rule ALC-ABox , an object name a, and an ALCK-concept C, whether |= C(a). More precisely, the problem |= C(a) is PSpace-complete (w.r.t. the size of C and ).

Observe that this result does not extend to the language with inclusion axioms of the form KC ⊑D, where C is equivalent to ⊤. In this case KC would be equivalent to ⊤as well, and so KC ⊑D would be equivalent to D ≡⊤. However, for knowledge bases with axioms of this type instance checking is known to be ExpTime-complete [Schild, 1994]. Notice that in applications a rule of the form ⊤⇒C does not make sense.

6.2.3.3 An extension of ALCK

The non-monotonic logic MKNF is an expressive extension of ground non- monotonic S5, which can simulate in a natural manner Default Logic, Autoepis- temic Logic, and Circumscription (see [Lifschitz, 1994]). This is achieved by adding to classical logic not only the operator K (of ground non monotonic S5)

but also a second epistemic operator A, which is interpreted in terms of autoepis- temic assumption. The papers [Donini et al., 1997b; Rosati, 1998] study the corre- sponding bimodal extension of ALC by means of K and A, called ALCB in what follows. We ﬁrst consider the two operators K and A separately: the consequence relation |= for assertions containing K only is still the one introduced above. On the other side, for assertions containing A (‘it is assumed that’) only we are interested in a consequence relation |=AE such that3  |=AE ϕ iff ϕ belongs to every stable expansion of , i.e., iff ϕ belongs to every reasonable theory4 about the world which a rational agent who assumes only the assertions in  can have. In particular, it is assumed that agents are capable of introspection. Consider, for example, an agent assuming precisely  = {AC ≡⊤} (‘the set of all objects I assume to be in C comprises all existing objects’). We still assume that agents know which objects exist (the constant domain assumption). Hence  can be rephrased as ‘I assume that all objects belong to C’. Now, according to the autoepistemic approach such an agent cannot have a coherent theory about the world, for then she would have to assume as well that C ≡⊤from the very beginning. From the “possible worlds” viewpoint the relation |=AE can be captured as fol- lows. Firstly, the extension of ALC by A is interpreted in pairs (I, M) in precisely the same manner as ALCK. However, now we allow that the actual world I is not in M – corresponding to the idea that assumptions (in contrast to known assertions) are not always true. Thus we may have (AC)I,M = ⊤but CI,M ̸= ⊤, which is not possible for K. The intended models are called AE-models in what follows.

Deﬁnition 6.10 An AE-model for a set of assertions  is a set of interpretations M that satisﬁes  and such that, for every interpretation I ̸∈M,  is refuted in (I, M). Now put  |=AE ϕ iff ϕ is satisﬁed in all AE-models for .

So, we do not maximize the set of possible worlds, but we exclude the case that  is true in an actual world that is not regarded as possible (i.e., is not a member of M). The consequence relation |=AE is also non-monotonic since ∅|=AE ¬AC(a) but C(a) |= AC(a). Observe that |= and |=AE are different: while AC ≡⊤has no AE-models, KC ≡⊤has the epistemic model consisting of all interpretations in which C ≡⊤. How should one interpret the combined language ALCB and deﬁne a conse- quence relation? Following Lifschitz [1994], the intended models (called ALCB- models) are deﬁned as follows.

3 AE indicates that autoepistemic propositional logic in the sense of [Moore, 1985] is extended here to ALC. 4 In terms of propositional logic a theory T is called reasonable iff the following conditions hold: (0) T is closed d l i l i (1) if P T th AP T (2) if P ̸ T th AP T

Deﬁnition 6.11 The ALCB-models for a set of ALCB-assertions  are those models M satisfying  and the following maximality condition: if a non-empty set of new worlds N is added to M, K is interpreted in the model M ∪N, and A is interpreted in the old model M, then  is refuted in some interpretation from N. Now  logically implies ϕ, in symbols  |= ϕ, iff ϕ is satisﬁed in every ALCB-model satisfying .

Thus, roughly speaking, we still maximize the set of worlds, but now we require that any larger set of possible worlds contains a world at which  is refuted under the interpretation of A by means of the original set of possible worlds. But this corresponds, for the operator A, to the deﬁnition of AE-models. Clearly, the new consequence relation is a conservative extension of the one deﬁned for ALCK above (and of |=AE as well). Hence using the same symbol for both does not cause any ambiguity. The new logic is considerably more expressive than ALCK. Donini et al. [1997b] show that Default Logic can be embedded into ALCB more naturally than into ALCK. They also consider the formalization of integrity constraints in knowledge bases, which cannot be expressed in ALCK, and they discuss how role and concept closure can be formalized in ALCB. Here we conﬁne ourselves to a brief discussion of the formalization of integrity constraints in ALCB. Above we have seen that the query (6.2) can be used to express the constraint that every course known to the knowledge base should be known to be for undergraduates or graduates. Sometimes it is more useful not to formalize integrity constraints as queries, but as part of the knowledge base (see [Donini et al., 1997b]). However, the addition of constraints should not change the content of the knowledge base, but just force the knowledge base to be inconsistent iff the constraint is violated. How can this be achieved in ALCK? The naive idea is to add the assertion (6.2) ≡⊤to the knowledge base in order to express the constraint. Unfortunately, this does not work: consider the knowledge base  consisting of Course(a), which does not satisfy the integrity con- straint.However,theknowledgebaseobtainedfrombyadding(6.2) ≡⊤doesnot tell us that the constraint is violated in  since the extended knowledge base is still consistent: the set M consisting of all interpretations J (with a ﬁxed domain and interpretation of a) satisfying aJ ∈CourseJ ∩GraduateJ is an epistemic model for the extended knowledge base. In fact, there is no way to formulate the required constraint within ALCK. On the other hand, by adding the ALCB-assertion

KCourse ⊑AGraduate ⊔AUndergraduate

to , we obtain a knowledge base without ALCB-models, as required. Note, for

example, that the model M introduced above is not an ALCB-model for this knowledge base because any set of worlds N = {I} with I ̸∈M and aI ∈CourseI

refutes the maximality condition. Donini et al. [1997b] present a number of decidability results for reasoning with ALCB knowledge bases.

6.2.4 Temporal extensions

Temporal extensions are a special form of modal extensions of Description Logics. However, because of the intended interpretation in ﬂows of time they have a speciﬁc ﬂavor,whichisslightlydifferentfromgeneralmodallogic.Chronologically,theﬁrst example of a “modalized” Description Logic was the temporal Description Logic of Schmiedel [1990]. The papers [Bettini, 1997; Artale and Franconi, 1994; 1998] introduce and investigate variants of Schmiedel’s formalism. The papers mentioned so far employ an interval-based approach to the semantics of temporal operators. Point-based temporal Description Logics have been introduced by Schild [1993] and further investigated by Wolter and Zakharyaschev [1999e]. For simplicity, let us ﬁrst consider propositional temporal logic and then see how it can be extended to temporal Description Logic. In what follows we assume that a ﬂow of time T = ⟨T, <⟩consists of a set of points in time T and a precedence relation < between points in time which is assumed to be a strict linear order. This corresponds to the intuition that, for any two moments t1, t2 ∈T , either t1 precedes t2, t2 precedes t1, or t1 equals t2. How should one deﬁne a satisﬁability relation |= between entities in a ﬂow of time and formulae? There exist (at least) two different ways to select the entities at which formulas are evaluated: points in time and intervals. While in the ﬁrst case we are considering a relation t |= ϕ between time-points t and formulas ϕ, in the second case we have a relation [u, v] |= ϕ between intervals [u, v] = {z ∈T | u ≤z ≤v}, where u ≤v, in T and formulae ϕ. Denote by T∗the set of all intervals in T. Both point- and interval-based temporal logics are special instances of modal logics: in the former the worlds of Kripke frames are interpreted as time-points while in the latter they are interpreted as intervals. Both point- and interval-based temporal models are easily extended to temporal ALC-models:

Deﬁnition 6.12 A point-based temporal ALC-model M = (T, I) consists of a ﬂow of time T and a function I which associates with every t ∈T an interpretation

I(t) = ⟨I,t, ·I,t⟩.

An interval-based temporal ALC-model M = ⟨T, I⟩consists of a ﬂow of time T

and a function I which associates with every interval i ∈T∗an interpretation

I(i) = ⟨I,i, ·I,i⟩.

We can now evaluate ALC-concepts and axioms in point- and interval-based temporal models. For example,

r (M, t) |= Alive(a) iff aI,t ∈AliveI,t, i.e., a is alive at moment t, r (M, i) |= Sleep(a) iff aI,i ∈SleepI,i, i.e., a is sleeping in the interval i.

We now add temporal operators and quantiﬁers to ALC, which enable us to relate different moments and intervals to each other. For the point-based approach we have discussed appropriate operators already: we can form the language L1 ALC and interpret the operator ✷= ✷1 as ‘always in the future’. Thus, t |= ✷(C ≡D) iff t′ |= C ≡D for all t′ > t, (always in the future of t, C and D are interpreted as the same set), and x ∈(✸C)I,t iff there exists t′ > t such that x ∈C I,t′ (eventually x is an instance of C). Often, however, more expressive temporal operators are required. The operator U (until), for example, is a binary temporal operator with the following truth-conditions, for all concepts C, D and axioms ϕ, ψ:

(i) x ∈(CU D)I,t iff there exists t′ > t such that x ∈DI,t′ and, for all t′′ with t < t′′ < t′, x ∈C I,t′′, (ii) t |= ϕUψ iff there exists t′ > t such that t′ |= ψ and, for all t′′ with t < t′′ < t′, t′′ |= ϕ.

In this language we can deﬁne a mortal as, say, a living being that is alive until it dies:

Mortal ≡LivingBeing ⊓(LivingBeing U ✷¬LivingBeing).

This language, interpreted in the ﬂow of time ⟨N, <⟩, was ﬁrst considered by Schild [1993], who showed that the satisﬁability problem for concepts (without modalized or global roles) is decidable. Wolter [2000] proves the decidability for concepts with global roles (but without modalized roles). However, the complexity of the decision problem for this language is non-elementary [Gabbay et al., 2002]. Wolter and Zakharyaschev [1999e] prove that even for axioms the satisﬁability problem is decidable, provided that they do not contain modalized or global roles. Tableau calculi (running in double-exponential time) for the case of expanding and constant domains were developed in [Sturm and Wolter, 2002; Lutz et al., 2001b]. The satisﬁability problem for axioms in the full language with the ﬂow of time ⟨N, <⟩is undecidable. For the interval-based approach we ﬁnd both languages that extend ALC by means of temporal operators which are interpreted by accessibility relations

between intervals [Bettini, 1997] and languages that allow explicit quantiﬁcation over intervals [Schmiedel, 1990; Artale and Franconi, 1994; 1998]. We start the discussion with the temporal operators approach. Bettini [1997] extends the propositional interval-based temporal logic of [Halpern and Shoham, 1991] to ALC (and weaker Description Logics). Thus, given a concept C, we can now form new concepts like ⟨starts⟩C and ⟨ﬁnishes⟩C. They are interpreted in interval-based models ⟨T, I⟩as follows:

r x ∈(⟨starts⟩C)I,[u,v] iff ∃t ∈T. u ≤t < v ∧x ∈C I,[u,t]

(x is an instance of ⟨starts⟩C in the interval [u, v] iff x is an instance of C in some interval starting [u, v]), r x ∈(⟨ﬁnishes⟩C)I,[u,v] iff ∃t ∈T. u < t ≤v ∧x ∈C I,[t,v].

In other words, the modal operators ⟨starts⟩and ⟨ﬁnishes⟩are interpreted in the standard “possible worlds manner” by means of the accessibility relations ‘starts’ and ‘ﬁnishes’, respectively, where (i, j) ∈starts iff j starts i and (i, j) ∈ﬁnishes if j ﬁnishes i. By adding the converse operators of ⟨starts⟩and ⟨ﬁnishes⟩to the language, we obtain a language that can express all the thirteen Allen relations between intervals [Allen, 1983]. Here is a deﬁnition of Mortal in this language:

Mortal ≡LivingBeing ⊓⟨after⟩¬LivingBeing.

Unfortunately, for the full language based on ALC the satisﬁability problem for concepts is undecidable in all interesting ﬂows of time. This follows from the fact that propositional interval-based temporal logic is undecidable already in ⟨R, <⟩, ⟨Q, <⟩, ⟨N, <⟩, etc. (see [Halpern and Shoham, 1991]). However, there are numerous open decision problems when Description Logics weaker than ALC and different notions of intervals are considered (see [Bettini, 1997; Artale and Franconi, 2000; 2001]). Now, let us consider interval-based temporal extensions of Description Logics that allow explicit quantiﬁcation over intervals. Schmiedel [1990] develops an ex- pressive formalism5 in which we have two quantiﬁers ✷(i) (‘for all intervals i’) and ✸(i) (‘there exists an interval i’), where i is a variable ranging over intervals. The language does not contain negation so that the quantiﬁers are not mutually deﬁnable. The quantiﬁers are relativized (alias bounded or guarded) by so-called time nets, which can, for example, be some relations like starts or ﬁnishes between intervals (metric and granularity constraints are admitted as well). An operator @ speciﬁes the interval at which a concept applies to an object and ♯denotes a refer- ence interval. The following concept can be regarded as a deﬁnition of the concept Mortal in Schmiedel’s language:

LivingBeing ⊓(✸(i)(after i ♯)(¬LivingBeing @ i)).

5 H d i h t f ll th t ti f [A t l d F i 1998]

Here (after i ♯) is the time net which relativizes the quantiﬁer ✸(i) by means of the constraint expressing that i must be after the reference interval denoted by ♯. According to this deﬁnition, an object x is an instance of Mortal at the reference interval ♯iff x is living at ♯and there exists an interval i that is after ♯, and at which x is not living. Schmiedel [1990] does not address computational problems for his language. However, it is not difﬁcult to see that, in the presence of negation, this language is more expressive than that of Bettini [1997] considered above – and thus subsump- tion is undecidable for all interesting ﬂows of time. The decision problem for the language without negation appears to be open. A brief remark concerning the relation between interval-based temporal logic with and without explicit quantiﬁcation over intervals is in order. Of course, ex- plicit quantiﬁcation provides more expressive power. Using the temporal oper- ators introduced above, it is not possible to represent relations between more than two intervals because referring to a ﬁxed reference interval is impossible. On the other hand, variable-free languages are much closer in spirit to pure Description Logics and therefore seem to be more natural candidates for temporal- izations of Description Logics; we refer the reader to [Artale and Franconi, 2000; 2001] for a detailed discussion. The papers [Artale and Franconi, 1994; 1998] present a number of languages weaker than Schmiedel’s with a decidable subsumption problem. Among others, they deﬁne a temporal extension of a Description Logic extending ALC with functional roles. They show decidability of concept subsumption and PSpace- completeness of satisﬁability w.r.t. an empty KB in an unbounded and dense ﬂow of time. The main reason for the decidability is that the language does not admit universal quantiﬁcation over intervals and that the constructors of the underlying Description Logic cannot be applied to the temporalized part of the language. In particular, the negation of the underlying Description Logic cannot be used to de- ﬁne the universal quantiﬁer by means of the existential one. The authors show by means of a number of examples that their formalism still has enough expressive power to represent non-trivial actions and plans. An interesting feature of the subsumption algorithm presented by Artale and Franconi [1998] is that it consists of two parts: ﬁrstly, a normalization procedure is employed to reduce the subsumption problem for the temporalized Description Logic to that problem for the pure Description Logic, which can then be solved with known algorithms [Hollunder and Nutt, 1990]. For a more detailed survey of the state of art in temporal Description Logic we refer the reader to [Artale and Franconi, 2000; 2001], where one can also ﬁnd an introduction to the work of Weida and Litman [1992], who propose a loose hybrid

integration between Description Logics and constraint networks with the aim of reasoning about plans.

6.2.5 Representing uncertain and vague knowledge

Description Logics whose semantics is based on classical ﬁrst-order logic cannot express vague or uncertain knowledge. To overcome this deﬁciency, approaches for integrating probabilistic logic and fuzzy logic into Description Logics have been proposed. Although both types of approaches assign numerical values to entries in the knowledge base, they are quite different, not only from a technical point of view, but also w.r.t. the basic phenomena they are trying to model. We talk about uncertainty if we deal with propositions that are either true or false, but due to a lack of information we do not know for certain which is the case. This gives rise to statements about the probability with which a proposition is assumed to be true. In contrast, vagueness means that the propositions themselves are only true to a certain degree. This vagueness is not caused by incomplete knowledge; it is due to the fact that fuzzy notions, i.e., notions without crisp boundaries (e.g., tall person) are modeled. In the following, we will restrict our attention to the probabilistic extensions of Description Logics introduced in [Heinsohn, 1994; Jaeger, 1994; Koller et al., 1997; Yelland, 2000] and the fuzzy extensions of Description Logics introduced in [Yen, 1991; Tresp and Molitor, 1998; Straccia, 1998; 2001]. The possibilistic extension by Hollunder [1994b] can be viewed as lying between these two approaches: possi- bilistic logic is mainly used to model uncertainty, but its formal semantics is deﬁned in terms of fuzzy sets of interpretations.

6.2.5.1 Probabilistic extensions

Let us ﬁrst concentrate on how to extend the terminological (TBox) formalism. In classical Description Logics, one has very restricted means of expressing (and test- ing for) relationships between concepts. Given two concepts C and D, subsumption tells us whether C is contained in D, and the satisﬁability test (applied to C ⊓D) tells us whether C and D are disjoint. Relationships that are in between (e.g., 90% of all Cs are Ds) can neither be expressed nor be derived. This deﬁciency is overcome in [Heinsohn, 1994; Jaeger, 1994] by allowing prob- abilistic terminological axioms of the form6

P(C|D) = p,

6 Actually, Heinsohn uses a different notation and allows more expressive axioms stating that P(C|D) belongs to an interval [pl, pu], where 0 ≤pl ≤pu ≤1.

where C, D are concept descriptions and 0 < p < 1 is a real number. Such an axiom states that the conditional probability for an object known to be in D to belong to C is p. A given ﬁnite interpretation I satisﬁes P(C|D) = p iff

|(C ⊓D)I|

|DI| = p.

More generally, the formal semantics of the extended language is deﬁned in terms of probability measures on the set of all concept descriptions (modulo equiv- alence). Given a knowledge base P consisting of probabilistic terminological axioms, the main inference task is then to derive optimal bounds for additional conditional probabilities. Intuitively,

P |= P(C|D) ∈[p, q]

iff in all probability measures satisfying P the conditional probability P(C|D) be- longs to the interval [p, q]. Given P, C, D, one is interested in ﬁnding the maximal p and minimal q such that P |= P(C|D) ∈[p, q] is true. Heinsohn [1994] introduces local inference rules that can be used to derive bounds for conditional probabilities, but these rules are not complete, that is, in general they are not sufﬁcient to derive the optimal bounds. Jaeger [1994] only describes a naive method for computing optimal bounds. A more sophisticated version of that method reduces the inference problem to a linear optimization problem. In the following, we will sketch the main idea underlying this reduction. Assume that C1, . . . , Cm are the concept descriptions occurring in P and P(C|D), and consider all conjunctions D1 ⊓· · · ⊓Dm, where Di is either Ci or ¬Ci. Let A be the set of those conjunctions that are satisﬁable. Given a probability measure on all concept descriptions, the value of this measure on C1, . . . , Cm is uniquely determined by the value on A. To be more precise, its value for Ci can be obtained as the sum of the values for those elements of A that are subsumed by Ci (i.e., the ones where Ci occurs positively). The idea is to introduce a numeri- cal variable xt (ranging over the real interval (0, 1)) for each element t ∈A. For example, if C1, C2 are two concept names, then A consists of the four elements t0 = ¬C1 ⊓¬C2, t1 = ¬C1 ⊓C2, t2 = C1 ⊓¬C2, and t3 = C1 ⊓C2, for which we introduce the variables x0, x1, x2, x3, respectively. Thus, the probability associated with C1 ⊓C2 is x3 and the one for C2 is x1 + x3. Consequently, the probabilistic terminological axiom P(C1|C2) = 0.7 can be represented by the (linear) constraint x3 = 0.7(x1 + x3). We have to ﬁnd the maximal and minimal values that P(C|D) attains on the set of values (x x ) satisfying the linear constraints induced by P The value of

the function P(C|D) (in terms of the variables xt) is given by {xt | t ∈A ∧t ⊑C ⊓D} {xt | t ∈A ∧t ⊑D} .

Byasimpletransformation,thisfractionaloptimizationproblemcanbetransformed into a linear optimization problem [Amarger et al., 1991]. Jaeger [1994] also extends the assertional formalism by allowing probabilistic assertions of the form

P(C(a)) = p,

whereC is a concept description,a an individual name, and p a real number between 0 and 1. It should be noted that this kind of probabilistic statement is quite different from the one introduced by the terminological formalism. Whereas probabilistic terminological axioms state statistical information, which is usually obtained by observing a large number of objects, probabilistic assertions express a degree of belief in assertions for speciﬁc individuals. The formal semantics of probabilistic assertions is again deﬁned with the help of probability measures on the set of all concept descriptions, one for each individual name. Intuitively, the measure for a tells us for each concept C how likely it is (believed to be) that a belongs to C. Given a knowledge base P consisting of probabilistic terminological axioms and assertions, the main inference task is now to derive optimal bounds for additional probabilistic assertions. However, if the probabilistic terminological axioms are supposed to have an impact on this inference problem, the semantics as sketched so far is not sufﬁcient. In fact, to date there is no connection between the probabil- ity measure used for the terminological part and the measures for the assertional part. Intuitively, one wants the measures for the assertional part to “most closely resemble” the measure for the terminological part, while not violating the proba- bilistic assertions. Jaeger [1994] uses cross entropy minimization in order to give a formal meaning to this intuition. To date, there is no algorithm for computing optimal bounds for P(C(a)), given a knowledge base consisting of probabilistic terminological axioms and assertions. The work reported in [Koller et al., 1997], which is restricted to the terminologi- cal component, has a focus that is quite different from the one in [Heinsohn, 1994; Jaeger, 1994]. In the latter work, the probabilistic terminological axioms provide constraints on the set of admissible probability measures. However, these con- straints may still be satisﬁed by a large set of distributions, and hence the optimal interval entailed for the probabilities of interest can be fairly large. In contrast, Koller et al. [1997] present a framework for the speciﬁcation of a unique probabil- ity distribution on the set of all concept descriptions (modulo equivalence). Since there are inﬁnitely many such descriptions providing such a (ﬁnite) speciﬁcation

is a nontrivial task. The basic idea is to specify a distribution on concepts of role- depth 0, and then to specify how to extend a distribution on concepts of role-depth n to one on concepts of role-depth n + 1. Koller et al. [1997] employ Bayesian networks as the basic representation language for the required probabilistic spec- iﬁcations. The probability P(C) of a concept description C can then be computed by using inference algorithms developed for Bayesian networks. The complexity of this computation is linear in the length of C. Under certain restrictions on the Bayesian networks used in the speciﬁcation, it is polynomial in the size of that speciﬁcation. Yelland [2000] also combines Bayesian networks and Description Logics. In contrast to [Koller et al., 1997], this work extends Bayesian networks by DL features rather than the other way round. The Description Logic used in [Yelland, 2000] is rather inexpressive, but this allows the author to avoid restrictions on the network that had to be imposed by Koller et al. [1997].

6.2.5.2 Fuzzy extensions

The concepts in Description Logics are interpreted as crisp sets, i.e., an individual either belongs to the set or not. However, many “real-life” concepts are vague in the sense that they do not have precisely deﬁned membership criteria. Consider, for example, the concept of a tall person. It does not make sense to ﬁx an exact boundary such that persons of height larger than this boundary are tall and others are not. In fact, what about a person whose height is 1 millimeter below the boundary? It is more sensible to say that an individual belongs to the concept “tall person” only to a certain degree n ∈[0, 1], which depends on the height of the individual. This is exactly what fuzzy logic allows one to do. The main idea underlying the fuzzy extensions of Description Logics proposed in [Yen, 1991; Tresp and Molitor, 1998; Straccia, 1998; 2001] is to leave the syntax as it is, but to use fuzzy logic for deﬁning the semantics. Thus, an interpretation now assigns fuzzy sets to concepts and roles, i.e., concept names A are inter- preted by membership degree functions of the form AI : I →[0, 1], and role names R by membership degree functions of the form RI : I × I →[0, 1]. The interpretation of the Boolean operators and the quantiﬁers must then be extended from {0, 1} to the interval [0, 1]. Fuzzy logics provide different op- tions for such an extension. In [Yen, 1991; Tresp and Molitor, 1998; Straccia, 1998; 2001], the usual interpretation of conjunction as minimum, disjunction as maximum, negation as λx.(1 −x), universal quantiﬁer as inﬁmum, and existential quantiﬁer as supremum is considered. For example,

(∀R.C)I(d) = inf{max{1 −RI(d, e), CI(d, e)} | e ∈I},

since ∀R C corresponds to the formula ∀x ( R(x y) ∨C(y))

Tresp and Molitor [1998] also propose an extension of the syntax by so-called manipulators, which are unary operators that can be applied to concepts. Exam- ples of manipulators could be “mostly”, “more or less”, or “very”. For example, if Tall is a concept (standing for the fuzzy set of all tall persons), then VeryTall, which is obtained by applying the manipulator Very to the concept Tall, is a new concept (standing for the fuzzy set of all very tall persons). Intuitively, the manipu- lators modify the membership degree functions of the concepts they are applied to appropriately. In our example, the membership function for VeryTall should have its largest values at larger heights than the membership function for Tall. Formally, the semantics of a manipulators is deﬁned by a function that maps membership degree functions to membership degree functions. The manipulators considered in [Tresp and Molitor, 1998] are, however, of a very restricted form. Lets us now consider what kind of inference problems are of interest in this context. Yen [1991] considers crisp subsumption of fuzzy concepts, i.e., given two concepts C, D deﬁned in the fuzzy Description Logic, he is interested in the question whether CI(d) ≤DI(d) for all fuzzy interpretations I and d ∈I. Thus, the subsumption relationship itself is not fuzziﬁed. He describes a structural subsumption algorithm for a rather small fuzzy Description Logic, which is almost identical to the subsumption algorithm for the corresponding classical Description Logic. In contrast, Tresp and Molitor [1998] are interested in determining fuzzy subsumption between fuzzy concepts, i.e., given concepts C, D, they want to know to what degree C is a subset of D. In [Straccia, 1998; 2001] and [Molitor and Tresp, 2000], also ABoxes are considered, where the ABox assertions are equipped with a degree. In this context one wants to ﬁnd out to what degree other assertions follow from the ABox. Both [Straccia, 1998; 2001] and [Tresp and Molitor, 1998] contain complete algorithms for solving these inference problems in the respective fuzzy extension of ALC. Although both algorithms are extensions of the usual tableau-based algorithm for ALC, they differ considerably. For example, the algorithm in [Tresp and Molitor, 1998] introduces numerical variables for the degrees, and produces a linear opti- mization problem, which must be solved in place of the usual clash test. In contrast, Straccia deals with the membership degrees within his tableau-based algorithm.

6.2.6 Extensions by default rules

In Description Logics, inclusion axioms of the form C ⊑D are interpreted as universal statements, i.e., all instances of C also belong to D. The same is true for inferred subsumption relationships. In commonsense reasoning, however, one often wants to state and infer relationships that are only “normally” true, but may have exceptions The most prominent example from the non monotonic reasoning

community is the statement that all birds ﬂy; but of course penguins and other non-ﬂying birds are exceptions. Allowing such default statements has a strong impact both on the semantics and the reasoning capabilities of Description Logics. Instead of basing the semantics on classical ﬁrst-order logic, one must employ a non-monotonic logic [Ginsberg, 1987]. In fact, conclusions drawn from a given knowledge base with defaults may ultimately turn out to be false when additional knowledge is added, and thus must be withdrawn. Since most of the classical Description Logics can be seen as fragments of ﬁrst-order predicate logic, an obvious approach for extending Description Logics by non-monotonic reasoning capabilities is to take one of the well-known non- monotonic logics, and restrict the ﬁrst-order version of this logic to the Description Logic in question. This approach was employed in [Baader and Hollunder, 1995a], where Reiter’s default logic [Reiter, 1980] is integrated into Description Logics. In addition to terminological axioms in the TBox and assertions in the ABox, Baader and Hollunder allow terminological defaults of the form

C(x) : D(x)

E(x) ,

where C, D, E are concept descriptions (viewed as ﬁrst-order formulae with one free variable x). Intuitively, such a default rule can be applied to an ABox individual a, i.e., E(a) is added to the current set of beliefs, if its prerequisite C(a) is already believed for this individual and its justiﬁcation D(a) is consistent with the set of beliefs. Formally, the consequences of a terminological default theory (consisting of a TBox, an ABox, and a set of terminological defaults) are deﬁned with reference to the notion of an extension, which is a set of deductively closed ﬁrst-order for- mulae deﬁned by a ﬁxpoint construction (see [Reiter, 1980]). In general, a default theory may have more than one extension, or even no extension. Depending on whether one wants to employ skeptical or credulous reasoning, an assertion F(a) is a consequence of a default theory iff it is in all extensions or if it is in at least one extension of the theory. It should be noted that in this setting the application of default rules is re- stricted to individuals explicitly present in the ABox.7 For example, assume that the ABox consists of the fact that Tom has a child that is a doctor, i.e., A = {(∃has-child.Doctor)(TOM)}, and that by default we assume that doctors are usually rich:

Doctor(x) : Rich(x)

Rich(x) .

7 This agrees with the semantics given to (monotonic) rules in Description Logics (see Subsection 6.2.3 and Ch t 2 S b ti 2 2 5)

Intuitively, one might expect that (∃has-child.Rich)(TOM) is a default conse- quence of this terminological default theory. However, since the ABox does not contain a name for Tom’s child, the default cannot be applied to this “implicit” individual, and thus one cannot conclude that Tom has a rich child by default. Baader and Hollunder [1995a] give two reasons that justify restricting the appli- cation of defaults to explicit individuals. From a semantic point of view, adapting Reiter’s treatment of implicit individuals via skolemization is quite unsatisfactory, since semantically equivalent (but syntactically different) ABoxes may lead to dif- ferent default consequences. From the algorithmic point of view, the application of defaults to implicit individuals is problematic since it may lead to an undecid- able default consequence relation, even though the Description Logic employed is decidable. In contrast, the restriction of default application to explicit individuals ensures that reasoning in terminological default theories stays decidable whenever reasoning in the underlying Description Logic is decidable. A major drawback, which terminological default logic inherits from general default logic, is that it does not take precedence of more speciﬁc defaults over more general ones into account. For example, assume that we have a default that says that doctors are usually rich, and another one that says that general practitioners are usually not rich, and that classiﬁcation shows that general practitioners are doctors. Intuitively, for any general practitioner the more speciﬁc second default should be preferred, which means that there should be only one default extension, in which the general practitioner is not rich. However, in default logic the second default has no priority over the ﬁrst one, which means that one also gets a second extension where the general practitioner is rich. This behavior has already been criticized in the general context of default logic, but it is all the more problematic in the terminological case where the emphasis lies on the hierarchical organization of concepts. To overcome this problem, Baader and Hollunder [1995b] ﬁrst deﬁne a prioritized version of Reiter’s default logic, where priorities are given by an arbitrary partial order on defaults. In the terminological case, the priority is induced by the subsumption relationship between prerequisites of defaults. A similar approach is proposed in [Straccia, 1993], with the main difference that in that paper the defaults also inﬂuence the priority order. In addition, Straccia also allows defaults of the form

A(x) ∧r(x, y) : C(y)

C(y) ,

where A is an atomic concept, r a role name, and C a concept description. Such a default can, for example, be used to say that usually a child of a doctor is again a doctor. A quite different proposal for how to treat defaults in Description Logics can be found in [Quantz and Royer 1992] There preference semantics [Shoham 1987]

is employed to deﬁne the semantics of default assertions C ❀D, which are in- tuitively interpreted as saying: “whenever an object is an instance of C, it is also an instance of D, unless this is in conﬂict with other knowledge”. Though on this intuitive level the meaning of the default C ❀D coincides with that of the termino- logical default C(x) : D(x)/D(x), the formal semantics (and thus also the default consequences) differ signiﬁcantly. The semantics proposed by Quantz and Royer is based on a preference relation on models, which tries to minimize the excep- tions to defaults while maximizing the number of defaults that have been ﬁred. In contrast to the work mentioned above, Quantz and Royer do not restrict reasoning with defaults to the derivation of concept assertions of the form C(a). They also consider default subsumption between concepts. However, default subsumption is reduced to reasoning about individuals. The subsumption relationship C ⊑D fol- lows by default from the knowledge base iff the knowledge base extended by C(a) implies D(a) by default, where a is a new individual name. Designing reasoning methods for such a model-based approach to non-monotonic reasoning is rather hard. Quantz and Royer only provide some ideas for how to obtain a sound but incomplete procedure. Default subsumption is also considered in [Padgham and Zhang, 1993], where non-monotonic inheritance networks [Horty et al., 1987] are extended in the di- rection of Description Logics, though the Description Logic employed is of a very limited expressive power.

6.3 Non-standard inference problems

All DL systems provide their users with standard inference services like computing the subsumption hierarchy and testing ABox consistency. In some applications it has turned out, however, that these services are not quite sufﬁcient for providing an optimal support when building and maintaining large DL knowledge bases. For this reason, some DL systems (e.g., Classic) provide their users with additional system services, which can formally be reconstructed as new types of inference problems. First, the standard inferences can be applied after a new concept has been de- ﬁned to ﬁnd out whether the concept is non-contradictory or whether its place in the taxonomy coincides with the intuition of the knowledge engineer; how- ever, these inferences do not directly support the process of actually deﬁning the new concept. To overcome this problem, the non-standard inference services of computing the least common subsumer and the most speciﬁc concept have been proposed. Second, if a knowledge base is maintained by different knowledge engineers, one needs support for detecting multiple deﬁnitions of the same intuitive concept Since

different knowledge engineers might use different names for the “same” primitive concept, the standard equivalence test may not be adequate to check whether different descriptions refer to the same notion. The non-standard inference service uniﬁcation of concept descriptions tackles this problem by allowing concept names to be replaced by appropriate concept descriptions before testing for equivalence. Matching is a special case of uniﬁcation, which has, for example, been used for pruning irrelevant parts of large concept descriptions before displaying them to the user. Third, and very abstractly speaking, rewriting of concept descriptions allows one to transform a given concept description C into a “better” description D, which satisﬁes certain optimality criteria (e.g., small size) and is in a certain relationship (e.g., equivalence or subsumption) with the original description C. Before describing the different non-standard inferences in more detail, we start with some general remarks on how these new problems have until now been tackled in the literature. An overview of the state of the art in this ﬁeld and detailed proofs of several of the results mentioned below can be found in [K¨usters, 2001].

6.3.1 Techniques for solving non-standard inferences – a general remark

Approaches for solving the new inference problems are usually based on an ap- propriate characterization of subsumption, which can be used to obtain a structural subsumption algorithm. First, the concept descriptions are turned into a certain normal form, in which implicit facts have been made explicit. Second, the structure of the normal forms is compared appropriately. This is one of the reasons why most of the results on non-standard inferences are restricted to languages that can be treated by structural subsumption algorithms. One can distinguish two kinds of normal forms proposed in the literature. In one approach, called language-based approach in the sequel, the normal form of a concept description is given in terms of certain ﬁnite or regular sets of words over the alphabet of all role names. Then, subsumption can be characterized via the inclusion of these sets (see Chapter 2, Subsection 2.3.3.2). The second approach, called graph-based in the following, turns concept descriptions into so-called de- scription graphs. Here, subsumption of concept descriptions is characterized via the existence of certain homomorphisms between the corresponding description graphs. The structural subsumption algorithm introduced in Chapter 2, Subsec- tion 2.3.1, can be represented in this way (although this was not explicitly done in Chapter 2). For the sublanguage ALN of Classic, the graph-based approach can be seen as a special implementation of the language-based approach [Baader et al., 1998a]. In general however either the language based or the graph based approach may

turn out to be more appropriate, depending on the Description Logic under con- sideration. On the one hand, the language-based approach is particularly useful for characterizing subsumption between cyclic concept descriptions, i.e., descrip- tions deﬁned by means of cyclic terminologies in FL0 and ALN [Baader, 1996b; K¨usters, 1998]. On the other hand, the graph-based approach can be employed to handle full Classic [Borgida and Patel-Schneider, 1994] as well as ALE [Baader et al., 1999b], which extends FL0 by primitive negation and existential restrictions. Although Borgida and Patel-Schneider did not explicitly characterize subsump- tion in terms of homomorphisms between description graphs, their subsumption algorithm does in fact check for the existence of an appropriate homomorphism. The known approaches for solving non-standard inference problems are usually based on one of the two approaches for characterizing subsumption, depending on the Description Logic of choice. In the sequel, we will give an idea of how to solve the inference problems by mainly looking at the language-based approach for the Description Logic FL0. We will also brieﬂy comment on how to treat extensions of FL0.

6.3.2 Least common subsumer and most speciﬁc concept

Intuitively, the least common subsumer of a given collection of concept descriptions is a description that represents the properties that all the elements of the collection have in common. More formally, it is the most speciﬁc concept description that subsumes the given descriptions:

Deﬁnition 6.13 Let L be a description language. A concept description E of L is the least common subsumer (lcs) of the concept descriptions C1, . . . , Cn in L (lcs(C1, . . . , Cn) for short) iff it satisﬁes

(i) Ci ⊑E for all i = 1, . . . , n, and (ii) E is the least L-concept description satisfying (i), i.e., if E′ is an L-concept description satisfying Ci ⊑E′ for all i = 1, . . . , n, then E ⊑E′.

As an easy consequence of this deﬁnition, the lcs is unique up to equivalence. In fact, if E1 and E2 are both least common subsumers of the same collection of concepts, then E1 ⊑E2 (since E2 satisﬁes (i) and E1 is the least concept description satisfying (i)). The subsumption relationship E2 ⊑E1 can be derived analogously. It should be noted, however, that the lcs need not always exist. This can have two different reasons: (a) there may be several subsumption incomparable minimal concept descriptions satisfying (i) of the deﬁnition; (b) there may be an inﬁnite chain of more and more speciﬁc descriptions satisfying (i). It is easy to see, however, that for Description Logics allowing conjunction of descriptions (a) cannot occur

The lcs was ﬁrst introduced by Cohen et al. [1992] as a new inference task that is useful for a number of different reasons. First, ﬁnding the most speciﬁc concept that generalizes a set of examples is a common operation in inductive learning, called learning from examples. Cohen and Hirsh [1994a] as well as Frazier and Pitt [1994] investigate the learnability of sublanguages of Classic with regard to the PAC learning model proposed by Valiant [1984]. The lcs-computation is used as a subprocedure in their learning algorithms. Experimental results concerning the learnability of concepts based on computing the lcs can be found in [Cohen and Hirsh, 1994b]. Another motivation for considering the lcs is to use it as an alternative to disjunc- tion. The idea is to replace disjunctions like C1 ⊔· · · ⊔Cn by the lcs of C1, . . . , Cn. In [Cohen et al., 1992; Borgida and Etherington, 1989], this operation is called knowledge base viviﬁcation. Although, in general, the lcs is not equivalent to the corresponding disjunction, it is the best approximation of the disjunctive concept within the available Description Logic. The use of such an approximation is moti- vatedbythefactthat,inmanycases,addingdisjunctionwouldincreasethecomplex- ity of reasoning. Observe that, if the Description Logic already allows disjunction, we have lcs(C1, . . . , Cn) ≡C1 ⊔· · · ⊔Cn. In particular, this means that, for such Description Logics, the lcs is not really of interest. Finally, as proposed in [Baader and K¨usters, 1998; Baader et al., 1999b], the lcs operation can be used to support the “bottom-up” construction of DL knowl- edge bases. In contrast to the usual “top-down” approach, where the knowledge engineer ﬁrst deﬁnes the terminology of the application domain in the TBox and then uses this terminology when describing individuals in the ABox, the “bottom- up” approach proceeds as follows. The knowledge engineer ﬁrst speciﬁes some “typical” examples of a concept to be deﬁned using individuals in the ABox. Then, in a second step, these individuals are generalized to their most speciﬁc concept, i.e., a concept description that (i) has all the individuals as instances, and (ii) is the most speciﬁc description satisfying property (i). Finally, the knowl- edge engineer inspects and possibly modiﬁes the concept description obtained this way. Let us now deﬁne the most speciﬁc concept of an ABox individual in more detail.

Deﬁnition 6.14 A concept description E in some description language L is the most speciﬁc concept (msc) of the individuals a1, . . . , an deﬁned in an ABox A (msc(a1, . . . , an) for short) iff

(i) A |= E(ai) for all i = 1, . . . , n, and (ii) E is the least concept satisfying (i), i.e., if E′ is an L-concept description satisfying A | E′( ) f ll i 1 th E ⊑E′

The task of computing the msc can be split into two subtasks: computing the most speciﬁc concept of a single individual, and computing the least common subsumer of a given ﬁnite number of concepts. In fact, it is easy to see that msc(a1, . . . , an) ≡ lcs(msc(a1), . . . , msc(an)).

6.3.2.1 Computing the lcs and the msc

We will now give an intuition on how to compute the lcs for the Description Logic FL0 and an extension, and brieﬂy comment on the problems that arise when con- sidering the msc. As mentioned above, the ﬁrst step towards an algorithm for computing the lcs is to characterize subsumption of concept descriptions. For the Description Logic FL0, we will present such a characterization using the language- based approach. The normal form of FL0-concept descriptions employed in the language-based approach is the so-called concept-centered normal form (CCNF), which has already been introduced in Chapter 2, Subsection 2.3.3.2. For example, using the equiva- lence ∀R.(C ⊓D) ≡∀R.C ⊓∀R.D and commutativity of concept conjunction, the FL0-concept description C = ∀R.(∀S.A ⊓∀R.B) ⊓∀S.∀S.A can be transformed into CCNF as follows:

C ≡∀R.∀S.A ⊓∀S.∀S.A ⊓∀R.∀R.B ≡∀{RS, SS}.A ⊓∀{RR}.B.

Recall that ∀{RS, SS}.A has been introduced in Chapter 2, Subsection 2.3.3.2 as an abbreviation for ∀R.∀S.A ⊓∀S.∀S.A. Similarly, ∀{RR}.B abbreviates ∀R.∀R.B. In general, if NC is a ﬁnite set of atomic concepts and NR is a ﬁnite set of role names, then the CCNF of a concept C built using only these names is of the form

C ≡⊓ A∈NC ∀UA.A,

where UA is a ﬁnite set of words over the alphabet of role names, i.e., UA ⊆N ∗ R. Note that ∀∅.A represents the universal concept ⊤, and ∀{ε}.A for the empty word ε is equivalent to A. If the CCNF of D is ⊓A∈NC ∀VA.A, then subsumption of C by D can be charac- terized as follows:

Proposition 6.15 C ⊑D iff VA ⊆UA for all A ∈NC.

As an easy consequence, we obtain

Corollary 6.16 lcs(C, D) ≡⊓A∈NC ∀(UA ∩VA).A.

By Proposition 6.15, this concept description obviously subsumes C and D. Moreover, UA ∩VA is the largest set contained in both UA and VA, and thus ⊓A∈NC ∀(UA ∩VA).A is in fact the least concept subsuming both C and D. As an example consider the concept C speciﬁed above and D ≡∀{RS, RR}.A ⊓ ∀{RR, SR}.B. Then, lcs(C, D) ≡∀{RS}.A ⊓∀{RR}.B. For Description Logics extending FL0 by constructs that can express unsatisﬁ- able concepts, like ⊥, the language-based approach can still be applied. However, in order to characterize subsumption, we need to consider certain inﬁnite regular lan- guages instead of ﬁnite ones. The reason is that ⊥is subsumed by an inﬁnite number of concept descriptions. For example, although ∀{R, RSR}.⊥⊑∀{RR}.⊥, we do not have V⊥= {RR} ⊆{R, RSR} =: U⊥. However, we know that ∀{R}.⊥is sub- sumed by ∀{Rw}.⊥for any word w of the alphabet NR. Consequently, we must use U⊥·N ∗ R = {vw | v ∈U⊥and w ∈N ∗ R} in place of U⊥in the inclusion test. For this reason, the lcs must also be described in terms of possibly inﬁnite regular lan- guages. As a simple example, consider the concept descriptions C ≡∀{R, SR}.⊥ and D ≡∀{RS, S}.⊥. Then,

lcs(C, D) ≡∀({R, SR}·N ∗ R ∩{RS, S}·N ∗ R).⊥ ≡∀({RS, SR}·N ∗ R).⊥ ≡∀{RS, SR}.⊥.

A detailed description of how to compute the lcs in ALN, which extends FL0 by ⊥, atomic complement, and number restrictions, is given in [Baader and K¨usters, 1998]. Moreover, Baader and K¨usters investigate cyclic ALN-concept descrip- tions, which are deﬁned in terms of cyclic terminologies with greatest ﬁxpoint semantics. In this context, the languages UA introduced above can be arbitrary regular languages (see also Chapter 2, Subsection 2.3.3.2). Cyclic descriptions become necessary if one wants to guarantee the existence of the msc. Consider, for example, the ABox consisting only of the assertion R(a, a). Then, we know that msc(a) ⊑∀R. · · · ∀R.(⩽1 R) for arbitrarily deep nesting of value restrictions. Baader and K¨usters show that there does not exist an acyclic ALN-concept description presenting the msc of a. However, the msc of indi- viduals described in ALN-ABoxes can always be represented by a cyclic ALN- concept description. In our example, msc(a) can be represented by the concept A de- ﬁned by A ≡(= 1 R) ⊓∀R.A, if this deﬁnition is interpreted with greatest ﬁxpoint semantics. Using the graph-based approach, the lcs can be computed for the Description Logic that extends FL0 by the same-as construct [Cohen and Hirsh, 1994a; Frazier and Pitt, 1994; K¨usters and Borgida, 2001], for the language ALE, which extends FL0 by full existential quantiﬁcation and primitive negation [Baader

et al., 1999b], and for the language ALEN, which extends ALE by number restrictions [K¨usters and Molitor, 2001b]. On the one hand, it is not clear how to handle these languages with the language-based approach. On the other hand, up to now the graph-based approach cannot deal with cyclic concept descriptions, which are needed for computing the msc. Consequently, for the extensions of FL0 treated with the help of the graph-based approach, the msc can currently only be approximated [Cohen and Hirsh, 1994b; K¨usters and Molitor, 2001a].

6.3.3 Uniﬁcation and matching

Uniﬁcationandmatchingarenon-standardinferencesthatallowustoreplacecertain concept names by concept descriptions before testing for equivalence or subsump- tion. This capability turns out to be useful when maintaining (large) knowledge bases. In this subsection, we will ﬁrst introduce uniﬁcation and matching and men- tion the main motivations for considering these new inference tasks. We will then review the results available in the literature, and give an intuition on how uniﬁcation problems in the small language FL0 can be solved.

6.3.3.1 Uniﬁcation

Uniﬁcation of concepts was ﬁrst introduced by Baader and Narendran [1998], motivated by the following application problem. If several knowledge engineers are involved in deﬁning new concepts, and if this knowledge acquisition process takes rather long (several years), it happens that the same (intuitive) concept is introduced several times, often with slightly differing descriptions. Testing for equivalence of concepts is not always sufﬁcient to ﬁnd out whether, for a given concept description, there already exists another concept description in the knowledge base describing the same notion. As an example, let us ask whether the following two FL0-concept descriptions might denote the same (intuitive) concept.

∀has-child.∀has-child.Rich ⊓∀has-child.Rmr,

Acr ⊓∀has-child.Acr ⊓∀has-child.∀has-spouse.Rich.

The answer is yes, since replacing the concept name Rmr by the description Rich ⊓ ∀has-spouse.Rich and Acr by ∀has-child.Rich yields the descriptions

∀has-child.∀has-child.Rich ⊓∀has-child.(Rich ⊓∀has-spouse.Rich),

∀has-child.Rich ⊓∀has-child.∀has-child.Rich ⊓∀has-child.∀has-spouse.Rich,

which are obviously equivalent. Thus, under the assumption that Rmr stands for “Rich and married rich” and Acr for “All children are rich”, we can conclude that

both descriptions are meant to express the concept “All grandchildren are rich and all children are rich and married rich”. A substitution of concept descriptions for concept names that makes two concept descriptions C, D equivalent is called a uniﬁer of C and D. Of course, before testing for uniﬁability, one must decide which of the concept names the uniﬁer is allowed to replace. These names are then called concept variables to distinguish them from the usual concept names, which cannot be replaced. In the above example, the strange acronyms Acr and Rmr were considered to be variables, whereas Rich was treated as a (non-replaceable) concept name. Concept descriptions containing variables are called concept patterns. More precisely, FL0-concept patterns are deﬁned by means of the following syntax rules:

C, D −→X | A | ∀R.C | C ⊓D

where X stands for concept variables. Now, a substitution in FL0 is a mapping from the concept variables into the set of FL0-concept descriptions. An example is the substitution {Rmr 0→Rich ⊓ ∀has-spouse.Rich, Acr 0→∀has-child.Rich} used in our example. The application of a substitution can be extended from variables to FL0-concept patterns in the usual way (as exempliﬁed above).

Deﬁnition 6.17 Let C, D be FL0-concept patterns. Then, a substitution σ is a uniﬁer of the uniﬁcation problem C ≡? D iff σ(C) ≡σ(D).

Of course, it is not necessarily the case that concept descriptions that are uniﬁable in this way are really meant to represent the same notion. A uniﬁability test can, however, suggest to the knowledge engineer possible candidate descriptions.

6.3.3.2 Matching

Matching can be seen as a special case of uniﬁcation, where one of the two ex- pressions to be uniﬁed does not contain variables [Baader and Narendran, 1998; 2001]. Thus, a matching problem is of the form C ≡? D where C is a concept description and D a concept pattern. A substitution σ is a matcher of this problem iff C ≡σ(D). Borgida and McGuinness [1996] have introduced a different notion of matching, whichwecallmatchingmodulosubsumptiontodistinguishitfrommatchingmodulo equivalence, as introduced above. A matching problem modulo subsumption is of the form C ⊑? D, where C is a concept description and D is a concept pattern. Such a problem asks for a substitution σ such that C ⊑σ(D).

Since σ is a solution of C ⊑? D iff σ solves C ≡? C ⊓D, matching modulo subsumption can be reduced to matching modulo equivalence, and thus to uniﬁca- tion. However, in the context of matching modulo subsumption, one is interested in ﬁnding “minimal” solutions of C ⊑? D, i.e., σ should satisfy the property that there does not exist another substitution δ such that C ⊑δ(D) ⊏σ(D). In addition, Baader et al. [1999a] introduce side conditions of the form X ⊑E and X ⊏E, with X a variable and E a concept pattern, to further restrict possible substitutions for the variables occurring in the matching problem. The original reason for introducing matching modulo equivalence was (i) to help ﬁlter out unimportant aspects of complicated concepts appearing in large knowledge bases, and (ii) to specify patterns for explaining proofs carried out by Description Logic systems [McGuinness and Borgida, 1995]. For example, matching the concept pattern

D = ∀research-interests.X

against the description

C = ∀pets.Cat ⊓∀research-interests.AI ⊓∀hobbies.Gardening

yields the minimal matcher σ = {X 0→AI}, and thus ﬁnds the scientiﬁc interest described in the concept, ﬁltering out the other aspects described by C. Another motivation for matching as well as uniﬁcation can be found in the area of integrating data or knowledge base schemas represented in some Description Logic. An integrated schema can be viewed as the union of the local schemas along with some interschema assertions satisfying certain conditions. Finding such inter- schema assertions can be supported by solving matching or uniﬁcation problems. Borgida and K¨usters [2000] propose a formal framework for schema integration, and provide initial theoretical as well as experimental results concerning this ap- plication of uniﬁcation and matching.

6.3.3.3 Results on matching and uniﬁcation

As with computing the lcs, the algorithms for matching that can be found in the literature follow either the language-based or the graph-based approach. Matching modulo subsumption for a description language containing most of the constructs available in Classic has been considered in [Borgida and McGuinness, 1996]. Borgida and McGuinness describe a polynomial-time matching algorithm, which follows the graph-based approach. However, this algorithm cannot be applied to arbitrary patterns, and it is not complete. Using the language-based approach, com- plete and polynomial-time algorithms for matching modulo equivalence and match- ing modulo subsumption in FL0 were presented in [Baader and Narendran, 1998; 2001] This result was extended to the language ALN by Baader et al [1999a] and

its extension ALN reg by the role constructors union, composition, and transitive closure by K¨usters [2001]. Baader et al. [2001] consider matching under side condi- tions in more detail. Basically, subsumption conditions of the form X ⊑E leave the complexity of matching in ALN polynomial, whereas strict subsumption condi- tions X ⊏E cause np-hardness. Matching in ALE based on the characterization of subsumption by homomorphism between graphs has been investigated in [Baader and K¨usters, 2000]. It is shown that matching modulo equivalence is np-complete, and that appropriate matchers can be computed in exponential time. Finally, com- plete algorithms for matching in Classic are provided by K¨usters [2001]. For uniﬁcation, the only results available to date are for the small Description Logic FL0 and its extension FLreg by the role constructors union, composition, and transitive closure. In [Baader and Narendran, 1998; 2001] it is shown that deciding uniﬁability of FL0-patterns is an ExpTime-complete problem, and in [Baader and K¨usters, 2001] this result is extended to FLreg. In the remainder of this subsection, we will try to give a ﬂavor of how to solve uniﬁcation problems in FL0. As an immediate consequence of Proposition 6.15, equivalence of FL0-concept descriptions C = ⊓A∈NC ∀UA.A and D = ⊓A∈NC ∀VA.A in CCNF can be charac- terized as follows:

C ≡D iff UA = VA for all A ∈NC. (6.3)

This fact can be used to turn FL0-uniﬁcation problems into certain formal language equations, which then can be solved using tree automata. Let us illustrate this by the example from Subsection 6.3.3.1. There, we consid- ered the uniﬁcation problem8

∀{cc}.R ⊓∀{c}.X ≡? ∀{ε, c}.Y ⊓∀{cs}.R.

As an easy consequence of (6.3), a substitution σ of the form

{X 0→∀UX.R, Y 0→∀UY.R},

where UX, UY are sets of words over the alphabet {c, s}, is a uniﬁer of this problem iff the assignment X = UX and Y = UY solves the formal language equation

{cc} ∪{c}·X = {cs} ∪{ε, c}·Y.

For example, the uniﬁer {X 0→R ⊓∀s.R, Y 0→∀c.R} corresponds to the solution X = {ε, s}, Y = {c} of the above formal language equation. In general, uniﬁcation problems correspond to systems of formal language equations of the form

S0 ∪S1·X1 ∪· · · ∪Sn·Xn = T0 ∪T1·X1 ∪· · · ∪Tn·Xn,

8 To increase readability, has-spouse is replaced by s, has-child by c, Rich by R, and Rmr, Acr by the variables X Y I dditi h l d t f d th tt i t th i CCNF

where the Si, Ti are given ﬁnite sets of words and the Xi are variables ranging over ﬁnite sets of words. In [Baader and Narendran, 1998; 2001] it is shown that solvability of such a system of equations can be reduced (in exponential time) to the emptiness problem for automata on ﬁnite trees. This yields an ExpTime- decision procedure for uniﬁcation in FL0. For uniﬁcation in FLreg, the Si, Ti are regular languages, and to test the equation for solvability one must employ automata working on inﬁnite trees.

6.3.4 Concept rewriting

A general framework for rewriting concepts using terminologies has been proposed in Baader et al. [2000]. Assume that L1, L2, and L3 are three description languages, and let C be an L1-concept description and T an L2-TBox. We are interested in rewriting (i.e., transforming) C into an L3-concept description D such that C and D are in a certain relationship (e.g., equivalence, subsumption w.r.t. T ) and such that D satisﬁes certain optimality criteria (e.g., being of minimal size). This very general framework has several interesting instances. In the following, we will discuss the three most promising ones. The ﬁrst instance is the translation of concept descriptions from one Descrip- tion Logic into another. Here, we assume that L1 and L3 are different description languages, and that the TBox T is empty. By trying to rewrite an L1-concept C into an equivalent L3-concept D, one can ﬁnd out whether C is expressible in L3. In many cases, such an exact rewriting may not exist. In this case, one can try to approximate C by an L3-concept from above (below), i.e., ﬁnd a minimal (maxi- mal) concept description D in L3 such C ⊑D (D ⊑C). An inference service that can compute such rewritings could, for example, support the transfer of knowledge bases between different systems. First results in this direction for the case where L1 is ALC and L3 is ALE can be found in [Brandt et al., 2001]. The second instance comes from the database area, where the problem of rewrit- ing queries using views is a well-known research topic [Beeri et al., 1997]. The aim is to optimize the runtime of queries by using cached views, which allows one to minimize the (more expensive) access to source relations. In the context of the above framework, views can be regarded as TBox deﬁnitions and queries as concept de- scriptions. Beeri et al. [1997] investigate the instance where L1 = L2 = ALCNR and L3 = {⊓, ⊔}. More precisely, they are interested in maximally contained total rewritings, i.e., D should be subsumed by C, contain only concept names deﬁned in the TBox, and be a maximal concept (w.r.t. subsumption) satisfying these prop- erties. They show that such a rewriting is computable (whenever it exists). The third instance of the general framework, which was ﬁrst proposed in [Baader and Molitor 1999] tries to increase the readability of large concept descriptions

by using concepts deﬁned in a TBox. The motivation comes from the experi- ences made with non-standard inferences (like lcs, msc and matching) in ap- plications. The concept descriptions produced by these services are usually un- folded (i.e., do not use deﬁned names), and are thus often very large and hard to read and comprehend. Therefore, one is interested in automatically generating an equivalent concept description of minimal length that employs the concept names deﬁned in the underlying terminology. Referring to the framework, one thus considers the case where L = L1 = L2 = L3 and the TBox is nonempty. For a given concept description C and a TBox T in L one is interested in an L-concept description D (containing concept names deﬁned in T ) such that C ≡T D and the size of D is minimal. Rewriting in this sense has been investigated for the languages ALN and ALE [Baader and Molitor, 1999; Baader et al., 2000]. Rewritings can be computed by a nondeterministic poly- nomial algorithm that uses an oracle for deciding subsumption. The corresponding decision problem (i.e., the question whether there exists a rewriting of size ≤k for a given number k) is np-hard for both languages.

Acknowledgement

We would like to thank Jochen Heinsohn and Manfred Jaeger for helpful discussions regarding the treatment of uncertain and vague knowledge and Riccardo Rosati regarding the treatment of epistemic operators.

Part II

Implementation

7

From Description Logic Provers to Knowledge Representation Systems

DEBORAH L. McGUINNESS PETER F. PATEL-SCHNEIDER

Abstract

A DL-based knowledge representation system is more than an inference engine for a particular Description Logic. A knowledge representation system must provide a number of services to human users, including presentation of the information stored in the system in a manner palatable to users and justiﬁcation of the inferences performed by the system. If human users cannot understand what the system is doing, then the development of knowledge bases is made much more difﬁcult or even impossible. A knowledge representation system must also provide a number of services to application programs, including access to the basic information stored in the system but also including access to the machinations of the system. If programs cannot easily access and manipulate the information stored in the system, then the development of applications is made much more difﬁcult or even impossible.

7.1 Introduction

A DL-based knowledge representation system does not live in a vacuum. It has to be prepared to interact with several sorts of other entities. One class of entities consists of human users who develop knowledge bases using the system. If the system cannot effectively interact with these users then it will be difﬁcult to create knowledge bases in the system, and the system will not be used. Another class of entities consists of programs that use the services of the system to provide information to support applications. If the system cannot effectively interact with these programs then it will be difﬁcult to create applications using the system, and the system will not be used. However, before one can talk about effective interaction, there has to be basic interaction between the knowledge representation system and applications or users. This basic interaction has to do with the mechanics of telling information to the

system and retrieving information from it. At this level the system just maintains what it was told and responds to the queries by running an inference procedure for the logic it implements. The basic interface is not sufﬁcient for effective access to the system. On the application side there is need for a treatment of exceptional conditions, wider in- terface to applications, remote interfaces, and concurrent access, among others. There is also need for responsive reaction by the system. On the human side there is need for better presentation of the results of queries, particularly the suppression of irrelevant detail; explanation of the inferences performed by the system; better support for the creation of large DL knowledge bases, particularly by several people working in collaboration. Even if all the above are present in a system, it will still not be complete. There is also a need to have effective information about the system widely available. This information has to be in various forms, including the obvious user manuals, but also including interactive tutorials and demonstration systems. A system that does not include all of the above services is not a complete knowl- edge representation system. Our discussion of the services that need to be provided will mostly be described in terms of an arbitrary DL knowledge representation system. However, some of our examples will be given in the context of the Classic family of knowledge repre- sentation systems developed at AT&T [Borgida et al., 1989; Brachman et al., 1991; Patel-Schneider et al., 1991], as Classic has had the longest-lived and most extensive industrial application history of any DL knowledge representation system. The Classic application that we will refer to the most is the conﬁg- uration of transmissions equipment – an application developed within AT&T [Wright et al., 1993; McGuinness et al., 1995; McGuinness and Wright, 1998b; McGuinness et al., 1998]. In a typical conﬁguration problem, a user is interested in entering a small number of constraints and obtaining a complete, correct, and consistent parts list. Given a conﬁguration application’s domain knowledge and the base DL inference system, the application can determine if the user’s constraints are consistent. It can then calculate the deductive closure of the user-stated knowledge and the background domain knowledge to generate a more complete description of the ﬁnal parts list. For example, in a home theater demonstration conﬁguration system [McGuinness et al., 1995], user input is solicited on the quality a user is willing to pay for and the typical use (audio only, home theater only, or combination), and then the application deduces all applicable consequences. This typically generates descriptions for 6–20 subcomponents which restrict properties such as price range, television diagonal, power rating, etc. A user might then inspect any of the individual components pos- sibly adding further requirements to it which may in turn cause further constraints

to appear on other components of the system. Also, a user may ask the system to “complete” the conﬁguration task, completely specifying each component so that a parts list is generated and an order may be completed. This home theater conﬁgurator example is fairly simple but it is motivated by real-world application uses in conﬁguring very large pieces of transmission equipment where objects may have thousands of parts and subparts and one decision can easily have hundreds of ramiﬁcations. It was complicated appli- cations such as these that drove our work on access to information. More in- formation can be found on Description Logics for conﬁguration in this book in Chapter 12. Another example application that drove our work on informa- tion access and presentation needs was a simple DL backend system support- ing knowledge-enhanced search for the web called FindUR [McGuinness, 1998; McGuinness et al., 1997] which is also described in Chapter 14.

7.2 Basic access

Basic access to a DL knowledge base consists of simple mechanisms to create DL knowledge bases and to query them. The foundational aspects of this basic interaction have been well-studied. For example, Levesque [1984] proposed that the basic interface to any knowledge representation system consist of two kinds of interactions – one to tell information to the system and one to ask whether information follows from what was previously told to the system. Many frame-oriented knowledge representation systems embody such distinc- tions, such as the Generic Frame Protocol [Chaudhri et al., 1997], and OKBC (Open Knowledge Base Connectivity) [Chaudhri et al., 1998a]. In the DL community, this basic interaction was standardized into an interface speciﬁcation that deﬁned a number of Tell&Ask operations that a DL knowledge representation system should implement [Patel-Schneider and Swartout, 1993]. This speciﬁcation is commonly known as the Krss speciﬁcation.1 The description of a minimal DL knowledge representation system interface given here will generally follow this Krss spec- iﬁcation. The Krss speciﬁcation incorporates the DFKI standardized syntax and semantics [Baader et al., 1991]. Examples given here follow the syntax of Chap- ter 2, for the abstract syntax, and the syntax of Krss for a Lisp-like syntax that can actually be used from within a computer. One problem with deﬁning a Tell&Ask interface for a DL knowledge representa- tion system is that even a minimal interface depends on the expressive power of the logic. As an example, if the Description Logic implemented by the system does not

1 The Krss speciﬁcation also incorporates a number of operations that fall under the advanced interface that will b di d l t

Table 7.1. Syntax and semantics of making deﬁnitions.

Program Syntax Abstract Syntax Semantics

(define-concept CN C) CN ≡C CN I = CI

(define-primitive-concept CN C) CN ⊑C CN I ⊆CI

(define-role RN R) RN ≡R RN I = RI

(define-primitive-role RN R) RN ⊑R RN I ⊆RI

(define-attribute AN A) AN ≡A AN I = AI

(define-primitive-attribute AN R) AN ⊑R AN I ⊆RI

Table 7.2. Inclusion syntax and semantics.

Program Syntax Abstract Syntax Semantics

(included C D) C ⊑D CI ⊆DI

include individuals then of course there is no need to include any facilities for making statements about individuals. To overcome this difﬁculty this chapter will describe the interfaces required for a system that implements a typical Description Logic with both concepts and individuals. Such a system has to have a method for creating a terminology of concepts. A syntax for creating such a terminology, taken directly from the Krss speciﬁcation, is given in Table 7.1. A terminological knowledge base, or TBox, is then a set of such deﬁnitions perhaps with the condition that every concept, role, and attribute name has at most one deﬁnition. There may also be the side condition that there are no recursive deﬁnitions. Some representation systems may have other deﬁnitions allowable or other re- strictions. For example, some systems allow the deﬁnition of transitive roles, via a deﬁne-transitive-role deﬁnition. Other systems prohibit non-primitive roles. If the underlying Description Logic allows recursive deﬁnitions, then it may be easier to provide an even more basic interface to deﬁne concepts. Table 7.2 shows a minimal interface for a system that employs arbitrary concept inclusions as its means of deﬁning concepts. If the system incorporates individual reasoning, then it has to have a mechanism for adding information about these individuals. One such method is via the asser- tions in Table 7.3. An assertional knowledge base, or ABox, is then a set of such assertions. Once information has been told to the system, there has to be a mechanism for determining what follows from this information A minimal mechanism for this is

Table 7.3. Assertion syntax and semantics.

Program Syntax Abstract Syntax Semantics

(instance IN C) IN ∈C IN I ∈CI

(related IN I R) ⟨IN , I⟩∈R ⟨IN I, I I⟩∈RI

Table 7.4. Query syntax and semantics.

Query Meaning

(concept-subsumes? C1 C2) CI 1 ⊆CI 2 (role-subsumes? R1 R2) RI 1 ⊆RI 2 (individual-instance? IN C) IN I ∈CI

(individual-related? IN I R) ⟨IN I, I I⟩∈RI

Table 7.5. Taxonomy retrieval syntax.

(concept-descendants C) (concept-children C) (concept-ancestors C) (concept-parents C) (concept-instances C) (concept-direct-instances C) (role-descendants R) (role-children R) (role-ancestors R) (role-parents R) (individual-types IN) (individual-direct-types IN) (individual-fillers IN R)

via a set of queries, such as those given in Table 7.4. The system answers a quary by determining if the meaning of the query is implied by the information that has been told to the system. The interface described above is sufﬁcient for determining the contents of a knowledge base but only in the theoretical sense. For reasonable access to the information in a knowledge base a richer interface is required. One part of this richer access even really belongs in the basic interface, namely retrievals of taxonomy information. The interface in Table 7.5 provides a simple interface to the taxonomy information implicit in a DL knowledge base. The meaning of the calls should be obvious from their description except perhaps the “ direct ” versions which

Table 7.6. UnTell syntax.

(undefine-concept CN) (undefine-role RN) (undefine-attribute AN) (un-tell-instance IN C) (un-tell-related IN I R)

return the concepts, individuals, or roles that are directly related to the query, i.e., that have no intervening concept or role. Another basic service that is missing from above interface is the ability to remove information from the knowledge base. This is not the ability to perform arbitrary changes to the implicit information represented by the knowledge base. Instead it is just the ability to “un-tell” information that had been previously told to the system. A basic interface for this purpose is given in Table 7.6. There may be restrictions on what can be un-told, such as requiring that concepts that are currently mentioned in the deﬁnition of other concepts cannot be removed from the knowledge base.

7.3 Advanced application access

The basic interface described above provides only minimal access to a DL knowl- edge base. Effective access requires a number of augmentations to the basic inter- face. One of the most important augmentations has to do with deﬁning a complete application programming interface (API). The basic interface assumes that the system is implemented in a language like Lisp, where there is a simple way of creating descriptions and other values for the various operations and there is a mechanism for returning values of any type. This was acceptable when systems and applications were all implemented in Lisp, but this is no longer the case. A complete API must then provide a syntax for creating all the types of values that need to be passed to the representation system. Further, it needs to provide or deﬁne mechanisms for returning values, particularly compound values such as the sets of concepts that are returned by the taxonomic retrieval operations.

7.3.1 Efﬁciency

Because the operations of the representation system may represent the largest re- source consumption of an application, it is often necessary to know how expensive various operations of the system may be For example it is often necessary to know

the usual resource consumption of the most frequently called operations of the knowledge representation system or those operations that are called at critical time in the operation of the whole system. The Classic family has been particularly aggressive in ensuring that queries to the system are fast, working under the assumption that the most common operations are queries. Most queries in Classic are simply retrievals of data stored by the system, as Classic responds to the addition of knowledge by computing most of its consequences. Further, the performance of the addition of knowledge to the system is optimized over the retraction or change of knowledge. Classic achieves these characteristics of fastest queries, fast additions, and slower retractions and changes by retaining data structures that record the current set of consequences and also record, on a fairly granular level, which knowledge affects other knowledge. This is not full truth-maintenance data, which would be prohibitively expensive to compute (and store), but is just enough to make additions cheap. It also serves to make retractions and changes somewhat cheaper than they otherwise would be, but this effect is much less than the gain in speed of adding knowledge.

7.3.2 Wide application programming interface

In the vast majority of applications, the knowledge representation system has to serve as a tightly integrated component of a much larger overall system. For this to be workable, the knowledge representation system must provide a full-featured interface for the use of the rest of the system. The NeoClassic system, which is programmed in C++, and is designed to be part of a larger C++ program, provides a very wide application programming inter- face. In addition to the above interface, there is a large interface that lets the rest of the system receive and process the actual data structures used inside NeoClassic to represent knowledge, but without allowing these structures to be modiﬁed out- side of NeoClassic.2 This interface allows much faster access to the knowledge stored by NeoClassic, as many accesses just retrieve ﬁelds from a data structure. Further, direct access to data structures allows the rest of the system to keep track of knowledge from NeoClassic without having to keep track of a “name” for the knowledge querying using this name. (In fact, it is in this way possible to dispense with any notion of querying by name.) There are also ways to obtain the data structures that are used by NeoClassic for other purposes, including explanation. We have used this facility to write graphical user interfaces to present explanations and other information.

2 Of course, as C++ does not have an inviolable type system, there are mechanisms to modify these structures. It i j t th t ll t d t

An additional interface that is provided by both Lisp Classic and NeoClassic is a notiﬁcation mechanism, or hooks. This mechanism allows programmers to write functions that are called when particular changes are made in the knowledge stored in the system or when the system infers new knowledge from other knowl- edge. Hooks for the retraction of knowledge from the system are also provided. These hooks allow, among other things, the creation of a graphical user interface that mirrors (some portion or view of) the knowledge stored in the representation system. Others in the knowledge representation community have recognized the need for common APIs, (e.g., the Generic Frame Protocol [Chaudhri et al., 1997] and the Open Knowledge Base Connectivity [Chaudhri et al., 1998a]). Some systems embrace the notion of loading many different forms of knowledge bases and accept wrapper speciﬁcations for other source formats and APIs. For example, Ontolin- gua has implemented capability for loading a number of formats including Classic, OKBC, ANSI KIF, KIF 3.0, CML, CLIPS, Ontolingua, Prot´eg´e, Snark, and DAML+OIL. It also provides the ability to dump frames in multiple formats such as OKBC, Classic, CLOS, CML, Ontolingua, and DAML+OIL and it has also been made interoperable with at least two reasoners including one in Lisp and one in Java.

7.3.3 Remote and concurrent access

The standard computing environment is becoming more and more distributed. If a DL knowledge representation system is to be part of this environment it must allow effective remote access. There are several mechanisms for allowing remote access, including applications that run on the same machine as the DL knowledge repre- sentation system but themselves provide a remote access mechanism. Examples of such applications are the wines [Brachman et al., 1991] and stereo conﬁguration demonstration systems [McGuinness et al., 1995] mentioned later in this chapter. The DL knowledge representation system itself can also directly provide a remote access mechanism. This can be as simple as providing the system with a pipe-like interface where clients can send a sequence of commands to the system from remote machines, and receive responses via the same pipe. NeoClassic provides this sort of simple remote access mechanism. A more complicated remote access mechanism would be to provide a CORBA interface to the system. This kind of access was proposed by Bechhofer et al. [1999]. Their interface gives a CORBA layering around a Tell&Ask interface. Providing a wider CORBA access to DL knowledge representation systems, such as providing CORBA access to the actual data structures of the system, is more difﬁcult, as the CORBA mechanism for dealing with recursive objects is annoying Nevertheless

an effective remote access mechanism should provide the same functionality as is desired for local access. If remote access to a DL knowledge representation system is provided, then the issue of concurrent access becomes vital. (This is not to say that concurrent access is not of interest if the system does not allow remote access.) The interesting issues withrespecttoconcurrentaccessinvolvesimultaneousaccesstothesamerepository of knowledge. Most of the issues with respect to concurrent access are the same as concurrent access to databases, including locking and providing transactions. In fact, there have been informal proposals to use a database system to store the information in a DL knowledge representation system like Classic just so as to piggyback on the facilities for concurrent access provided by the database system. The remote interface proposal mentioned above provides a limited form of trans- actions, basically allowing clients to batch up a collection of updates to a knowledge base and apply them all at once as an atomic transaction. This interface, however, does not provide any mechanism to abort transactions or to provide a local view of the knowledge base during the execution of a transaction. At least one other knowledge representation system has dealt with the notion of concurrent access by leveraging the notion of sessions. Ontolingua allows users to log into a particular session that may already be opened by a previous user. All users logged into the same session see the same version of the knowledge base. A more sophisticated approach to concurrent access and knowledge base editing is embodied in OntoBuilder [Das et al., 2001]. In this system, users can not only do something similar to sharing a session, but the implementation also facilitates collaboration through dialog with other users currently signed on to the same ontology and allows locking of concepts for updates.

7.3.4 Platforms

Another important access aspect concerns the platforms on which the knowledge representation system runs. This encompasses not only the machines and operating systems, but also the language in which the system is written (if it is visible), the version of the libraries that the system uses, and the mechanism for linking to the system. Many applications have needs for a particular operating system or language, and cannot utilize tools not available in this context. Some Description Logics like Classic have been made available on a reasonable number of platforms. The underlying language of a member of the Classic family is visible, not just because of the API which is, of necessity, language-speciﬁc, but also because programmers can write functions to extend the expressive power of the system, and these functions have to be written in the underlying language of the system

Classic is currently available in two different languages: Lisp and C++. The C++ member is the more recent, and the reimplementation used C++ precisely to make Classic available for a larger number of applications. This was done even though C++ is not the ideal language in which to write a representation system. The members of the Classic family have also been written in a platform- independent manner. This has required not using some of the nicer capabili- ties of the underlying language or of particular operating systems. For example, NeoClassic does not use C++ exceptions, partly because few C++ compilers supported this extension to the language. Lisp-Classic runs on various Lisp im- plementations and on various operating systems, including most versions of Unix, MacOS, and Windows. NeoClassic runs under four C++ compilers and on both Unix and Windows NT. With the inﬂuence of the web and more distributed development environments, it may be expected that more Description Logics may be made available on multiple platforms and may be integrated into more hybrid environments. One example of another knowledge representation system that found a need to do this is the Chi- maera Ontology Evolution Environment [McGuinness et al., 2000b]. This system has been connected to Ontolingua for ontology editing and simple inference, a Lisp-based reasoner for some diagnostics, and a hybrid Java-based reasoning en- vironment that supports both ﬁrst-order logic reasoning as well as special-purpose reasoning for the DAML+OIL Description Logic.

7.4 Advanced human access

7.4.1 Explanation

Many research areas which focus on deductive systems (such as expert systems and theorem proving) have determined that explanation modules are required for even simple deductive systems to be usable by people other than their designers. Description Logics have at least as great a need for explanation as other deductive systems since they typically provide similar inferences to those found in other ﬁelds and also support added inferences particular to Description Logics. They provide a wide array of inferences [Borgida, 1992b] which can be strung together toprovidecomplicatedchainsofinferences.Thusconclusionsmaybepuzzlingeven to experts in Description Logics when application domains are unfamiliar or when chains of inference are long. Additionally, naive users may require explanations for deductions which may appear simple to knowledgeable users. Both sets of needs became evident in work on a family of conﬁguration applications and necessitated an automatic explanation facility.

The main inference in Description Logics is subsumption – determining when membership in one class necessitates membership in another class. For example, Person is subsumed by Mammal since anything that is a member of the class Person must be a member of the class Mammal. Almost every inference in Description Logics can be rewritten using subsumption relationships and thus subsumption explanation forms the foundation of an explanation module [McGuin- ness and Borgida, 1995]. Although subsumption in most implemented Description Logics is calculated procedurally, it is preferable to provide a declarative presentation of the deduc- tions because a procedural trace typically is very long and is littered with details of the implementation. A declarative explanation mechanism which relies on a proof-theoretic representation of deductions may be used as a framework. Such a mechanism has been speciﬁed [McGuinness, 1996] and implemented for Classic and later speciﬁed for ALN [Baader et al., 1999a]. All the inferences in a DL system can be represented declaratively by proof rules which state some (optional) antecedent conditions and deduce some consequent relationship. The subsumption rules may be written so that they have a single subsumption relationship in the denominator. For example, if Person is subsumed by Mammal, then it follows that something that has all of its children restricted to be Persons must be subsumed by something that has all of its children restricted to be Mammals. This can be written more generally (with C representing Person, D representing Mammal, and R representing child) as the ∀restriction rule below:

All restriction ⊢C ⊑D ⊢∀R.C ⊑∀R.D .

Using a set of proof rules that represent DL inferences, it is possible to give a declarative explanation of subsumption conclusions in terms of proof rule applica- tions and appropriate antecedent conditions. This basic foundation can be applied to all of the inferences in Description Logics, including all of the inferences for handling constraint propagation and other individual inferences. There is a wealth of techniques that one can employ to make this basic approach more manageable and meaningful for users [McGuinness and Borgida, 1995; McGuinness, 1996]. Expressive DL-based systems may require a large number of proof rules. If one is interested in limiting both explanation implementation work and also the size of explanations, it is be beneﬁcial to prune the number of inferences to be explained. In one conﬁguration family of applications [McGuinness and Wright, 1998b] the help desk logs were analyzed to determine the most frequent questions that related to explanation. These inferences included inheritance (if A is an instance of B and B is a subclass of C, then A “inherits” all the properties of C), propagation

(if A ﬁlls a role R on B, and B is an instance of something which is known to restrict all of its ﬁllers for the R role to be instances of D, then A is an instance of D), rule ﬁring (if a is an instance of E and E has a rule associated with it that says that anything that is an E must also be an F, then a is an instance of F), and contradiction detection (e.g., I cannot be an instance of something that has at least 3 children and at most 2 children). In the initial development version, expla- nation was only provided for these inferences in an effort to minimize development costs, resulting in a quite useful explanation mechanism with much less effort than a full explanation system. (The two current implementations of explanation in Classic contain complete explanation.) One demonstration system [McGuinness et al., 1995] incorporates special handling for the most heavily used inferences pro- viding natural language templates for presentations of explanations aimed at lay people.

7.4.2 Error handling

Since one common usage of deductive systems is for contradiction detection, han- dling error reporting and explanation is critical to usability. This usage is com- mon in applications where object descriptions can easily become over-constrained. For example, in the home theater system application, one could generate a non- contradictory request for a high quality stereo system that costs under a certain amount. The description could later become inconsistent as more information is added. For example, a required high quality, expensive speaker set could violate a low total price constraint. Understanding evolving contradictions such as this challenges many users and leads them to request special error explanation sup- port. Informal studies with internal users and external academic users indicate that adequate error support is crucial to the usability of the system. Error handling could be viewed simply as a special case of inference where the conclusion is that some object is found to be described by a special concept typically called bottom or nothing. For example, a concept is incoherent if it has conﬂicting bounds on some role:

Bounds Conﬂict ⊢C ⊑(⩾m r) ⊢C ⊑(⩽n r) n < m ⊢C ⊑⊥ .

If an explanation system is already implemented to explain proof-theoretic infer- ence rules, then explaining error conditions is almost a special case of explaining any inference. There are two issues that are worth noting, however. The ﬁrst is that information added to one object in the knowledge base may cause another object to become inconsistent. In fact, information about one object may impact another series of objects before a contradiction is discovered at some distant point

along an inference chain. Typical DL systems require consistent knowledge bases; thus whenever they discover a contradiction, they use some form of truth main- tenance to revert to a consistent state of knowledge, removing conclusions that depend on the information removed from the knowledge base. Thus, it is possi- ble, if not typical, for an error condition to depend upon some conclusion that was later removed. A simple minded explanation based solely on information that is currently in the knowledge base would not be able to refer to these removed conclusions. Thus, any explanation system capable of explaining errors will need access to the inconsistent state of the knowledge base as well as to its current state. Because of the added complexity resulting from the distinction between the cur- rent (consistent) state and the inconsistent state of the knowledge base and because of the importance of error explanation, we believe system designers will want to support special handling of error conditions. For example, in a number of situations surveyed, users typically asked for explanations of a particular object property or relationships between objects. Under error conditions, users had more trouble iden- tifying an appropriate query to ask. This suggests that special error support should be introduced. In Classic, for example, an automatic error explanation option is generated upon contradiction detection. This way the user requires no knowledge (other than the error explanation command name) in order to ask for help. Another issue of importance to error handling is the completeness or incomplete- ness of the system. If a system is incomplete then it may miss deductions. Thus, it is possible that an object is inconsistent—if all of the logically implied deductions were to be made—but, because the system is incomplete, it misses some of these deductions and thus the object remains consistent in the knowledge base. In order for users to be able to use a system that is incomplete, they may need to be able to explain not only error deductions but deductions that were missed because of incomplete reasoning. An approach that completes the reasoning with respect to a particular aspect of an object is described in [McGuinness, 1996, Chapter 5]. Given the completed information, the system can then explain missed deductions.

7.4.3 Pruning

If a knowledge representation system makes it easy to generate and reason with complicated objects, users may ﬁnd naive object presentations to be much too complex to handle. In order to make a system more usable, there needs to be some way of limiting the amount of information presented about complicated objects. For example, in the stereo demonstration application, a typical stereo system description may generate four pages of printout. The information contained in the description may be clearly meaningful information such as price ranges and model numbers for

components but it may also contain descriptions of where the component might be displayed in the rack and which superconcepts are related to the object. In certain contexts it is desirable to print just model numbers and prices, and in other contexts it is desirable to print price ranges of components. We believe it is critical to provide supportforencodingdomainindependentanddomaindependentinformationwhich can be used along with contextual information to determine what information to print or explain. As one example, we consider some of the knowledge bases written for the DARPA High Performance Knowledge Base project. This project includes a very general upper level ontology with many slots deﬁned on many of the classes. Most objects in the system inherit a large number of slots from upper ontology classes and it is not uncommon for normalized objects to have hundreds of slots associated with them even though they only have a couple of properties deﬁned on them in the local knowledge bases. Knowledge representation systems faced with information overload need to take some approach to ﬁltering. One of the simplest approaches allows a speciﬁcation on roles concerning whether they should be displayed on objects or not. This may work for homogeneous knowledge bases where role information is uniformly inter- esting or uninteresting. Our experience is, however, that context needs to be taken into account in more heterogeneous knowledge base applications. One example implementation that allows context and domain dependent information to be con- sidered along with domain independent information is implemented in Classic. A meta-language is deﬁned for describing what is interesting to either print or explain on a class by class basis. Any subclass or instance of the class will then inherit the meta-description and thus will inherit “interestingness” properties from its parent classes. The meta-language essentially captures the expressive power of the base Description Logic with some carefully chosen epistemic operators to allow contex- tual information (such as known ﬁllers or closed roles) to impact decisions on what to print. The meta-language has been used to reduce object presentation and explanation by an order of magnitude in at least one application [McGuinness et al., 1995]. This reduction was required for the application to be able to include object presentation. The algorithms of the basic approach are included in [McGuinness, 1996]; the theory of a generalized approach is presented in [Borgida and McGuinness, 1996] and further analyzed in [Baader et al., 1999a].

7.4.4 Knowledge acquisition

If an application is expected to have a long life-cycle, then acquisition and main- tenance of knowledge become major issues for usability. There are two kinds of knowledge acquisition which are worth considering: (i) acquisition of additional

knowledge once a knowledge base is in place, and (ii) acquisition of original do- main knowledge. A complete environment will address both concerns; however, the original acquisition of knowledge is a much more general and difﬁcult problem and, conveniently enough, is not the activity that many users will ﬁnd themselves doing repeatedly while maintaining a project. We observe that with knowledge of the domain and appropriate analysis of evolution, it is possible to build a knowledge evolution environment suitable for non-experts to use for extending knowledge bases. One such project considered the evolution support environment for conﬁgurators. The speciﬁc domain and usage patternswereanalyzed,anditwasfoundthatonlycertainclasseshadnewsubclasses added to them as product knowledge evolved. It was also found that instances were typicallypopulatedinparticularpatterns.Aspecialpurposeinterfacewasdeveloped for a family of conﬁgurators that exploited these ﬁndings and supported new conﬁg- urator application development by non-experts [McGuinness and Wright, 1998b]. Also, in related work, Gil and Melz [1996] have analyzed planning-based uses of another DL-based system that systematically supports knowledge base evolution with respect to the known plan usage. A more general problem that does not rely on domain or reasoning knowl- edge has been addressed in the editor work [Paley et al., 1997] for the general frame protocol and also in editor work for collaborative generation and mainte- nance of ontologies by non-experts in the Collaborative Topic Builder component of FindUR [McGuinness, 1998] and recently in Chimaera work [McGuinness et al., 2000b] for merging, analyzing, and maintaining ontologies. The general work, of course, is broader yet shallower with respect to reasoning implications. In the FindUR collaborative topic builder environment, simple hierarchies of node names (with role ﬁller and value restriction information) are used to support query expansion to provide more intelligent web searching. In order to deploy this broadly, a web-based distributed ontology editor was required to allow non-experts to in- put, modify, and maintain background ontologies. The basic functionality for this interface follows the same requirements speciﬁed in Section 7.2 although this par- ticular implementation limited some of the interface speciﬁcations according to expected usage patterns. For example, in the medical deployments [McGuinness, 1999] of FindUR, it was expected that all of the roles that were to be used had been deﬁned and thus pulldown lists of these roles were hardcoded into the inter- face and new role speciﬁcation was not one of the exposed functionalities in the GUI. FindUR also allows importing of seed ontologies and supports contradiction detection from ontology input. Chimaera’s environment takes the analysis task to a much more detailed level and it provides a number of different ways of detect- ing not only explicit contradictions but also possible contradictions and possible term merges

7.5 Other technical concerns

The computer science concerns that affect the suitability of a knowledge represen- tation system have to do with the behavior of the system as a computer program or routine, ignoring its status as a representer of knowledge. The most-studied as- pect of this collection of concerns has to do with the computational analysis of the basic algorithms embodied in the system, in particular their worst-case complexity. Because this worst-case complexity has been so well studied, we will not say any- thing about it further, except to state that it is important in determining the suitability of a knowledge representation system for particular task, notably tasks that need a performance guarantee.

7.6 Public relations concerns

Researchers sometimes underestimate the varied public relations aspects involved with making a system usable. Barriers to usability come in many forms: potential users who are unaware of a system’s existence will not use it; potential users who do not understand how a system can meet the their needs are unlikely to use it; potential users who do not have enough understanding to visualize an abstract solution to their problem using a new system are unlikely to depend on the new system over tools they understand and can predict; and ﬁnally potential users who have a limited set of approved tools which does not include the new system are unlikely go to the effort of getting the new system approved for their internal use. In order to address these issues, DL system designers need to devise ways to make their systems known to likely users, educate those users about the possible uses, provide support for teaching users how to use them for some standard and leverageable uses, and either obtain approval for their systems or provide ammunition for users to gain approval. In experiences with Classic, the following tools have been employed to over- come the above stated barriers to usability. Beyond the standard research papers, users demand usage guidelines aimed at non-PhD researchers. A paper that provides a running (executable) example on how to use the system is most desirable: an example is [Brachman et al., 1991]. That paper also tries to provide guidance on when a DL-based system might be useful, what its limitations are, and how one might go about using one in a simple application. That paper was used as the basis of a tutorial on building ontologies in other knowledge representation systems including Prot´eg´e and Ontolingua [Noy and McGuinness, 2000]. A demonstration system is also of great utility as it helps users understand a simple reasoning paradigm and provides a prototyping domain for showing off

Classic project a number of demonstration systems were developed, including a simple application that captures “typical” reasoning patterns in an accessible domain. This one system has been used in dozens of universities as a pedagogical tool and test system. While this application was appropriate for many students, an application more closely resembling some actual applications was needed to (i) give more meaningful demonstrations internally and to (ii) provide concrete suggestions of new functionality that developers might consider using in their applications. This led to a more complex application with a fairly serious graphical interface [McGuinness et al., 1995]. Both of these applications have been adapted for the web.3 It was only when a demonstration system that was clearly isomorphic to the developer’s applications was available that there could be effective providing of clear descriptions and implemented examples of the functionality that we believed should be incorporated into development applications. Interactive courses are also of beneﬁt in training potential users in how to use a DL-based knowledge representation system. Several courses [McGuinness et al., 1994; Abrahams et al., 1996] on how to use Classic have been developed, in- cluding one from a university for course use, which includes a set of ﬁve running assignments to help students gain experience using the system. Other general DL courses can be found on the DL web site at http://www.dl.kr.org/. For a system to be used in the business community, it has to satisfy their demand for common standard implementation languages, reasonable support, and standard platform toolkits. Some DL implementations, such as Classic, attempted to meet this need by providing an implementation in C while still maintaining the Lisp research version. This later proved problematic to maintain and the decision was made to provide an implementation in C++ that was to meet both developers’ and implementers’ needs. Interestingly enough, years later, it is the Lisp version that appears to be most heavily used. More details of the evolution of the usability of that system can be found in [Brachman et al., 1999].

7.7 Summary

Although a knowledge representation system must have sufﬁcient expressive power and appropriate computational complexity to be considered for use in applications, there are many other issues that also determine whether it will be used. These issues involve access to the knowledge stored in the system, such as explanation and presentation of the knowledge, other technical issues, such as efﬁciency and programming interfaces, and non-technical issues, such as publicity and demos. If these issues are not addressed appropriately, a knowledge representation system will not be used in real applications.

8

Description Logic Systems

RALF M ¨OLLER VOLKER HAARSLEV

Abstract

This chapter discusses implemented DL systems that have played or play an im- portant role in the ﬁeld. It ﬁrst presents several earlier systems that, although not based on Description Logics, have provided important ideas. These systems include Kl-One, Krypton, Nikl, and Kandor. Then, successor systems are described by classifying them along the characteristics discussed in the previous chap- ters, addressing the following systems: Classic (“almost” complete, fast); Back, Loom (expressive, incomplete); Kris, Crack (expressive, complete). Finally, a new optimized generation of very expressive but sound and complete DL systems is also introduced. In particular, we focus on the systems Dlp, Fact, and Racer and explain what they can and cannot do.

8.1 New light through old windows?

In this chapter a description of the goals behind the development of different DL systems is given from a historical perspective. The description of DL systems allows important insights into the development of the knowledge representation research ﬁeld as a whole. The design decisions behind the well-known systems which we discuss in this chapter not only reﬂect the trends in different knowledge representation research areas but also characterize the point of view on knowledge representation that different researchers advocate. The chapter discusses general capabilities of the systems and gives an analysis of the main language features and design decisions behind system architectures. The analysis of current systems in the light of a historical perspective might lead to new ideas for the development of even more powerful DL systems in the future. References to previous descriptions of DL systems (e.g., in [MacGregor, 1991a; Woods and Schmolze, 1992; Horrocks, 1997a])orpublicationsonDLtheorythatalsocontaindiscussionsaboutDLsystems

(e.g., [Patel-Schneider, 1987a; Nebel, 1990a; Schmidt, 1991]) are included where appropriate. For references to other systems not mentioned here see also [Woods and Schmolze, 1992] and [Nebel, 1990b, pp. 46f., pp. 63f.]. Basic concept and role constructors have already been introduced in Chapter 2 (see also the Appendix for a summary of syntax and semantics of DL construc- tors). However, before starting the discussion about DL systems it is appropriate to introduce some notation for language constructors in order to keep this chapter self-contained. It is assumed that the reader is familiar with the basic Description Logics AL and ALC. In a similar way as in Chapter 2, further language features are indicated by different letters. The letter N is used for simple number restrictions and the letter Q is used for qualiﬁed number restrictions. H is used for role hierarchies with multiple parents whereas h is used for role hierarchies with single inheritance only. In some languages, no role hierarchies but role conjunctions are provided. Role conjunctions are indicated with the letter R in the following. In addition, the abbreviations F and f are used for features with and without equality for feature chains (i.e., agreements), respectively. The index R+ is used to indicate support for transitive roles. Language constructors for an extensional speciﬁcation of concepts using nominals (or individuals) are denoted by the letters O and B (see Chapter 2 or the Appendix for details). If inverse roles are supported by a DL system, this is indicated either by a superscript −1 or by the letter I. The latter variant is used in order to allow a convenient pronunciation of the DL language.

8.2 The ﬁrst generation

Inspired by research on human cognitive behavior, proposals for knowledge repre- sentation languages were ﬁrst discussed in the late 1960s. For example, [Quillian, 1967] is one of the ﬁrst publications of the languages called “semantic networks” (see also [Quillian, 1968]). Originally, semantic network formalisms were seen as alternatives to ﬁrst-order logic. In a similar spirit, [Minsky, 1981] introduced the initial notion of a frame system. The motivation of these representation formalisms was to mimic human reasoning in the sense of achieving “cognitive adequacy”. Thus, the idea was to support problem solving with appropriate representation structures that somehow “resemble” representation structures assumed in human information processing. The exploitation of inheritance was a predominant idea in frame systems. The speciﬁcation of knowledge bases should be simple and the use of the representation structures should be intuitive (“epistemological adequacy”). However, as pointed out by [Woods, 1975], it was not at all simple to specify what an inference system was supposed to actually compute. The late 1970s saw initial research on the relation of frame systems and ﬁrst-order logic [Hayes, 1977; 1979] which revealed that some aspects of frame based systems can be considered as

special “instantiations” of ﬁrst-order reasoning. Hayes argued that frame-based reasoning was not an entirely new way of knowledge representation with particular advantages over ﬁrst-order reasoning. Speciﬁc features of frame systems beyond ﬁrst-order reasoning (e.g., defaults) were not very well understood at that time. The consequence of these publications was that many researchers no longer considered frame systems and semantic network systems as possible alternatives to logic-based approaches. The criticisms of early frame systems and semantic network formalisms stimu- lated research on the development of mathematical structures and techniques for deﬁning the semantics of representational constructs supported by different rep- resentation languages. For instance, in early frame systems there was no clear distinction between constructs for representing “generic” knowledge about sets of individuals and knowledge about “speciﬁc” individuals. Furthermore, frames were often used as data structures in procedural programs. For these programs a formal speciﬁcation of what they were expected to compute was rarely provided. Rather than interpreting frame structures as data structures, [Woods, 1975] suggested using a formal semantics to clearly specify what is to be computed by inference algorithms.

Kl-One

Inspired by critics such as [Woods, 1975], Brachman started to develop a new representation system (called Kl-One) that inherently included the notion of inferring implicit knowledge from given declarations [Brachman, 1977b; 1979]. Although the initial approach was not logic-based, Kl-One started the era of logic- based representation systems which can be used to formalize application problems as inference problems over the constructs supported by the representation language. One of the prevailing inference patterns is centered around inheritance [Brachman, 1983]. The ﬁnal report on the Kl-One language is published in [Brachman and Schmolze, 1985]. One of the core ideas behind Kl-One as a representation language for the “epis- temological level” resulted from problems with languages offering built-in primi- tives for general representation purposes (e.g., CD theory [Schank, 1975]). Rather than providing general built-in primitives, in Kl-One, for a speciﬁc representation problem a set of adequate primitives was deﬁned by the user. The primitives were denoted by so-called concept names. The next idea was to use concept-forming op- erators to build new concepts from basic concepts. These compound concepts were also referred to as “concepts”, “concept terms” or “concept descriptions”. Generic concepts were intended to denote classes of individuals and individual concepts were intended to denote individuals (see also [Nebel 1990a p 42]) Individuals

were related by so-called roles which, in turn, could be primitive roles (role names) or roles described with role constructors [Brachman and Schmolze, 1985]. In Kl-One, concepts and roles are the building blocks for representational pur- poses. The main idea behind concepts and concept constructors in Kl-One is that the meaning of a concept is derived only from the meaning of its superconcepts and other restrictions associated with a concept [Brachman and Schmolze, 1985]. A Kl-One generic concept consists of a set of superconcept names, a set of role descriptions, and a set of structural descriptions [Patel-Schneider, 1987a, pp. 58f.].1

Roles can be viewed as potential relationships between an individual of a certain class and other individuals in the world [Nebel, 1990a, p. 42]. Role descriptions could be either restrictions or differentiations. The former restricted the class of permitted ﬁllers (value restrictions) or the number of ﬁllers (number restrictions). Role differentiations were used to describe a subrole with possible value or number restrictions. So-called structural descriptions were used to state relationships between the ﬁllers of roles (see also [Patel-Schneider, 1987a, pp. 58f.]). Descriptions for individual concepts consisted simply of a set of values for roles plus a set of generic concepts. Individual concepts were seen as instances of these generic concepts, i.e., an individual concept had to satisfy all restrictions (and differentiations) inherited by the generic concepts. On the other hand, individual concepts were also subsumed by their generic concepts. However, the semantics of individuals was never completely worked out (see [Schmolze and Brachman, 1982, pp. 23–31] cited after [Nebel, 1990a, p. 64]). The representation structures offered by Kl-One were similar to those of- fered by semantic networks or frames. Although, initially, the structures offered by Kl-One were called “structural inheritance networks” [Brachman, 1977b; 1979], in [Brachman and Levesque, 1984] the authors talk of “frame structures”.2

In accordance with [Nebel, 1990a, p. 45] we argue that in contrast to, e.g., CD theory [Schank, 1975], providing a (large) set of primitive representation structures (names) for all kinds of representation purposes was not the development goal of Kl-One. As Nebel points out [Nebel, 1990a, p. 45], more important and unique to Kl-One is the core idea of proving ways to specify concept deﬁnitions, i.e., the ability to let a knowledge engineer declare the relation of “high-level concepts” to “lower-level primitives”.

1 Note that, in Kl-One-like languages, there are speciﬁc syntactic constructs for specifying superconcepts. These speciﬁc constructs are no longer present in logic-based concept languages of the 1990s. 2 There are large differences between frame systems and DL systems: if for i the restriction ∀R.C holds, and we set i into relation to j via the role R, then every Kl-One-based system concludes that j is an instance of C. In standard frame-based systems, j can only be set into relation to i via R if it is already known that j is an i t f C Oth i i f t t l t i i i d i i l d

A concept deﬁnition was an assignment of a (unique) name to a concept term. In Kl-One the well-known distinction between the two kinds of concept deﬁ- nitions, deﬁnitions with necessary and sufﬁcient conditions and deﬁnitions with only necessary conditions (so-called primitive deﬁnitions), was investigated for knowledge representation purposes for the ﬁrst time.3 In the original approach no cycles were allowed in the set of concept deﬁnitions.4 The most important con- sequence of the introduction of concept deﬁnitions with necessary and sufﬁcient conditions was that reasoning about the relationships between concepts became important. In Kl-One there is still the notion of a “told subsumer” syntactically being explicitly mentioned in a list of so-called superconcepts but, according to the semantics, there are also additional computed subsumers which are concept names (direct subsumers or direct superconcepts). Note that inferences in Kl-One were based on the open-world assumption. Hence, unlike frame systems, where the names as superconcepts are always given explicitly, Kl-One introduced the idea that the set of direct superconcepts (i.e., concept names) for a given concept must be inferred. Direct superconcept–subconcept relationships (also called parent–children rela- tionships) are dependent on the concept terms used in the deﬁnitions of a TBox. In particular, the notion of deﬁned concepts (with necessary and sufﬁcient condi- tions) led to the idea of classifying a TBox. The idea was to compute the sub- sumption hierarchy (sometimes also called “inheritance hierarchy”) of parents and children for each concept name mentioned in a TBox during a so-called classiﬁcation process. The intention was that a model for a speciﬁc application domain could be veriﬁed by a knowledge engineer based on the subsumption hierarchy. Considering the subsumption hierarchy, i.e., the lattice of direct su- perconcepts, the idea was also that concept terms could be automatically “in- serted” between named concepts in the hierarchy. Hence, concept terms could be set into relation to “pre-deﬁned” concept names (and, indirectly, other concept terms). This feature has been used in many projects for implementing application functionality. The ﬁrst development of an algorithm for computing the subsumption hierarchy of a TBox (the “classiﬁer”) is described in [Schmolze and Lipkis, 1983]. Another inferencecomponentcalled“realizer”computesforeachindividualmentionedinan ABox the most speciﬁc atomic concepts (or concept names) of which the individual

3 In the literature, some authors use the word “deﬁnition” as a synonym for concept terms themselves (e.g., [Schmidt, 1991], see also [Woods, 1991, p. 65]). In this case, “primitive” concepts with only necessary conditions were introduced with a speciﬁc marker to be used in concept terms. 4 The semantics of cycles was analyzed in [Baader, 1990b; 1991; Nebel, 1990a; 1991]. The so-called descriptive semantics provided many advantages over so-called ﬁxed point semantics. For details see [Nebel, 1990a]. One of the ﬁrst publications of an expressive Description Logic supporting cyclic axioms with a descriptive semantics and a sound and complete calculus is [Buchheit et al., 1993a]. Cyclic axioms are usually not considered as t d ﬁiti

is an instance. One of the ﬁrst algorithms for computing the realization of an ABox is described in [Mark, 1982]. Initial Kl-One systems were implemented in Interlisp [Lipkis, 1982] and Smalltalk [Fikes, 1982]. The Consul project [Kaczmarek et al., 1986] was one of the ﬁrst projects in which classiﬁer and realizer inference services were exploited. First investigations about defaults and exceptions were published in [Brachman, 1985]. Nowadays, the semantical theory of defaults in Description Logics is much clearer, see [Baader and Hollunder, 1992; 1993; Baader and Schlechta, 1993; Padgham and Zhang, 1993; Padgham and Nebel, 1993; Baader and Hollunder, 1995a; 1995b; Donini et al., 1997b]. At the ﬁrst Kl-One workshop [Schmolze and Brachman, 1982] it became clear that the informal speciﬁcation of the semantics of Kl-One concept and role con- structors led to serious problems. The development of the classiﬁer [Schmolze and Lipkis, 1983] was based on the intuitive meaning of the Kl-One formalism [Nebel, 1990a, p. 46]. Attempts to logically reconstruct the representation con- structs, e.g., [Schmolze and Israel, 1983; Israel and Brachman, 1984], resulted in a deeper understanding of the formalism. Given the formal semantics, implemented algorithms for classiﬁcation and realization were shown to be incomplete. Later investigations revealed that Kl-One (with the formal semantics given in the logi- cal reconstruction approaches) is undecidable (e.g., this holds for the combination of conjunction, value restrictions and role-value-maps [Schmidt-Schauß, 1989]). In [Brachman and Levesque, 1984] the ﬁrst thoughts about tractability of sub- sumption for sublanguages are discussed. Terminological reasoning with concept deﬁnitions even for sublanguages with low expressiveness were shown to be in- herently intractable in the worst case [Nebel, 1990b, p. 28, pp. 71f.]. Proposals for a semantics based on many-valued logics (e.g., [Patel-Schneider, 1986; 1987a; 1987b; 1989a]) ensure tractable algorithms concerning concept consistency rea- soning but also result in a weak expressiveness: many intuitive inferences are not sanctioned by this semantics (see also [Nebel, 1990a]). Another result of [Schmolze and Brachman, 1982] was that the semantics of individual concepts was not quite clear (e.g., concerning coreference and unique name assumption). Thus, at the ﬁrst Kl-One workshop [Schmolze and Brachman, 1982], the notions of a hybrid reasoning system consisting of a TBox (a set of concept deﬁnitions) and an ABox (a set of assertions concerning individuals) were made more precise. The change of the view on Kl-One spelled out in [Schmolze and Brachman, 1982, pp. 8–17] (see also [Nebel, 1990a, p. 46]) can be summarized as follows: It is not the names of representation structures that are important but the functionality, i.e., the declaration and inference services which the system provides. It was ﬁrst pointed out that inferences have to be formally deﬁned based on the semantics of the representation formalism This view led to the development of the

functional view of knowledge representation as pursued with the development of the system Krypton.

Krypton

The knowledge representation system Krypton [Brachman et al., 1983a; 1983b; 1985] can be seen as the ﬁrst attempt at deﬁning a new language of the Kl-One family with a formal, Tarskian semantics. Furthermore, the goal was to overcome the problems with individual concepts in Kl-One [Nebel, 1990a, p. 63]. The hy- brid representation approach with a TBox and an ABox was ﬁrst implemented in the Krypton system (see also [MacGregor, 1991a, p. 391]). As in Kl-One, the distinction between primitive and deﬁned concepts and the computation of the most speciﬁc atomic concepts which instantiate individuals is one of the core ideas of Krypton. Krypton offered a concept language with low expressiveness. While the initial approach [Brachman et al., 1983b] was too expressive to be tractable (see also [MacGregor, 1991a, p. 390]), in a revised version [Brachman et al., 1985] the concept constructors of Krypton were deﬁned as conjunction, value restrictions and role chains. Thus, subsumption checking was polynomial [Patel-Schneider, 1987a, p. 75]. For the ABox a full-ﬂedged resolution-based FOPL theorem prover [Stickel, 1982] was proposed, i.e., the ABox reasoner of Krypton was incomplete. Another perspective is that Krypton started with a ﬁrst-order logic theorem prover and augmented it with a special-purpose inference system for terminological rea- soning to cut out some of the combinatorial search [Vilain, 1985]. Krypton can be regarded as one of the ﬁrst efforts in combining knowledge representation and theorem-proving techniques but was not used for industrial applications [Nebel, 1990a, pp. 63f.]. Rather than dealing with speciﬁc representation structures and operations on them, Krypton offers a so-called “functional approach”. Using the interface func- tions “tell” and “ask”, a knowledge base can be deﬁned and queries can be answered about it. In this sense, a “functional approach” means that a formal representation system does not necessarily have to maintain, for instance, frame structures, the subsumption hierarchy, or even an ABox as a graph structure. If, for internal imple- mentation purposes, graph structures are indeed used, they are nevertheless hidden from the user in order to avoid “procedural” operations being carried out with internal record structures. Arbitrary procedural operations are usually not related to the semantics of the representation formalism, so that, in this case, it is hard to characterize what is actually represented and what is computed as solutions to inference problems. Thus, the focus of Krypton was not on the structures to be maintained by the system but was centered around the question about what the

system should do for the user, i.e., what services should be made available. In other publications this idea was described as the “knowledge level” [Newell, 1982]. In Krypton, inference services for concept terms are checks for concept consistency, disjointness, and subsumption. For a TBox, the most speciﬁc subsumers (parent– children relation) can be computed, whereas for an ABox, consistency, instance checking, realization (direct types) and instance retrieval are offered as inference services. Krypton pioneered the idea that the user should only know, at some level not dependent on implementation details, what questions the system is ca- pable of answering and what operations are permitted that allow new information to be provided to it. For instance, it is not important how the association between an individual and a certain role ﬁller is actually represented in terms of memory arrangements (called the symbol level). What counted for the underlying imple- mentation was what operations must be supported in order to answer queries at the semantical level. This view about Kl-One-based representation systems was one of the major achievements of the Krypton project.

Nikl, Penni, Kl-Two

At the same time as Krypton, the knowledge representation system Nikl was developed as a successor of Kl-One. Nikl was a New Implementation of Kl- One [Schmolze and Israel, 1983; Schmolze, 1985; Schmolze and Mark, 1991]. As discussed in [Kaczmarek et al., 1986], in Nikl, roles are also ordered with respect to subsumption (see also [Schmidt, 1991, p. 13]). The assertional components of Kl-One were initially discarded in the Nikl system (see the Nikl user guide [Robins, 1986]). Compared to the initial Kl-One implementation, the algorithms in the Nikl classiﬁer were faster in the average case because “obvious” information was exploited to a larger degree (see [MacGregor, 1988, p. 405] or [MacGregor, 1991a, p. 392]). However, the subsumption algorithm of Nikl was incomplete and it was hard to characterize which inferences were omitted [Schmolze and Israel, 1983] (see also [Patel-Schneider, 1987a, p. 74]). Later, an assertional reasoning component was added with the system Penni which is based on RUP [McAllester, 1982]. The resulting system was called Kl- Two [Vilain, 1985] (see also [Schmidt, 1991, p. 15]). In Kl-Two a propositional reasoner with equality (the Penni subsystem) was augmented with a so-called quantiﬁcational reasoning component (the Nikl subsystem). For the propositional part in the Penni component, incremental additions and retractions were supported due to the facilities provided by RUP. However, as shown in [Patel-Schneider, 1989b] the concept language of Nikl contained concept and role constructs that rendered the satisﬁability problem for Nikl concept terms undecidable (see also [Schmidt Schauß 1989])

Concerning hybrid reasoning, i.e., the systematic integration of TBox and ABox reasoning, there were shortcomings as well. Because in RUP different constants do not necessarily denote different objects, the unique name assumption was not built into the assertional component Penni. Thus, number restrictions imposed by Nikl concepts often did not have the intended effects concerning hybrid reasoning. Other sources of incompleteness were pointed out (see also the analysis of “in- ferential gaps” in [Nebel, 1990a, pp. 63f.]). The research on the Kl-Two system demonstrated that hybrid reasoning is not just a matter of integrating reasoning sub- systems at the software level. Hybrid reasoning requires a dedicated architecture implementing a sound and complete calculus which, in turn, can be developed only after a deep analysis of the semantics of the representation constructs. Neverthe- less, the principal idea of exploiting subsumption information for resolution-based ﬁrst-order reasoning has been integrated into many theorem-proving systems.

Kandor

Research on Kandor [Patel-Schneider, 1984] was inﬂuenced by the Krypton architecture and the performance problems of the Nikl approach. The goal of Kandor was to increase the expressive power of the terminological representation component in such a way that an efﬁcient subsumption algorithm could be de- veloped. Basically, Kandor supported conjunction, value restriction and number restrictions as concept-forming operators. In minimum number restrictions, range- restricted roles could be used (hence, qualiﬁed minimum number restrictions were allowed, see also [Patel-Schneider, 1987a, p. 76]). In order to provide effective infer- ence algorithms (e.g., for information retrieval scenarios) in the Kandor approach the expressiveness of the assertional component was cut down to a representation system comparable to a database (without revision mechanisms). Subsumption in Kandor was shown to be conp-complete (see [Nebel, 1988] and [Nebel, 1990a, p. 90] for details). The initially proposed subsumption algorithm with polynomial runtime must have been incomplete. Kandor was called a frame-based system (which might be reasonable because of the expressiveness offered by the ABox language). A frame in Kandor was essentially a speciﬁcation of conditions for describing how an individual can be an instance of it (in terms of superframes and restrictions). Kandor supported deﬁned frames and primitive frames in the spirit of Kl-One. The system adopted the “small interfaces” approach of Krypton, i.e., models were built using the declaration interface (tell interface), and application services were realized with the query interface (ask interface). Although called a frame system, frames were not treated as record structures to be manipulated by procedural programs. The authors of Kandor argued for a small knowledge representation system that could be used

as part of larger systems with different subcomponents. The main achievement of Kandor was the introduction of a small-can-be-beautiful approach which, ﬁnally, led to the design of the system Classic which will be discussed in detail in the next section.

8.3 Second generation Description Logic systems

Whereas the prototypical implementations of ﬁrst generation systems were used to study knowledge representation problems, second generation DL systems have been more extensively used in serious applications. The implementations discussed in this section are not only not prototypes but are much more stable. In addition, since the beginning of the 1990s, the systems have been called DL systems. We ﬁrst discuss systems for (almost) tractable languages based on (almost) complete algorithms and investigate systems for expressive Description Logics afterwards.

Classic

ThebasicClassicsystemsupportedthelogicALNFh−1 withTBoxesandABoxes plus facilities for dealing with numbers [Borgida et al., 1989]. We use the lowercase letter h to indicate that Classic supports role inclusion but not role conjunction, i.e., Classic supports “single-inheritance” role hierarchies. Classic is available for research purposes. Implementation languages for Classic are CommonLisp [Steele, 1990] and C. The interfaces are described in [Resnick et al., 1995]. Full Classic also contained the concept constructors O and B for referring to individuals in concept terms. Subsumption in full Classic was initially assumed to be polynomial [Borgida et al., 1989]. Problems with individuals in full Classic were recognized in [Patel- Schneider et al., 1991]. At the same time, subsumption in Classic was shown to be conp complete [Lenzerini and Schaerf, 1991]. In the modiﬁed semantics for the concept constructors O and B (see [Borgida and Patel-Schneider, 1994]) the interpretation function maps individuals in concept terms to disjoint sets of domain objects. With this semantics concerning individuals the inference algorithms of the Classic system could be shown to be complete [Borgida and Patel-Schneider, 1994]. However, given the non-standard semantics for the concept constructors O and B, the same effect can be achieved with existential quantiﬁcations and disjunctions w.r.t. atomic concepts:5 For each individual I a new atomic concept AI can be introduced. Note that atomic concepts are also mapped to sets of individuals. Additionally, since Classic imposes the unique name assumption, a set of axioms

5 N t th t th t t t t di tl id d b C

ensures that the new atomic concepts are disjoint. Now every term of the form ∃R.I can be replaced by ∃R.AI. Terms of the form {I1, . . . , In} can be replaced by AI1 ⊔· · · ⊔AIn. In an ABox, for each individual I a concept assertion is added to ensure that the individual is an instance of the associated atomic concept AI. Thus, only in an ABox, can a real coreference between roles be enforced. On the one hand, we can call the Classic system “almost” complete. “Almost” refers to non-standard semantics w.r.t. individuals being supported by current system implementations. On the other hand, the transformation makes clear that in Classic nevertheless a limited kind of disjunction (with concept names for which no deﬁnitions exist) can be expressed while retaining polynomial inference algorithms. The recommended techniques for knowledge-based system development with Classic are outlined in [Brachman et al., 1991]. As Brachman [Brachman, 1992, p. 256] points out, a tractable Description Logic does not guarantee that a system is useful in practice. Therefore, the Classic system was also carefully designed to meet practical requirements and to guarantee predictable system behavior. The context in which the system was expected to be used required that many queries were given to knowledge bases which rarely changed. The architectural design of Classic supports a precomputation of index structures such that queries can be answered quickly (mostly by simple storage retrieval). The architecture is made possible by a careful selection of the concept and role constructors for the DL language. Inference services for the Description Logic supported by Classic can be implemented by transforming concept expressions into a normal form (“structural subsumption”). Once the normal form is computed, queries can be answered by inspecting the data structures used to encode the normal form. It should be noted that, in Classic, retraction of told information is possible but not optimized. Another facility offered by Classic is a rule system. Rules are applied to indi- viduals explicitly named in the ABox. Furthermore, rules are applied in a forward- chaining way. Basically, a rule has a precondition (a concept) and a conclusion (also a concept). If it can be shown that an individual mentioned in the ABox is an instance of the precondition concept, a concept assertion for stating the member- ship of the individual in the conclusion concept is added to the ABox. In order to provide support for modeling, the rule base is statically checked for inconsistencies. For instance, if there are two rules whose preconditions subsume each other, the conclusions must not be disjoint. Furthermore, Classic provides simple support for closed-world reasoning ([Resnick et al., 1995], see also [Weida, 1996]). Closing a role for an individual means adding an appropriate maximum number restriction for the role. The max- imum number of ﬁllers is restricted to the largest integer such that the minimum number restriction with this integer (and the corresponding role) is entailed by the knowledge base The problem with role closing is that in combination with

rules, the exact sequence of several closing operations determines what actu- ally holds in the resulting ABox. These and other problems concerning different closing operations have to be considered with default reasoning as the theoretical background [Baader and Hollunder, 1995a; 1995b; Donini et al., 1997b; Rosati, 1998]. For a speciﬁc approach concerning the integration of defaults into the Classic system see also [Wahl¨of, 1996; Lambrix et al., 1998]. Classic is one of the ﬁrst systems that provided support for incorporating infer- ences over other domains. Consistency and subsumption checking for expressions of another domain (e.g., the reals) can be integrated into the Classic system via an extension interface [Borgida et al., 1996]. Classic was one of the ﬁrst DL systems designed with respect to users who are not experts in DL theory. An im- portant lesson learned by the Classic approach and its applications was the impor- tance of explanation and output pruning facilities [McGuinness and Borgida, 1995; McGuinness, 1996; Borgida and McGuinness, 1996]. Moreover, Classic was the ﬁrst system capable of supporting some reasonable form of error reporting [Brach- man, 1992]. However, in the current state of the art there is hardly an adequate measure for the quality of these indispensable services [Brachman, 1992, p. 253]. Although Classic was a very successful DL modeling environment, the low expressiveness of the Classic Description Logic made it hard to use the system in many kinds of applications. In many cases, users wanted more expressiveness [Patel-Schneider et al., 1990]. In the following sections we discuss systems for (more) expressive Description Logics. As can be expected, increases in expres- siveness came at a certain price. The predictability of the behavior of Classic in terms of performance could not be reached by systems implementing complete al- gorithms for more expressive DLs. On the other hand, incomplete algorithms have the problem that results computed by a system cannot be trusted in general. Thus, the complete–incomplete debate for expressive DL systems started at the end of the 1980s and the beginning of the 1990s. First, we describe the systems Loom and Back, which are based on incomplete algorithms. Afterwards, initial research on DL systems based on complete algorithms is summarized with a discussion of the systems Kris and Crack.

Loom

The Loom architecture [MacGregor and Bates, 1987; MacGregor, 1991b] offers TBox and ABox reasoning facilities for a Description Logic that can be character- ized by the name ALCQRIFO plus additional constructs for dealing with real numbers (see also [Brill, 1994] or [Horrocks, 1997a, p. 43]). Loom is based on Kl-One, i.e., concept deﬁnitions with necessary or with necessary and sufﬁcient conditions play an important role in domain modeling with Loom It should be

emphasized that truth maintenance facilities for revision were built into the Loom architecture right from the beginning and have inﬂuenced the design of the whole system [MacGregor, 1988; MacGregor and Brill, 1992]. While the ﬁrst Loom ver- sions were based on Description Logics [MacGregor and Brill, 1992], in later versions an attempt was made to develop a “description classiﬁer for the Predicate Calculus” [MacGregor, 1994]. For instance, facilities for dealing with deﬁnitions for relations were added. The current version of Loom is implemented in Common- Lisp and is available for research purposes. A new system (called PowerLoom) for CommonLisp as well as C and Java-based platforms can be licensed as well. A distinguishing design goal of Loom was the incorporation of an expressive query language for retrieving ABox individuals. Another design goal of Loom was to support rule-based programming [Yen et al., 1991b; 1991a; MacGregor and Burstein, 1991]. Based on the rule system, it is possible to specify additional necessary conditions for individuals which (i) are explicitly mentioned in the ABox and (ii) are derived to be instances of a certain deﬁned concept. The additional necessary conditions are called “implications” in Loom [MacGregor, 1988]. The additional necessary conditions speciﬁed by rules are not exploited, for instance, for TBox reasoning. Note that an “implication” A →B stated by a Loom rule does not mean that ¬B →¬A holds, i.e., rule-based “implications” are not to be confused with true logical implications as provided by generalized concept inclusions that are now standard in newer systems (see below). In order to meet the performance requirements of the applications for which Loom was developed (e.g., natural language and image interpretation), incomplete algorithms for concept consistency and subsumption are implemented. Concerning ABox reasoning, Loom applications required speciﬁc strategies to avoid the compu- tation of unused results. Rather than employing the usual forward-chaining strategy of computing the most speciﬁc atomic concepts of which the ABox individuals are instances, Loom uses a scheme that considers the queries being posed to the system. Thus,backward-chainingstrategiesforqueryansweringareusedintheimplementa- tion [MacGregor and Brill, 1992]. However, for the rule system, it is important to de- tect whether an individual is an instance of a concept that is used as a precondition of a rule. In this case, forward-chaining techniques are exploited [MacGregor, 1991b; MacGregor and Brill, 1992]. The combination of forward-chaining and backward- chaining inferences can be speciﬁed for a certain application problem by “marking” concepts accordingly. The user can control the inference process by these means but is also responsible for estimating the effects of these declarations. The arguments for the Loom approach can be summarized as follows: The in- tractability of the representation language can hardly be avoided if the require- ments of users are to be fulﬁlled. Therefore, the idea is to support the features in one system rather than as a set of application speciﬁc ad hoc supplements (“Where

resides the scrufﬁness?” [MacGregor, 1991a, p. 396]). Obviously, incompleteness is no problem as long as the answers of the inference system are interpreted in the right way (i.e., “no” answers should not be trusted). Several researchers argued that there is always the inherent danger that non-expert users either do not know this or might not recognize this as a potential danger (cf. the work on complete systems [Baader and Hollunder, 1991a; 1991b] discussed below). However, if a combina- torial explosion occurs in a complete algorithm, in practice, no result is available at all. Concerning incomplete algorithms for decidable Description Logics, arguments similar to those for other modeling environments based on ﬁrst-order logic can be mentioned: If, in a certain application, concept terms are checked for consistency and combinatorial explosions occur in complete algorithms, incomplete algorithms at least might provide some support, e.g., for building a TBox. Just signaling a timeout during the execution of a complete algorithm that runs into a combinato- rial explosion might result in less information. In this case, an incomplete algo- rithm might succeed in ﬁnding at least some inconsistencies. Note however, that in modern inference system technologies supporting complete reasoning, incomplete reasoners are used as “preprocessors” in order to speed up inferences (see the next chapter). Loom supports different kinds of individuals (classiﬁed instances, light instances, CLOS instances). For different kinds of instances different levels of inference services are supported, e.g., for classiﬁed instances, the set of most speciﬁc atomic concepts of which the classiﬁed individual is an instance is computed once new assertions are speciﬁed. Thus, for classiﬁed instances, the rule-based forward- chaining engine is triggered, possibly adding new assertions to an ABox (for details see [MacGregor and Brill, 1992]). A problem with the Loom approach is that from a user perspective it is hard to characterize the source of the incompleteness of the Loom reasoning algorithms (see the discussion in [Horrocks, 1997a, p. 42]). Although the inference techniques used in Loom are characterized in [MacGregor, 1991b, p. 90], once a system is incomplete there is no adequate measure for the “quality of service” in terms of an implementation-independent characterization. For instance, in Classic the char- acterization of the incompleteness of the inference system concerning individual reasoning was given in terms of a weak semantics for the offered representation constructs (see above). It should be noted that specifying the incompleteness on the semantic level is by no means a trivial task. Not only incompleteness issues are important in this context. For instance, the theoretical background for giving a se- mantics for rule-based computations was only investigated recently [Donini et al., 1992b; 1994a; 1998a]. Incomplete reasoning facilities might lead to unexpected behavior. We demon- strate by an example that incomplete inference algorithms can have effects in

situations a user might not be aware of. Loom also supports closed-world rea- soning. The strategy for closing a role for an individual is to count the number of known role ﬁllers. However, in addition to the individuals explicitly mentioned in the ABox, existential quantiﬁcations and minimum number restrictions have to be considered. Assuming too few of these individuals might result in an inconsis- tency. This is demonstrated by a simple knowledge base example with the following ABox: {(∃R.A ⊓∃R.B ⊓∃R.C)(i), R(i, j)}. Let us assume that in the TBox there exist axioms such that A is implicitly declared as disjoint from both concepts, B and C. In the Loom system, speciﬁc reasoning techniques (e.g., a technique called “conditioning” [MacGregor, 1991b]) are implemented to compute the number of necessary ﬁllers. Closing the role R for i by adding (≤1 R)(i) makes the ABox inconsistent. However, since Loom is incomplete, it might be the case that the dis- jointness of A and B as well as A and C is not detected and, therefore, too few ﬁllers are assumed to exist in the closing process. Thus, the added maximum num- ber restriction might be too restrictive, i.e., the system is unsound if closed-world reasoning is employed. Note that the semantic basis of automatic closing of roles as offered by Loom is hard to characterize for expressive representation languages. Obviously, closing the role R for i with (≤2 R)(i) might be a candidate. However, closing the role R for i with (≤3 R)(i) might also be possible. In this case we have more individuals but with less speciﬁc constraints.

Back and Flex

Research on Back (Berlin Advanced Computational Knowledge representation system) started in 1985, approximately at the same time as work on the Loom system was initiated. Back was also called a knowledge representation environment [Quantz and Kindermann, 1990; Peltason, 1991; Hoppe et al., 1993]. The Description Logic of the initial Back system can be called ALQR−1. There was also support for reasoning with numbers and attribute sets. Research on the inference algorithms for the basic Back language stimulated the development of theoretical results on the complexity of concept consistency reasoning (e.g., [Nebel, 1988; 1990a]) and the semantics of cycles [Nebel, 1991]. Additionally, not only was terminological reasoning considered but an investigation was made into the development of a hybrid architecture consisting of a TBox and an ABox. Issues of integration and balancing in hybrid knowledge representation systems, namely balanced expressiveness and tight coupling in hybrid systems, were analyzed in [Nebel and von Luck, 1987; 1988]. Research on the Back system helped to shape the current view on balanced representation schemes with TBox and ABox. In order to provide an hybrid representation language, Back was one of the ﬁrst systems in which TBox concept terms could also be used in an ABox to assert e g disjunctive

information about individuals. In addition, distinct individuals were assumed to denote distinct objects. Hence, the number of role ﬁllers could be counted and compared against number restrictions (this was also done in Krypton as pointed out by [Woods and Schmolze, 1992, p. 165]). The algorithms used in Back for instancecheckingandinstanceretrievalaredescribedin[NebelandvonLuck,1987; 1988; Kindermann and Randi, 1990]. In general, the discussion of the problems of incomplete algorithms that was sketched in the account of Loom also applies to the Back system because the inference algorithms used in Back are also known to be incomplete. In order to provide a knowledge representation environment, the Back architec- ture was designed to support incremental additions to the ABox. Back was one of the ﬁrst attempts to implement algorithms for reasoning about retractions of ABox assertions. Back supported retraction of told information, also called literal retraction [Nebel, 1990a; Kindermann, 1992]. This is also supported in the Loom system. ABox assertions can be retrieved from a database by automatically com- puting SQL queries [Schmiedel, 1993]. For the applications considered in the Back project, reasoning about time was important. Therefore, an integration of temporal reasoning and terminological reasoning was investigated by several project mem- bers. Investigations into how to incorporate temporal reasoning into terminological reasoning are reported in [Schmiedel, 1988; 1990; Schild, 1993; Fischer, 1992; Neuwirth, 1993]. In the successor system Flex [Quantz et al., 1995], incomplete algorithms were implemented for the Description Logic ALCQRIFO. Additionally, reasoning about equations and inequalities concerning integers was supported. Furthermore, the Flex system served as a testbed for investigating so-called weighted defaults [Quantz and Royer, 1992]. The initial implementation of Flex was developed in Prolog. Flex++ was a reimplementation in C++. The implementation was faster, but for application knowledge bases the performance was not sufﬁcient. Appro- priate optimization techniques (see the next chapter) had not been investigated in the context of Description Logics at the time of the development of the Flex implementation. In general, it is quite difﬁcult to compare different systems and knowledge rep- resentation environments because the services being offered and the representation languages are not standardized (see [Patel-Schneider and Swartout, 1993] for a proposal on standardizing representation languages and inference services). Expe- riences with system implementations indicated that either limited expressiveness or incompleteness of reasoning could possibly lead to problems in applications. Therefore, other researchers investigated the implementation of systems based on sound and complete algorithms (published at the end of the 1980s and beginning of the 1990s) One can consider [Schmidt Schauß and Smolka 1991] as a starting

point of this development (see also [Donini et al., 1991a]). Based on tableau calculi, practical DL implementations were developed. We discuss the architectures of the systems Kris and Crack.

Kris

The development of sound and complete reasoning systems for more expressive Description Logics started at the end of the 1980s. One of the main develop- ments in this direction was the system Kris. The approach of Kris was to im- plement sound and complete algorithms for an expressive Description Logic and to develop optimization techniques for TBox reasoning so that, in prac- tice, reasonable performance could be expected. The Description Logic of Kris is ALCNF [Baader and Hollunder, 1991a; 1991b]. As an addition, Kris pro- vides enumerated types (O operator) and an experimental interface for reasoning about so-called concrete domains [Baader and Hanschke, 1991a; 1991b; 1992] (e.g., linear inequalities over the reals). Role conjunctions were supported with a prototype implementation. The focus of the work in the Kris project was on TBox classiﬁcation. Nevertheless, Kris was one of the ﬁrst systems also support- ing sound and complete ABox reasoning in expressive Description Logics. Even multiple ABoxes could be handled. The implementation language of Kris was CommonLisp (see [Hollunder et al., 1991] for a User’s Guide and [Achilles et al., 1991] for a description of the graphical user interface). The idea behind optimizing TBox classiﬁcation was to exploit “obvious” infor- mation concerning “told” superconcepts and primitive concepts. In many concept deﬁnitions of application knowledge bases the right-hand side is a conjunction with concept names and concept terms. The conjuncts which are concept names on the right-hand side are deﬁned as the “told” subsumers. Another important point was to avoid recomputation of subsumption relations found in preceding computation steps. Thus, caching and propagation techniques were implemented. The idea was that information can be propagated in the subsumption lattice such that expensive subsumptiontestscanbeavoidedwherepossible.Kriswastheﬁrstsystemforwhich systematic empirical tests were carried out. The algorithms evaluated in [Baader et al., 1992b; 1994] are still in use in modern DL systems (see below). Extensions such as defaults were investigated as well (see also [Baader and Hollunder, 1992; 1993; Hollunder, 1994a]) but have not been implemented in Kris. Although the benchmarks considered in [Baader et al., 1994] revealed that the performance of Kris for TBox reasoning was comparable to that of other systems of that time, the more or less direct implementation of nondeterministic tableau algorithms that were developed for proving the decidability of problems in the ﬁeld of theoretical computer science with chronological backtracking as in Kris led to

performance problems for many applications. One of the main results of the Kris project was that sound and complete inference algorithms are an important starting point for research on optimized sound and complete algorithms for practical system development.

Crack

One of the main research goals of the system Crack was to implement sound and complete algorithms for dealing with inferences about individuals in concept terms. Rather than providing a non-standard semantics as in Classic (individuals are mapped onto sets of domain objects), in Crack, individuals are mapped to elements of the domain. Thus, coreferences also have to be considered in concept terms. Crack supports the Description Logic ALCRIFO [Bresciani et al., 1995]. The implementation of Crack is based on CommonLisp. Crack provided a web interface. In a similar way as in Kris, obvious information is exploited in the architecture to some extent but, nevertheless, Crack is a direct implementation of the tableau rules of the underlying calculus. At the beginning of the 1990s it became clear that sound andcompletereasoningisneededformanyapplicationsbuttheinferencetechniques employed, which had been developed for (manually) deriving decidability results, e.g., with tableau algorithms, were not suited for direct implementation. Thus, it was realized that there is a long way to go from a decidability proof to a working system that has good performance in the average case.

Other systems

The list of systems we have discussed in this chapter is certainly incomplete. The large number of projects involved in the development of knowledge representation systems shows the importance of this area. Usually DL systems are built around a core engine which is a consistency checker. However, there are other services to be supplied which are also important to make the systems usable in larger applica- tion projects. We present an overview of some additional systems with interesting features developed at the beginning of the 1990s. Among other points, the graphical manipulation of representations was inves- tigated in the Sb-One project [Allgayer, 1990; Kobsa, 1991b; 1991a]. The im- plementation language was CommonLisp. Techniques for graphical interfaces to support knowledge base development with Sb-One are described in [Kalmes, 1988; 1990] (see also [Abrett and Burstein, 1987] for a description of the Kreme system). Furthermore, in Sb-One the use of contexts (also called partitions) was explored for user modeling applications in natural language generation

Another important point for DL inference systems is persistence and transaction management. We have already discussed the Back approach [Schmiedel, 1993] (see also [Borgida, 1995]). Additional investigations were also made with the K-Rep system [Mays et al., 1991a; 1991b].

Summary: standard inference services of Description Logics systems

Before discussing successors of the second generation systems presented in this section it is appropriate to summarize the main inference problems that are now as- sumed as standard for DL systems. The inference services provided by DL systems for concept consistency and TBox reasoning can be summarized as follows:

r Concept consistency (w.r.t. a TBox). r Concept subsumption (w.r.t. a TBox). r Another important inference service for practical knowledge representation is to check whether a certain concept name is inconsistent w.r.t. a TBox. Usually, inconsistent concept names are the consequence of modeling errors. Checking the consistency of all concept names mentioned in a TBox without computing the parents and children is called a TBox coherence check. r The problem of computing the most speciﬁc concept names mentioned in a TBox that subsume a certain concept is known as computing the parents of a concept. The children are the most general concept names mentioned in a TBox that are subsumed by a certain concept. We use the name concept ancestors (concept descendants) for the transitive closure of the parents (children) relation. The computation of the parents and children of every concept name is also called classiﬁcation of the TBox. This inference is needed to build a hierarchy of concept names w.r.t. speciﬁcity and is known as TBox classiﬁcation.

If a system supports ABox reasoning, the following inference services are provided:

r ABox consistency (w.r.t. a TBox). r Instance checking w.r.t. a TBox and an ABox. r The most speciﬁc concept names mentioned in a TBox T of which an individual is an instance are called the direct types of the individual w.r.t. a TBox and an ABox. r The retrieval inference problem is to ﬁnd all individuals mentioned in an ABox that are an instance of a given concept C w.r.t. a TBox. r The set of ﬁllers of a role R for an individual i w.r.t. a TBox T and an ABox A is deﬁned as {x | (T , A) |= (i, x) : R} where (T , A) |= ax means that all models of T and A are also models of ax. r The set of roles between two individuals i and j w.r.t. a knowledge base (T , A) is deﬁned as {R | (T , A) |= (i, j) : R}.

In many DL systems, there are some auxiliary queries supported: retrieval of the concept names or individuals mentioned in a knowledge base, retrieval of the set of roles retrieval of the role parents and children (deﬁned analogously to the concept

parents and children, see above), retrieval of the set of individuals in the domain and in the range of a role, etc. As we have discussed in this section, DL systems of the second generation offer most if not all of these inference services. An exception is a language for specifying retrieval queries that goes beyond the simple retrieval inference problem mentioned above (see e.g., the discussion about Loom).

8.4 The next generation: Fact, Dlp and Racer

The declarative nature of DL modeling is even more important when problems are treated for which languages are required that are no longer tractable. In- spired by theoretical advances—e.g., for handling number restrictions, role con- junctions, generalized concept inclusions and cyclic axioms with descriptive se- mantics (ALCNR [Buchheit et al., 1993a]); transitive roles (ALC R+ [Sattler, 1996]); role hierarchies and features (ALCH fR+ [Horrocks, 1998b]); and inverse roles, qualiﬁed number restrictions, and role hierarchies (SHIQ [Horrocks et al., 1999] also called ALCQHI R+, pronounced ALC-choir)—the development of an- other generation of sound and complete DL systems was started at the end of the 1990s.

Fact

Initially, research on practical implementations of DL systems for expressive Description Logics started with a focus on concept and TBox reasoning. How- ever, rather than directly implementing the tableau calculus used for the the- oretical decidability proofs and complexity analyses, a rigorous investigation into methods for informed search was made for developing the next genera- tion of DL systems. In particular, average-case optimization techniques have been investigated with the system Fact ([Horrocks, 1997a; 1998b; Horrocks and Patel-Schneider, 1999] see also the subsequent chapter for details). At the time of this writing, two versions of Fact are available. One version supports TBox reasoning for the Description Logic ALCH fR+ [Horrocks, 1997a; 1998b]. Furthermore, a newer version of Fact also supports TBox reasoning with inverse roles and qualiﬁed number restrictions (SHIQ [Horrocks, 1999; Horrocks et al., 1999]). At the time of this writing, Fact does not support ABoxes. It was the Fact system that ﬁrst demonstrated the usefulness of expressive De- scription Logics for developing practical applications. It was shown that, although runtime behavior can be exponential in the worst case, in practical contexts, op- timization techniques can be found that prevent a DL system from running into combinatorial explosion. Nevertheless, the algorithms are still sound and com- plete Indeed after several years of experience with less expressive systems such

as Classic, research on Fact stimulated many research activities for developing optimized DL system implementations for expressive Description Logics. The system Fact is implemented in CommonLisp and can be downloaded with source code for research purposes. A CORBA interface guarantees seamless integration into network-aware applications. Various input formats are suppor- ted by Fact (e.g., for XML-based notations of TBoxes). The graphical inter- face OilEd for developing TBoxes in the spirit of frame systems is described in [Bechhofer et al., 2001b].

Dlp

Based on similar techniques to Fact, the system Dlp utilizes extended techniques for optimizations [Horrocks and Patel-Schneider, 1998c; 1998d; Patel-Schneider, 1999]. Dlp supports concept consistency reasoning for the Description Logic ALCN reg. From a modal logic perspective, ALCN reg can also be called Propo- sitional Dynamic Logic (PDL) with a restricted form of graded modalities, i.e., simple number restrictions. Dlp has succeeded in many performance competitions [Horrocks, 1998a; Horrocks and Patel-Schneider, 1998c; Patel-Schneider, 1999]. It was shown that tableau-based approaches can be implemented such that the performance for satisﬁability testing for ALC or modal logic Km is comparable to traditional approaches used in the community [Giunchiglia and Sebastiani, 1996b; Giunchiglia et al., 1999]. However, in the current version of Dlp TBox classiﬁcation is not provided as an inference service. In particular, no generalized concept inclusions and no TBoxes with forward references are supported (i.e., algorithms for dealing with generalized concept inclusions are not implemented in Dlp). ABoxes are not supported either. Dlp is implemented in SML.

Racer

For many applications, besides concept consistency and TBox reasoning, ABox reasoning is also important. Calculi for ABox consistency have been presented for the above-mentioned representation constructs: ALCNR [Buchheit et al., 1993b], ALCNHR+ [Haarslev and M¨oller, 2000], ALCQHI R+ (SHIQ) [Horrocks et al., 2000c]. Based on theoretical results, a practical implementation of ABox calculi was developed with the full TBox and ABox DL system Racer [Haarslev andM¨oller,1999;2001e].Racersupportsalloptimizationtechniquesthatareincor- porated into Fact. Some new optimization techniques investigated with the Racer system (e g for dealing with number restrictions and ABoxes) are mentioned in

the next chapter. In Racer, the unique name assumption for ABox individuals is imposed. In order to demonstrate the usefulness of DL systems for practical ap- plications, high performance reasoning for large TBoxes is discussed in [Haarslev and M¨oller, 2001c]. Initial versions of the Racer system supported the logic ALCNHR+. In later versions reasoning was extended to ABox reasoning with the logic ALCQHI R+ (SHIQ). In addition, Racer supports concrete domains without so-called feature chains (see [Baader and Hanschke, 1991a] and the discussion of the Kris system). In particular, predicates representing linear inequalities about the reals are handled by Racer (see [Haarslev et al., 2001; Haarslev and M¨oller, 2001b] for details). Racer dynamically selects appropriate optimization techniques based on a static analysis of input TBoxes, ABoxes and queries. As a distinguishing feature, which is important for many applications, it should also be mentioned that Racer supports multiple TBoxes and ABoxes (see also the Kris system). Assertions can be added to ABoxes after queries have been answered. In addition, for instance, Racer also provides support for retraction of assertions. Racer can be downloaded for research purposes as a server program for standard operating systems with no additional licenses. A socket-based network version with Java interface is available. The implementation language of Racer is CommonLisp.

8.5 Lessons learned

Considering the evolving technology of DL systems it becomes clear that since the end of the 1990s there has been an enormous interest in DL reasoning systems. This is demonstrated by the quite large number of system implementations. Currently, all modern DL systems are based on sound and complete algorithms. Thus, system developers can really rely on all answers computed by a DL system. This positive trend has been initiated by the development of optimization techniques that ensure stable runtimes for average-case inputs for real-world problems even if the worst- case complexity is exponential (see also below). The trend has been initiated by the landmark system Fact. The original idea of the Tell&Ask interface of Krypton is still realized in modern systems. However, at the time of this writing, the systems support only some kind of batch-oriented behavior. A knowledge base (TBox and ABox) is passed to the systems (tell interface). Afterwards, queries can be answered (ask interface). But, no incremental additions to the knowledge base are possible after the ﬁrst query is answered. The difﬁculty is that complex transformations on the knowledge bases are necessary in order to compute an internal representation that can be used for relatively fast query answering (see the discussion on optimization techniques in

subsequent chapters). The price to pay is that algorithms for appropriately handling incremental additions to a knowledge base are not yet known. Other features, e.g., explanation facilities, retraction, etc., still have to be developed for expressive DLs as well. As a second and quite important lesson one can see that Description Logics with more expressiveness and sound and complete algorithms impose a different view in modeling. Concept deﬁnitions as known from, for instance, Classic are no longer the central modeling device if generalized concept inclusions (representing cyclic implications or equalities) are available.6

A third lesson we can learn from considering DL systems and their develop- ment is that speed depends much more on the expressiveness of the Description Logic than it does on the implementation language. What really counts is the set of optimization strategies, the implementation of index data structures and the selection of clever heuristics. There are ﬁrst attempts at providing a distributed implementation of a DL system. However, performance problems in network com- munication lead to server-based solutions, i.e., a knowledge base is being processed at a single workstation computer (but may be accessed from different clients). Benchmark generators and standardized application knowledge bases are used for metering system performance. Thus, different system implementations can be compared. With Racer we have discussed a state-of-the-art DL system that also supports ABoxes and concrete domains. However, only simple query languages are cur- rently available. For Description Logics without inverse roles and number restric- tions (i.e., ALCH fR+), Tessaris [2001] developed the basic techniques for sup- porting the so-called conjunctive queries in DL systems. However, for Description Logics as expressive as SHIQ much less is known from an implementation standpoint. Another lesson is that the development of techniques for practically incorporat- ing facilities for the representation of space and time into Description Logics is still an open issue. The necessity of a semantics-based integration of temporal and terminological reasoning has been emphasized in ﬁrst investigations in the Back project. However, early approaches (e.g., [Schmiedel, 1990]) have been shown to be undecidable [Halpern and Shoham, 1991; Schild, 1993]. In the context of planning, the opportunities of an integrated environment combining temporal and termino- logical reasoning were clearly demonstrated with the RHET system [Allen, 1991]. It has been shown that spatial reasoning (e.g., about topological relations) induces non-obvious subsumption relationships between concepts [Haarslev et al., 1998;

6 Nevertheless, Description Logics can still be called object-based representation formalisms, although there are some approaches to deal with n-ary relations [Schmolze, 1989; Calvanese et al., 1998d] as well.

1999]. The work presented in [Artale et al., 2001] demonstrates that the decidability barrier is reached if temporal operators are integrated into expressive Description Logics. Nevertheless, [Artale et al., 2001] identify a fragment that allows a limited kind of practical modeling. Initial experiments concerning an implementation of a Description Logic that supports operators for linear time temporal reasoning are discussed in [G¨unsel and Wittmann, 2001].

9

Implementation and Optimization Techniques

IAN HORROCKS

Abstract

This chapter will discuss the implementation of the reasoning services which form the core of DL-based knowledge representation systems. To be useful in realis- tic applications, such systems need both expressive logics and fast reasoners. As expressive logics inevitably have high worst-case complexities, this can only be achieved by employing highly optimized implementations of suitable reasoning al- gorithms. Systems based on such implementations have demonstrated that they can perform well with problems that occur in realistic applications, including problems where unoptimized reasoning is hopelessly intractable.

9.1 Introduction

The usefulness of Description Logics in applications has been hindered by the basic conﬂict between expressiveness and tractability. Realistic applications typically re- quire both expressive logics, with inevitably high worst-case complexities for their decision procedures, and acceptable performance from the reasoning services. Al- though the deﬁnition of acceptable may vary widely from application to application, early experiments with Description Logics indicated that, in practice, performance was a serious problem, even for logics with relatively limited expressive powers [Heinsohn et al., 1992]. On the other hand, theoretical work has continued to extend our understand- ing of the boundaries of decidability in Description Logics, and has led to the development of sound and complete reasoning algorithms for much more expres- sive logics. The expressive power of these logics goes a long way towards ad- dressing the criticisms leveled at Description Logics in traditional applications such as ontological engineering [Doyle and Patil, 1991] and is sufﬁcient to sug- t th t th ld b f l i l iti li ti d i f

example reasoning about database schemas and queries [Calvanese et al., 1998f; 1998a] and providing reasoning support for the so-called Semantic Web [Decker et al., 2000; Bechhofer et al., 2001b]. However, the worst-case complexity of their decision procedures is invariably (at least) exponential with respect to problem size. This high worst-case complexity initially led to the conjecture that expressive Description Logics might be of limited practical applicability [Buchheit et al., 1993c]. However, although the theoretical complexity results are discouraging, empirical analyses of real applications have shown that the kinds of construct which lead to worst-case intractability rarely occur in practice [Nebel, 1990b; Heinsohn et al., 1994; Speel et al., 1995], and experiments with the Kris system showed that applying some simple optimization techniques could lead to a signif- icant improvement in the empirical performance of a DL system [Baader et al., 1992a]. More recently the Fact, Dlp and Racer systems have demonstrated that, even with very expressive logics, highly optimized implementations can provide ac- ceptable performance in realistic applications [Horrocks and Patel-Schneider, 1999; Haarslev and M¨oller, 2001c].1

In this chapter we will study the implementation of DL systems, examining in detail the wide range of optimization techniques that can be used to improve perfor- mance. Some of the techniques that will be discussed are completely independent of the logical language supported by the Description Logic and the kind of algorithm used for reasoning; many others would be applicable to a wide range of languages and implementation styles, particularly those using search-based algorithms. How- ever, the detailed descriptions of implementation and optimization techniques will assume, for the most part, reasoning in an expressive DL based on a sound and complete tableau algorithm.

9.1.1 Performance analysis

Before designing and implementing a DL-based knowledge representation system, the implementor should be clear about the goals that they are trying to meet and against which the performance of the system will ultimately be measured. In this chapter it will be assumed that the primary goal is utility in realistic applications, and that this will normally be assessed by empirical analysis. Unfortunately, as DL systems with very expressive logics have only recently become available [Horrocks, 1998a; Patel-Schneider, 1998; Haarslev and M¨oller, 2001e],thereareveryfewapplicationsthatcanbeusedasasourcefortestdata.2 One

1 It should be pointed out that experience in this area is still relatively limited. 2 This situation is changing rapidly, however, with the increasing use of Description Logics in database and

application that has been able to provide such data is the European Galen project, part of which has involved the construction of a large DL knowledge base describing medical terminology [Rector et al., 1993]. Reasoning performance with respect to this knowledge base has been used for comparing DL systems [Horrocks and Patel- Schneider, 1998b], and we will often refer to it when assessing the effectiveness of optimization techniques. As few other suitable knowledge bases are available, the testing of DL systems has often been supplemented with the use of randomly generated or hand crafted test data [Giunchiglia and Sebastiani, 1996b; Heuerding and Schwendimann, 1996; Horrocks and Patel-Schneider, 1998b; Massacci, 1999; Donini and Massacci, 2000]. In many cases the data was originally developed for testing propositional modal logics, and has been adapted for use with Description Logics by taking ad- vantage of the well-known correspondence between the two formalisms [Schild, 1991]. Tests using this kind of data, in particular the test suites from the Tableaux’98 comparison of modal logic theorem provers [Balsiger and Heuerding, 1998] and the DL’98 comparison of DL systems [Horrocks and Patel-Schneider, 1998b], will also be referred to in assessments of optimization techniques.

9.2 Preliminaries

This section will introduce the syntax and semantics of Description Logics (full details of which can be found in Chapter 2) and discuss the reasoning services which would form the core of a DL-based knowledge representation system. It will also discuss how, through the use of unfolding and internalization, these reasoning services can often be reduced to the problem of determining the satisﬁability of a single concept.

9.2.1 Syntax and semantics

Description Logics are formalisms that support the logical description of concepts and roles. Arbitrary concept and role descriptions (from now on referred to simply as concepts and roles) are constructed from atomic concept and role names using a variety of concept- and role-forming operators, the range of which is dependent on the particular logic. In the following discussion we will use C and D to denote arbitrary concepts, R and S to denote arbitrary roles, A and P to denote atomic concept and role names, and n to denote a nonnegative integer. For concepts, the available operators usually include some or all of the standard logical connectives, conjunction (denoted ⊓), disjunction (denoted ⊔) and negation (denoted ¬). In addition, the universal concept top (denoted ⊤, and equivalent to A A) d th i h t t b tt (d t d ⊥ d i l t t A A)

are often pre-deﬁned. Other commonly supported operators include restricted forms of quantiﬁcation called existential role restrictions (denoted ∃R.C) and universal role restrictions (denoted ∀R.C). Some Description Logics also support qualiﬁed number restrictions (denoted ⩽n .PC and ⩾n .PC), operators that place cardinality restrictions on the roles relating instances of a concept to instances of some other concept.Cardinalityrestrictionsareoftenlimitedtotheforms⩽n .P⊤and⩾n .P⊤, when they are called unqualiﬁed number restrictions, or simply number restrictions, and are often abbreviated to ⩽n P and ⩾nP. The roles that can appear in cardinality restriction concepts are usually restricted to being atomic, as allowing arbitrary roles in such concepts is known to lead to undecidability [Baader and Sattler, 1996b]. Role-forming operators may also be supported, and in some very expressive logics roles can be regular expressions formed using union (denoted ⊔), compo- sition (denoted ◦), reﬂexive-transitive closure (denoted ∗) and identity operators (denoted id), possibly augmented with the inverse (also known as converse) opera- tor (denoted −) [De Giacomo and Lenzerini, 1996]. In most implemented systems, however, roles are restricted to being atomic names. Concepts and roles are given a standard Tarski-style model-theoretic semantics, their meaning being given by an interpretation I = (I,I ), where I is the domain (a set) and I is an interpretation function. Full details of both syntax and semantics can be found in Chapter 2. In general, a DL knowledge base (KB) consists of a set T of terminological axioms, and a set A of assertional axioms. The axioms in T state facts about concepts and roles while those in A state facts about individual instances of concepts and roles. As in this chapter we will mostly be concerned with terminological reasoning, that is reasoning about concepts and roles, a KB will usually be taken to consist only of the terminological component T . A terminological KB T usually consists of a set of axioms of the form C ⊑D and C ≡D, where C and D are concepts. An interpretation I satisﬁes T if for every axiom (C ⊑D) ∈T , CI ⊆DI, and for every axiom (C ≡D) ∈T , CI = DI; T is satisﬁable if there exists some non-empty interpretation that satisﬁes it. Note that T can, without loss of generality, be restricted to contain only inclusion axioms or only equality axioms, as the two forms can be reduced one to the other using the following equivalences:

C ⊑D ⇐⇒ ⊤≡D ⊔¬C C ≡D ⇐⇒ C ⊑D and D ⊑C.

A concept C is subsumed by a concept D with respect to T (written T |= C ⊑D) if CI ⊆DI in every interpretation I that satisﬁes T , a concept C is satisﬁable with respect to T (written T |= C ̸⊑⊥) if CI ̸= ∅in some I that satisﬁes T , and a t C i ti ﬁbl ( t ti ﬁbl ) ith t t T ( itt T | C) if

CI = ∅in every I that satisﬁes T . Subsumption and (un)satisﬁability are closely related. If T |= C ⊑D, then in all interpretations I that satisfy T , CI ⊆DI and so CI ∩(¬D)I = ∅. Conversely, if C is not satisﬁable with respect to T , then in all I that satisfy T , CI = ∅and so CI ⊆⊥I. Subsumption and (un)satisﬁability can thus be reduced one to the other using the following equivalences:

T |= C ⊑D ⇐⇒ T |= ¬(C ⊓¬D) T |= ¬C ⇐⇒ T |= C ⊑⊥.

In some Description Logics T can also contain axioms that deﬁne a set of transi- tive roles R+ and/or a subsumption partial ordering on roles [Horrocks and Sattler, 1999]. An axiom R ∈R+ states that R is a transitive role while an axiom R ⊑S states that R is subsumed by S. An interpretation I satisﬁes the axiom R ∈R+ if RI is transitively closed (i.e., (RI)+ = RI), and it satisﬁes the axiom R ⊑S if RI ⊆SI.

9.2.2 Reasoning services

Terminological reasoning in a DL-based knowledge representation system is based on determining subsumption relationships with respect to the axioms in a KB. As well as answering speciﬁc subsumption and satisﬁability queries, it is often useful to compute and store (usually in the form of a directed acyclic graph) the subsumption partial ordering of all the concept names appearing in the KB, a procedure known as classifying the KB [Patel-Schneider and Swartout, 1993]. Some systems may also be capable of dealing with assertional axioms, those concerning instances of concepts and roles, and performing reasoning tasks such as realization (determining the concepts instantiated by a given individual) and retrieval (determining the set of individuals that instantiate a given concept) [Baader et al., 1991]. However, we will mostly concentrate on terminological reasoning because it has been more widely used in DL applications. Moreover, given a sufﬁciently expressive Description Logic, assertional reasoning can be reduced to terminological reasoning [De Giacomo and Lenzerini, 1996]. In practice, many systems use subsumption-testing algorithms that are not ca- pable of determining subsumption relationships with respect to an arbitrary KB. Instead, they restrict the kinds of axiom that can appear in the KB so that dependency-eliminating substitutions (known as unfolding) can be performed prior to evaluating subsumption relationships. These restrictions require that all axioms are unique, acyclic deﬁnitions. An axiom is called a deﬁnition of A if it is of the form A ⊑D or A ≡D, where A is an atomic name, it is unique if the KB contains th d ﬁiti f A d it i li if D d t f ith di tl

indirectly (via other axioms) to A. A KB that satisﬁes these restrictions will be called an unfoldable KB. Deﬁnitions of the form A ⊑D are sometimes called primitive or necessary, as D speciﬁes a necessary condition for instances of A, while those of the form A ≡D are sometimescallednon-primitiveornecessaryandsufﬁcient as D speciﬁesconditions that are both necessary and sufﬁcient for instances of A. In order to distinguish non-deﬁnitional axioms, they are often called general axioms [Buchheit et al., 1993a]. Restricting the KB to deﬁnition axioms makes reasoning much easier, but signiﬁcantly reduces the expressive power of the DL. However, even with an unrestricted (or general) KB, deﬁnition axioms and unfolding are still useful ideas, as they can be used to optimize the reasoning procedures (see Section 9.4.3).

9.2.3 Unfolding

Given an unfoldable KB T , and a concept C whose satisﬁability is to be tested with respect to T , it is possible to eliminate from C all concept names occurring in T using a recursive substitution procedure called unfolding. The satisﬁability of the resulting concept is independent of the axioms in T and can therefore be tested using a decision procedure that is only capable of determining the satisﬁability of a single concept (or equivalently, the satisﬁability of a concept with respect to an empty KB). For a non-primitive concept name A, deﬁned in T by an axiom A ≡D, the procedure is simply to replace A with D wherever it occurs in C, and then to recursively unfold D. For a primitive concept name A, deﬁned in T by an axiom A ⊑D, the procedure is slightly more complex. Wherever A occurs in C it is replaced with the concept A′ ⊓D, where A′ is a new concept name not occurring in T or C, and D is then recursively unfolded. The concept A′ represents the “primitiveness” of A—the unspeciﬁed characteristics that differentiate it from D. We will use Unfold(C, T ) to denote the concept C unfolded with respect to a KB T . AdecisionprocedurethattriestoﬁndasatisfyinginterpretationI fortheunfolded concept can now be used, as any such interpretation will also satisfy T . This can easily be shown by applying the unfolding procedure to all of the concepts forming the right-hand side of axioms in T , so that they are constructed entirely from concept names that are not deﬁned in T , and are thus independent of the other axioms in T . The interpretation of each deﬁned concept in T can then be taken to be the interpretation of the unfolded right-hand side concept, as given by I and the semantics of the concept and role forming operators. Subsumption reasoning can be made independent of T using the same technique. Gi t t C d D d t i i if C i b d b D ith t t

T is the same as determining if Unfold(C, T ) is subsumed by Unfold(D, T ) with respect to an empty KB:

T |= C ⊑D ⇐⇒ ∅|= Unfold(C, T ) ⊑Unfold(D, T ).

Unfolding would not be possible, in general, if the axioms in T were not unique acyclic deﬁnitions. If T contained multiple deﬁnition axioms for some concept A, for example {(A ≡C), (A ≡D)} ⊆T , then it would not be possible to make a substitution for A that preserved the meaning of both axioms. If T contained cyclic axioms, for example (A ⊑∃R.A) ∈T , then trying to unfold A would lead to non-termination. If T contained general axioms, for example ∃R.C ⊑D, then it could not be guaranteed that an interpretation satisfying the unfolded concept would also satisfy these axioms.

9.2.4 Internalization

While it is possible to design an algorithm capable of reasoning with respect to a general KB [Buchheit et al., 1993a], with more expressive logics, in particular those allowing the deﬁnition of a universal role, a procedure called internalization can be used to reduce the problem to that of determining the satisﬁability of a single concept [Baader, 1991]. A truly universal role is one whose interpretation includes every pair of elements in the domain of interpretation (i.e., I × I). However, a role U is universal w.r.t. a terminology T if it is deﬁned such that U is transitively closed and P ⊑U for all role names P occurring in T . For a logic that supports the union and transitive reﬂexive closure role-forming operators, this can be achieved simply by taking U to be

(P1 ⊔· · · ⊔Pn ⊔P− 1 ⊔· · · ⊔P− n )∗,

where P1, . . . , Pn are all the roles names occurring in T . For a logic that supports transitively closed roles and role inclusion axioms, this can be achieved by adding the axioms

(U ∈R+), (P1 ⊑U), . . . , (Pn ⊑U), (P− 1 ⊑U), . . . , (P− n ⊑U)

to T , where P1, . . . , Pn are all the roles names occurring in T and U is a new role name not occurring in T . Note that in either case, the inverse role components are only required if the logic supports the inverse role operator. The concept axioms in T can be reduced to axioms of the form ⊤⊑C using the equivalences:

A ≡B ⇐⇒ ⊤⊑(A ⊔¬B) ⊓(¬A ⊔B) A ⊑B ⊤⊑ A B

These axioms can then be conjoined to give a single axiom ⊤⊑C, where

C = ⊓ (Ai≡Bi)∈T ((Ai ⊔¬Bi) ⊓(¬Ai ⊔Bi)) ⊓⊓ (A j⊑B j)∈T (¬A j ⊔B j).

Because the interpretation of ⊤is equal to the domain (⊤I = I), this axiom statesthateveryelementinthedomainmustsatisfyC.Whentestingthesatisﬁability of a concept D with respect to T , this constraint on possible interpretations can be imposed by testing the satisﬁability of D ⊓C ⊓∀U.C (or simply D ⊓∀U.C in the case where U is transitively reﬂexively closed). This relies on the fact that satisﬁable DL concepts always have an interpretation in which every element is connected to every other element by some sequence of roles (the collapsed model property) [Schild, 1991].

9.3 Subsumption-testing algorithms

The use of unfolding and internalization means that, in most cases, terminological reasoning in a DL-based Knowledge Representation System can be reduced to subsumption or satisﬁability reasoning. There are several algorithmic techniques for computing subsumption relationships, but they divide into two main families: structural and logical.

9.3.1 Structural subsumption algorithms

Structural algorithms were used in early DL systems such as Kl-One [Brachman and Schmolze, 1985], Nikl [Kaczmarek et al., 1986] and Krypton [Brachman et al., 1983a], and are still used in systems such as Classic [Patel-Schneider et al., 1991], Loom [MacGregor, 1991b] and Grail [Rector et al., 1997]. To determine if one concept subsumes another, structural algorithms simply compare the (normal- ized) syntactic structure of the two concepts (see Chapter 2). Although such algorithms can be quite efﬁcient [Borgida and Patel-Schneider, 1994; Heinsohn et al., 1994], they have several disadvantages.

r Perhaps the most important disadvantage of this type of algorithm is that while it is generally easy to demonstrate the soundness of the structural inference rules (they will never infer an invalid subsumption relationship), they are usually incomplete (they may fail to infer all valid subsumption relationships). r It is difﬁcult to extend structural algorithms in order to deal with more expressive logics, in particular those supporting general negation, or to reason with respect to an arbitrary KB. This lack of expressive power makes the DL system of limited value in traditional ontological engineering applications [Doyle and Patil, 1991], and completely useless in d b h i li i [C l l 1998f]

r Although accepting some degree of incompleteness is one way of improving the perfor- mance of a DL reasoner, the performance of incomplete reasoners is highly dependent on the degree of incompleteness, and this is notoriously difﬁcult to quantify [Borgida, 1992a].

9.3.2 Logical algorithms

These kinds of algorithm use a refutation-style proof: C is subsumed by D if it can be shown that the existence of an individual x that is in the extension of C (x ∈CI) but not in the extension of D (x /∈DI) is logically inconsistent. As we have seen in Subsection 9.2.2, this corresponds to testing the logical (un)satisﬁability of the concept C ⊓¬D (i.e., C ⊑D iff C ⊓¬D is not satisﬁable). Note that forming this concept obviously relies on having full negation in the logic. Various techniques can be used to test the logical satisﬁability of a concept. One obvious possibility is to exploit an existing reasoner. For example, the LogicsWorkbench [Balsiger et al., 1996], a general-purpose propositional modal logic reasoning system, could be used simply by exploiting the well-known corre- spondences between description and modal logics [Schild, 1991]. First-order logic theorem provers can also be used via appropriate traslations of Description Logics intoﬁrst-orderlogic.Examplesofthisapproachcanbeseeninsystemsdevelopedby Hustadt and Schmidt [1997], using the Spass theorem prover, and Paramasivam and Plaisted [1998], using the CLIN-S theorem prover. An existing reasoner could also be used as a component of a more powerful system, as in Ksat/*Sat [Giunchiglia and Sebastiani, 1996a; Giunchiglia et al., 2002], where a propositional satisﬁability (SAT) tester is used as the key component of a propositional modal satisﬁability reasoner. There are advantages and disadvantages to the “re-use” approach. On the positive side, it should be much easier to build a system based on an existing reasoner, and performance can be maximized by using a state-of-the-art implementation such as Spass (a highly optimized ﬁrst-order theorem prover) or the highly optimized SAT testing algorithms used in Ksat and *Sat (the use of a specialized SAT tester allows *Sat to outperform other systems on classes of problem that emphasize propositional reasoning). The translation (into ﬁrst-order logic) approach has also been shown to be able to deal with a wide range of expressive Description Logics, in particular those with complex role-forming operators such as negation or identity [Hustadt and Schmidt, 2000]. On the negative side, it may be difﬁcult to extend the reasoner to deal with more expressive logics, or to add optimizations that take advantage of speciﬁc features of the Description Logic, without reimplementing the reasoner (as has been done, f l i t i f th *S t )

Most, if not all, implemented DL systems based on logical reasoning have used custom designed tableau decision procedures. These algorithms try to prove that D subsumes C by starting with a single individual satisfying C ⊓¬D, and demon- strating that any attempt to extend this into a complete interpretation (using a set of tableau expansion rules) will lead to a logical contradiction. If a complete and non-contradictory interpretation is found, then this represents a counterexample (an interpretation in which some element of the domain is in CI but not in DI) that disproves the conjectured subsumption relationship. This approach has many advantages and has dominated recent DL research:

r It has a sound theoretical basis in ﬁrst-order logic [Hollunder et al., 1990]. r It can be relatively easily adapted to allow for a range of logical languages by changing the set of tableau expansion rules [Hollunder et al., 1990; Bresciani et al., 1995]. r It can be adapted to deal with very expressive logics, and to reason with respect to an arbitrary KB, by using more sophisticated control mechanisms to ensure termination [Baader, 1991; Buchheit et al., 1993c; Sattler, 1996]. r It has been shown to be optimal for a number of DL languages, in the sense that the worst-case complexity of the algorithm is no worse than the known complexity of the satisﬁability problem for the logic [Hollunder et al., 1990].

In the remainder of this chapter, detailed descriptions of implementation and optimization techniques will assume the use of a tableau decision procedure. How- ever, many of the techniques are independent of the subsumption-testing algorithm or could easily be adapted to most logic-based methods. The reverse is also true, and several of the described techniques have been adapted from other logical deci- sion procedures, in particular those that try to optimize the search used to deal with non-determinism.

9.3.2.1 Tableau algorithms

Tableau algorithms try to prove the satisﬁability of a concept D by constructing a model, an interpretation I in which DI is not empty. A tableau is a graph which rep- resents such a model, with nodes corresponding to individuals (elements of I) and edges corresponding to relationships between individuals (elements of I × I). A typical algorithm will start with a single individual satisfying D and try to construct a tableau, or some structure from which a tableau can be constructed, by inferring the existence of additional individuals or of additional constraints on individuals. The inference mechanism consists of applying a set of expansion rules which correspond to the logical constructs of the language, and the algorithm terminates either when the structure is complete (no further inferences are possible) or when obvious contradictions have been revealed. Non-determinism is dealt with b hi diff t ibl i th t i ti ﬁbl if

⊓-rule if 1. (C ⊓D) ∈L(x) 2. {C, D} ⊈L(x) then L(x) −→L(x) ∪{C, D} ⊔-rule if 1. (C ⊔D) ∈L(x) 2. {C, D} ∩L(x) = ∅ then either L(x) −→L(x) ∪{C} or L(x) −→L(x) ∪{D} ∃-rule if 1. ∃R.C ∈L(x) 2. there is no y s.t. L(⟨x, y⟩) = R and C ∈L(y) then create a new node y and edge ⟨x, y⟩ with L(y) = {C} and L(⟨x, y⟩) = R ∀-rule if 1. ∀R.C ∈L(x) 2. there is some y s.t. (⟨x, y⟩) = R and C /∈L(y) then

L(y) L(y) ∪{C} L

Fig. 9.1. Tableau expansion rules for ALC.

expansion leads to a contradiction and is satisﬁable if any possible expansion leads to the discovery of a complete non-contradictory structure. Theoretical presentations of tableau algorithms use a variety of notational styles including constraints [Hollunder et al., 1990], preﬁxes [De Giacomo and Massacci, 1996] and labeled graphs [Sattler, 1996]. We will use the labeled graph notation as it has an obvious correspondence with standard implementation techniques. In its basic form, this notation describes the construction of a directed graph (usually a tree) in which each node x is labeled with a set of concepts (L(x) = {C1, . . . , Cn}), and each edge ⟨x, y⟩is labeled with a role (L(⟨x, y⟩) = R). When a concept C is in the label of a node x (C ∈L(x)), it represents a model in which the individual corresponding with x is in the interpretation of C. When an edge ⟨x, y⟩is labeled R (L(⟨x, y⟩) = R), it represents a model in which the tuple corresponding with ⟨x, y⟩ is in the interpretation of R. A node y is called an R-successor of a node x if there is an edge ⟨x, y⟩labeled R, x is called the predecessor of y if y is an R-successor of x, and x is called an ancestor of y if x is the predecessor of y or there exists some node z such that z is the predecessor of y and x is an ancestor of z. A contradiction or clash is detected when {C, ¬C} ⊆L(x) for some concept C and some node x. To test the satisﬁability of a concept D, a basic algorithm initializes a tree to contain a single node x (called the root node) with L(x) = {D}, and then expands the tree by applying rules that either extend node labels or add new leaf nodes. A set of expansion rules for the ALC Description Logic is shown in Figure 9.1, where C and D are concepts, and R is a role. Note that:

r Concepts are assumed to be in negation normal form, that is with negations only applying to concept names. Arbitrary ALC concepts can be converted to negation normal form by pushing negations inwards using a combination of De Morgan’s laws and the equivalences ¬(∃R.C) ⇐⇒(∀R.¬C) and ¬(∀R.C) ⇐⇒(∃R.¬C). This procedure

r Disjunctive concepts (C ⊔D) ∈L(x) give rise to non-deterministic expansion. In practice this is usually dealt with by search: trying each possible expansion in turn until a fully expanded and clash-free tree is found, or all possibilities have been shown to lead to contradictions. In more expressive logics other constructs, such as maximum number restrictions (⩽n R), also lead to non-deterministic expansion. Searching non- deterministic expansions is the main cause of intractability in tableau subsumption testing algorithms. r Existential role restriction concepts ∃R.C ∈L(x) cause the creation of new R-successor nodes, and universal role restriction concepts ∀R.C ∈L(x) extend the labels of R-successor nodes.

The tree is fully expanded when none of the expansion rules can be applied. If a fully expanded and clash-free tree can be found, then the algorithm returns satisﬁable; otherwise it returns unsatisﬁable. More expressive logics may require several extensions to this basic formalism. For example, with logics that include both role inclusion axioms and some form of cardinality restriction, it may be necessary to label edges with sets of role names instead of a single role name [Horrocks, 1998b]. It may also be necessary to add cycle detection (often called blocking) to the preconditions of some of the inference rules in order to guarantee termination [Buchheit et al., 1993a; Baader et al., 1996], the general idea being to stop the expansion of a branch whenever the same node label recurs in the branch. Blocking can also lead to a more complex correspondence between the structure created by the algorithm and a model of a satisﬁable concept, as the model may contain cycles or even be inﬁnite [Horrocks and Sattler, 1999].

9.4 Theory versus practice

So far, what we have seen is typical of theoretical presentations of tableau-based decision procedures. Such a presentation is sufﬁcient for soundness and complete- ness proofs, and is an essential starting point for the implementation of a reliable subsumption-testing algorithm. However, there often remains a considerable gap between the theoretical algorithm and an actual implementation. Additional points which may need to be considered are:

r the efﬁciency of the algorithm, in the theoretical (worst-case) sense; r the efﬁciency of the algorithm, in a practical (typical-case) sense; r how to use the algorithm for reasoning with unfoldable, general and cyclical KBs; r optimizing the (implementation of the) algorithm to improve the typical-case perfor- mance.

In the remainder of this section we will consider the ﬁrst three points, while in th f ll i ti ill id i l t ti d ti i ti t h i

∃∀-rule if 1. ∃R.C ∈L(x) 2. there is no y s.t. L(⟨x, y⟩) = R and C ∈L(y) 3. neither the ⊓-rule nor the ⊔-rule is applicable to L(x) then create a new node y and edge ⟨x, y⟩ with L(y) = {C} ∪{D | ∀R.D ∈L(x)} and L(⟨x, y⟩) = R

Fig. 9.2. Combined ∃∀-rule for ALC.

9.4.1 Worst-case complexity

When considering an implementation, it is sensible to start with an algorithm that is known to be theoretically efﬁcient, even if the implementation subsequently departs from the theory to some extent. Theoretically efﬁcient is taken to mean that the complexity of the algorithm is equal to the complexity of the satisﬁability problem for the logic, where this is known, or at least that consideration has been given to the worst-case complexity of the algorithm. This is not always the case, as the algorithm may have been designed to facilitate a soundness and completeness proof, with little consideration having been given to worst-case complexity, much less implementation. Apart from establishing an upper bound for the “hardness” of the problem, stud- ies of theoretical complexity can suggest useful implementation techniques. For example, a study of the complexity of the satisﬁability problem for ALC concepts with respect to a general KB has demonstrated that caching of intermediate results is required in order to stay in ExpTime [Donini et al., 1996a], while studying the complexity of the satisﬁability problem for SIN concepts has shown that a more sophisticated labeling and blocking strategy can be used in order to stay in PSpace [Horrocks et al., 1999]. One theoretically derived technique that is widely used in practice is the trace technique. This is a method for minimizing the amount of space used by the algorithm to store the tableau expansion tree. The idea is to impose an ordering on the application of expansion rules so that local propositional reasoning (ﬁnding a clash-free expansion of conjunctions and disjunctions using the ⊓-rule and ⊔-rule) is completed before new nodes are created using the ∃-rule. A successor created by an application of the ∃-rule, and any possible applications of the ∀-rule, can then be treated as an independent subproblem that returns either satisﬁable or unsatisﬁable, and the space used to solve it can be re-used in solving the next subproblem. A node x returns satisﬁable if there is a clash-free propositional solution for which any and all subproblems return satisﬁable; otherwise it returns unsatisﬁable. In algorithms where the trace technique can be used, the ∀-rule is often incorporated in the ∃-rule, giving a single rule as shown in Figure 9.2. Apart from minimizing space usage, the trace technique is generally viewed as a sensible way of organizing the expansion and the ﬂow of control within the algo- ith O d i th i i thi l b i d b bl ki

strategies [Buchheit et al., 1993a], although in some cases it is possible to use a more efﬁcient subset blocking technique that is independent of the ordering [Baader et al., 1996]. The trace technique relies on the fact that node labels are not affected by the expansion of their successors. This is no longer true when the logic includes inverse roles, because universal value restrictions in the label of a successor of a node x can augment L(x). This could invalidate the existing propositional solution for L(x), or invalidate previously computed solutions to subproblems in other successor nodes. For example, if

L(x) = {∃R.C, ∃S.(∀S−.(∀R.¬C))},

then x is obviously unsatisﬁable as expanding ∃S.(∀S−.(∀R.¬C)) will add ∀R.¬C to L(x), meaning that x must have an R-successor whose label contains both C and ¬C. The contradiction would not be discovered if the R-successor required by ∃R.C ∈L(x) were generated ﬁrst, found to be satisﬁable and then deleted from the tree in order to save space. The development of a PSpace algorithm for the SIN logic has shown that a modiﬁed version of the trace technique can still be used with logics that include inverse roles [Horrocks et al., 1999]. However, the modiﬁcation requires that the propositional solution and all subproblems are re-computed whenever the label of a node is augmented by the expansion of a universal value restriction in the label of one of its successors.

9.4.2 Typical-case complexity

Although useful practical techniques can be derived from the study of theoretical algorithms, it should be borne in mind that minimizing worst-case complexity may require the use of techniques that clearly would not be sensible in typical cases. This is because the kinds of pathological problem that would lead to worst-case behavior do not seem to occur in realistic applications. In particular, the amount of space used by algorithms does not seem to be a practical problem, whereas the time taken for the computation certainly is. For example, in experiments with the Fact system using the DL’98 test suite, available memory (200Mb) was never exhausted in spite of the fact that some single computations required hundreds of seconds of CPU time [Horrocks and Patel-Schneider, 1998b]. In other experiments using the Galen KB, computations were run for tens of thousands of seconds of CPU time without exhausting available memory. In view of these considerations, techniques that save space by recomputing are unlikely to be of practical value. The modiﬁed trace technique used in the PSpace SIN l ith ( S ti 9 4 1) f l i b bl t f ti l l

However, the more sophisticated labeling and blocking strategy, which allows the establishment of a polynomial bound on the length of branches, could be used not only in an implementation of the SIN algorithm, but also in implementations of more expressive logics where other considerations mean that the PSpace result no longer holds [Horrocks et al., 1999]. In practice, thepoor performanceoftableau algorithmsisduetonon-determinism in the expansion rules (for example the ⊔-rule), and the resulting search of different possible expansions. This is often treated in a very cursory manner in theoretical presentations. For soundness and completeness it is enough to prove that the search will always ﬁnd a solution if one exists, and that it will always terminate. For worst-case complexity, an upper bound on the size of the search space is all that is required. As this upper bound is invariably exponential with respect to the size of the problem, exploring the whole search space would inevitably lead to intractability for all but the smallest problems. When implementing an algorithm it is therefore vital to give much more careful consideration to non-deterministic expansion, in particular how to reduce the size of the search space and how to explore it in an efﬁcient manner. Many of the optimizations discussed in subsequent sections will be aimed at doing this, for example by using absorption to localize non-determinism in the KB, dependency directed backtracking to prune the search tree, heuristics to guide the search, and caching to avoid repetitive search.

9.4.3 Reasoning with a knowledge base

One area in which the theory and practice diverge signiﬁcantly is that of reasoning with respect to the axioms in a KB. This problem is rarely considered in detail: with less expressive logics the KB is usually restricted to being unfoldable, while with more expressive logics, all axioms can be treated as general axioms and dealt with via internalization. In either case it is sufﬁcient to consider an algorithm that tests the satisﬁability of a single concept, usually in negation normal form. In practice, it is much more efﬁcient to retain the structure of the KB for as long as possible, and to take advantage of it during subsumption/satisﬁability testing. One way in which this can be done is to use lazy unfolding – only unfolding concepts as required by the progress of the subsumption or satisﬁability testing algorithm [Baader et al., 1992a]. With a tableau algorithm, this means that a deﬁned concept A is only unfolded when it occurs in a node label. For example, if T contains the non-primitive deﬁnition axiom A ≡C, and the ⊓-rule is applied to a concept (A ⊓D) ∈L(x) so that A and D are added to L(x), then at this point A can be unfolded by replacing it with C. Used in this way, lazy unfolding already has the advantage that it avoids f ldi f i l t b t ith b t di ti

is discovered without fully expanding the tree, or because a non-deterministic expansion choice leads to a complete and clash-free tree. However, a much greater increase in efﬁciency can be achieved if, instead of replacing concept names with their deﬁnitions, names are retained when their deﬁnitions are added. This is be- cause the discovery of a clash between concept names can avoid expansion of their deﬁnitions [Baader et al., 1992a]. In general, lazy unfolding can be described as additional tableau expansion rules, deﬁned as follows.

U1-rule if 1. A ∈L(x) and (A ≡C) ∈T 2. C /∈L(x) then L(x) −→L(x) ∪{C}

U2-rule if 1. ¬A ∈L(x) and (A ≡C) ∈T 2. ¬C /∈L(x) then L(x) −→L(x) ∪{¬C}

U3-rule if 1. A ∈L(x) and (A ⊑C) ∈T 2. C /∈L(x) then L(x) −→L(x) ∪{C}.

The U1-rule and U2-rule reﬂect the symmetry of the equality relation in the non- primitive deﬁnition A ≡C, which is equivalent to A ⊑C and ¬A ⊑¬C. The U3-rule on the other hand reﬂects the asymmetry of the subsumption relation in the primitive deﬁnition A ⊑C. Treating all the axioms in the KB as general axioms, and dealing with them via internalization, is also highly inefﬁcient. For example, if T contains an axiom A ⊑C, where A is a concept name not appearing on the left-hand side of any other axiom, then it is easy to deal with the axiom using the lazy unfolding technique, simply adding C to the label of any node in which A appears. Treating all axioms as general axioms would be equivalent to applying the following additional tableau expansion rules:

I1-rule if 1. (C ≡D) ∈T 2. (D ⊔¬C) /∈L(x) then L(x) −→L(x) ∪{(D ⊔¬C)}

I2-rule if 1. (C ≡D) ∈T 2. (¬D ⊔C) /∈L(x) then L(x) −→L(x) ∪{(¬D ⊔C)}

I3-rule if 1. (C ⊑D) ∈T 2. (D ⊔¬C) /∈L(x) th L( ) L( ) ∪{(D C)}

With (A ⊑C) ∈T , this would result in the disjunction (C ⊔¬A) being added to the label of every node, leading to non-deterministic expansion and search, the main cause of empirical intractability. The solution to this problem is to divide the KB into two components, an unfoldable part Tu and a general part Tg, such that Tg = T \ Tu, and Tu contains unique, acyclic, deﬁnition axioms. This is easily achieved, e.g., by initializing Tu to ∅(which is obviously unfoldable), then for each axiom X in T , adding X to Tu if Tu ∪X is still unfoldable, and adding X to Tg otherwise.3 It is then possible to use lazy unfolding to deal with Tu, and internalization to deal with Tg. Given that the satisﬁability-testing algorithm includes some sort of cycle checking, such as blocking, then it is even possible to be a little less conserva- tive with respect to the deﬁnition of Tu by allowing it to contain cyclic primitive deﬁnition axioms, for example axioms of the form A ⊑∃R.A. Lazy unfolding will ensure that AI ⊆∃R.AI by adding ∃R.A to every node containing A, while blocking will take care of the non-termination problem that such an axiom would otherwise cause [Horrocks, 1997b]. Moreover, multiple primitive deﬁnitions for a single name can be added to Tu, or equivalently merged into a single deﬁnition using the equivalence

(A ⊑C1), . . . , (A ⊑Cn) ⇐⇒ A ⊑(C1 ⊓· · · ⊓Cn).

However, if Tu contains a non-primitive deﬁnition axiom A ≡C, then it cannot contain any other deﬁnitions for A, because this would be equivalent to allowing general axioms in Tu. For example, given a general axiom C ⊑D, this could be added to Tu as A ⊑D and A ≡C, where A is a new name not appearing in T . Moreover, certain kinds of non-primitive cycles cannot be allowed as they can be used to constrain possible models a way that would not be reﬂected by unfolding. For example, if (A ≡¬A) ∈T for some concept name A, then the domain of all valid interpretations of T must be empty, and T |= C ⊑D for all concepts C and D [Horrocks and Tobies, 2000].

9.5 Optimization techniques

The Kris system demonstrated that by taking a well-designed tableau algorithm, and applying some reasonable implementation and optimization techniques (such as lazy expansion), it is possible to obtain a tableau-based DL system that behaves reasonably well in typical cases, and compares favorably with systems based on structural algorithms [Baader et al., 1992a]. However, this kind of system is still much too slow to be usable in many realistic applications. Fortunately, it is possible

3

to achieve dramatic improvements in typical-case performance by using a wider range of optimization techniques. As DL systems are often used to classify a KB, a hierarchy of optimization techniques is naturally suggested based on the stage of the classiﬁcation process at which they can be applied.

(i) Pre-processing optimizations that try to modify the KB so that classiﬁcation and sub- sumption testing are easier. (ii) Partial ordering optimizations that try to minimize the number of subsumption tests required in order to classify the KB. (iii) Subsumption optimizations that try to avoid performing a potentially expensive satis- ﬁability test, usually by substituting a cheaper test. (iv) Satisﬁability optimizations that try to improve the typical-case performance of the underlying satisﬁability tester.

9.5.1 Pre-processing optimizations

The axioms that constitute a DL KB may have been generated by a human knowl- edge engineer, as is typically the case in ontological engineering applications, or be the result of some automated mapping from another formalism, as is typically the case in DB schema and query reasoning applications. In either case it is un- likely that a great deal of consideration was given to facilitating the subsequent reasoning procedures; the KB may, for example, contain considerable redundancy and may make unnecessary use of general axioms. As we have seen, general ax- ioms are costly to reason with due to the high degree of non-determinism that they introduce. It is, therefore, useful to preprocess the KB, applying a range of syntactic simpliﬁ- cations and manipulations. The ﬁrst of these, normalization, tries to simplify the KB by identifying syntactic equivalences, contradictions and tautologies. The second, absorption, tries to eliminate general axioms by augmenting deﬁnition axioms.

9.5.1.1 Normalization

In realistic KBs, at least those manually constructed, large and complex concepts are seldom described monolithically, but are built up from a hierarchy of named concepts whose descriptions are less complex. The lazy unfolding technique described above can use this structure to provide more rapid detection of con- tradictions. The effectiveness of lazy unfolding is greatly increased if a contradiction between two concepts can be detected whenever one is syntactically equivalent to the negation of the other; for example, we would like to discover a direct contra- di ti b t (C D) d ( D C) Thi b hi d b t f i

Norm(A) = A for atomic concept name A Norm(¬C) = Simp(¬ Norm(C)) Norm(C1 ⊓. . . ⊓Cn) = Simp(⊓{Norm(C1)} ∪. . . ∪{Norm(Cn)}) Norm(C1 ⊔. . . ⊔Cn) = Norm(¬(¬C1 ⊓. . . ⊓¬Cn)) Norm(∀R.C) = Simp(∀R. Norm(C)) Norm(∃R.C) = Norm(¬∀R.¬C)

Simp(A) = A for atomic concept name A

  

⊥ if C = ⊤ ⊤ if C = ⊥ Simp(D) if C = ¬D ¬C otherwise

Simp(¬C) =

 

      

⊥ if ⊥∈S ⊥ if {C, ¬C} ⊆S ⊤ if S = ∅ Simp(S \ {⊤}) if ⊤∈S Simp(⊓P ∪S \ {⊓{P}}) if ⊓{P} ∈S ⊓S otherwise

Simp(⊓S) =

     

Simp(∀R.C) =  ⊤ if C = ⊤ R.C otherwise

Fig. 9.3. Normalization and simpliﬁcation functions for ALC.

all concepts into a syntactic normal form, and by directly detecting contradictions caused by non-atomic concepts as well as those caused by concept names. In Description Logics there is often redundancy in the set of concept-forming operators. In particular, logics with full negation often provide pairs of operators, either one of which can be eliminated in favor of the other by using negation. Conjunction and disjunction operators are an example of such a pair, and one can be eliminated in favor of the other using De Morgan’s laws. In syntactic normal form, all concepts are transformed so that only one of each such pair appears in the KB (it does not matter which of the two is chosen, the important thing is uniformity). In ALC, for example, all concepts could be transformed into (possibly negated) value restrictions, conjunctions and atomic concept names, with (¬D ⊔¬C) being transformed into ¬(D ⊓C). An important reﬁnement is to treat conjunctions as sets (written ⊓{C1, . . . , Cn}) so that reordering or repeating the conjuncts does not affect equivalence; for example, (D ⊓C) would be normalized as ⊓{C, D}.4 Nor- malization can also include a range of simpliﬁcations so that syntactically obvious contradictions and tautologies are detected; for example, ∃R.⊥could be simpliﬁed to ⊥. Figure 9.3 describes normalization and simpliﬁcation functions Norm and Simp for ALC. These can be extended to deal with more expressive logics by adding appropriate normalizations (and possibly additional simpliﬁcations). For example, number restrictions can be dealt with by adding the normalizations Norm(⩽n R) = ¬⩾(n + 1)R and Norm(⩾nR) = ⩾nR, and the simpliﬁcation Simp(⩾0R) = ⊤.

Normalized and simpliﬁed concepts may not be in negation normal form, but they can be dealt with by treating them exactly like their non-negated counterparts. For example, ¬⊓{C, D} can be treated as (¬C ⊔¬D) and ¬∀R.C can be treated as ∃R.¬C. In the remainder of this chapter we will use both forms interchangeably, choosing whichever is most convenient. Additional simpliﬁcations would clearly be possible. For example, ∀R.C ⊓ ∀R.D could be simpliﬁed to ∀R. Norm(C ⊓D). Which simpliﬁcations it is sen- sible to perform is an implementation decision that may depend on a cost-beneﬁt analysis with respect to some particular application. Empirically, simpliﬁcation seems to be more effective with mechanically generated KBs and satisﬁability problems, in particular those where the number of different roles is very small. With this kind of problem it is quite common for satisﬁability tests to be greatly simpliﬁed, or even completely avoided, by simplifying part or all of the concept to either ⊤or ⊥. In the benchmark tests used for the Tableaux’98 comparison of modal logic theorem provers, for example, some classes of problem can be completely solved via this mechanism [Heuerding and Schwendimann, 1996; Balsiger and Heuerding, 1998]. If the subsumption-testing algorithm is to derive maximum beneﬁt from normal- ization, it is important that it directly detect contradictions caused by non-atomic concepts as well as those caused by concept names; for example the occurrence of both ⊓{C, D} and ¬⊓{C, D} in a node label should be detected as a contra- diction without the need for further expansion. This can be achieved by replacing all equivalent (identically encoded) non-atomic concepts C in the KB with a new atomic concept name A, and adding the axiom A ≡C to the KB. For example, all occurrences of ⊓{C, D} in a KB could be replaced with CD, and the axiom CD ≡⊓{C, D} added to the KB. It is necessary to distinguish these newly introduced system names from user names appearing in the original KB, as system names need not be classiﬁed (indeed, it would be very confusing for the user if they were). In practice, it is often more convenient to avoid this problem by using pointer or object identiﬁers to refer to concepts, with the same identiﬁer always being associated with equivalent concepts. A contradiction is then detected whenever a pointer/identiﬁer and its negation occur in a node label. The advantages of the normalization and simpliﬁcation procedure are:

r It is easy to implement and could be used with most logics and algorithms. r Subsumption/satisﬁability problems can often be simpliﬁed, and sometimes even com- pletely avoided, by detecting syntactically obvious satisﬁability and unsatisﬁability. r It complements lazy unfolding and improves early clash detection. r The elimination of redundancies and the sharing of syntactically equivalent structures

C1 C2 D C1 D C2 C D1 D2 C D1 and C D2

Fig. 9.4. Axiom equivalences used in absorption.

The disadvantages are:

r The overhead involved in the procedure, although this is relatively small. r For very unstructured KBs there may be no beneﬁt, and it might even slightly increase the size of the KB.

9.5.1.2 Absorption

As we have seen in Section 9.4.3, general axioms are costly to reason with due to the high degree of non-determinism that they introduce. With a tableau algorithm, a disjunction is added to the label of each node for each general axiom in the KB. This leads to an exponential increase in the search space as the number of nodes and axioms increases. For example, with 10 nodes and a KB containing 10 general axioms there are already 100 disjunctions, and they can be non-deterministically expanded in 2100 different ways. For a KB containing large numbers of general axioms (there are 1,214 in the Galen medical terminology KB) this can degrade performance to the extent that subsumption testing is effectively non-terminating. It therefore makes sense to eliminate general axioms from the KB whenever possible. Absorption is a technique that tries to do this by absorbing them into primitive deﬁnition axioms. The basic idea is that a general axiom of the form C ⊑D, where C may be a non-atomic concept, is manipulated (using the equiva- lences in Figure 9.4) so that it has the form of a primitive deﬁnition A ⊑D′, where A is an atomic concept name. This axiom can then be merged into an existing prim- itive deﬁnition A ⊑C′ to give A ⊑C′ ⊓D′. For example, an axiom stating that all three-sided geometric ﬁgures (i.e., triangles) also have three angles

geometric-figure ⊓∃angles.three ⊑∃sides.three

could be transformed into an axiom stating that all geometric ﬁgures either have three sides or do not have three angles

geometric-figure ⊑∃sides.three ⊔¬∃angles.three

and then absorbed into the primitive deﬁnition of geometric ﬁgure (geometric- figure ⊑figure) to give

geometric-figure ⊑figure ⊓(∃sides.three ⊔¬∃angles.three).

Given a KB divided into an unfoldable part Tu and a general part Tg, the following procedure can be used to try to absorb the axioms from Tg into primitive deﬁnitions i T Fi t t T ′ i i iti li d t b t d i (C D) T

replaced with an equivalent pair of axioms C ⊑D and ¬C ⊑¬D. Then for each axiom (C ⊑D) ∈Tg:

(i) Initialize a set G = {¬D, C}, representing the axiom in the form ⊤⊑¬⊓{¬D, C} (i.e., ⊤⊑D ⊔¬C). (ii) If for some A ∈G there is a primitive deﬁnition axiom (A ⊑C) ∈Tu, then absorb the general axiom into the primitive deﬁnition axiom so that it becomes

A ⊑⊓{C, ¬⊓(G \ {A})},

and exit. (iii) If for some A ∈G there is an axiom (A ≡D) ∈Tu, then replace A ∈G with D

G −→{D} ∪G \ {A},

and return to step (ii). (iv) If for some ¬A ∈G there is an axiom (A ≡D) ∈Tu, then replace ¬A ∈G with ¬D

G −→{¬D} ∪G \ {¬A},

and return to step (ii). (v) IfthereissomeC ∈GsuchthatC isoftheform⊓S,thenuseassociativitytosimplify G

G −→S ∪G \ {⊓S},

and return to step (ii). (vi) If there is some C ∈G such that C is of the form ¬⊓S, then for every D ∈S try to absorb (recursively)

{¬D} ∪G \ {¬⊓S},

and exit. (vii) Otherwise, the axiom could not be absorbed, so add ¬⊓G to T ′ g

T ′ g −→T ′ g ∪¬⊓G,

and exit.

Note that this procedure allows parts of axioms to be absorbed. For example, given axioms (A ⊑D1) ∈Tu and (A ⊔∃R.C ⊑D2) ∈Tg, then the general axiom would be partly absorbed into the deﬁnition axiom to give (A ⊑(D1 ⊓D2)) ∈Tu, leaving a smaller general axiom (¬⊓{¬D2, ∃R.C}) ∈Tg. When this procedure has been applied to all the axioms in Tg, then T ′ g represents those (parts of) axioms that could not be absorbed. The axioms in T ′ g are already in the form ⊤⊑C, so that ⊓T ′ g is the concept that must be added to every node in the tableau expansion. This can be done using a universal role, as described in Subsection 9.2.4, although in practice it may be simpler just to add the concept to th l b l f h l t d d

The absorption process is clearly non-deterministic. In the ﬁrst place, there may be more than one way to divide T into unfoldable and general parts. For example, if T contains multiple non-primitive deﬁnitions for some concept A, then one of them must be selected as a deﬁnition in Tu while the rest are treated as general axioms in Tg. Moreover, the absorption procedure itself is non-deterministic as G may contain more than one primitive concept name into which the axiom could be absorbed. For example, in the case where {A1, A2} = G, and there are two primitive deﬁnition axioms A1 ⊑C and A2 ⊑D in Tu, then the axiom could be absorbed either into the deﬁnition of A1 to give A1 ⊑C ⊓¬⊓{A2} (equivalent to A1 ⊑C ⊓¬A2) or into the deﬁnition of A2 to give A2 ⊑C ⊓¬⊓{A1} (equivalent to A2 ⊑C ⊓¬A1). It would obviously be sensible to choose the “best” absorption (the one that maximized empirical tractability), but it is not clear how to do this—in fact it is not even clear how to deﬁne “best” in this context [Horrocks and Tobies, 2000]. If T contains more than one deﬁnition axiom for a given concept name, then empirical evidence suggests that efﬁciency is improved by retaining as many non- primitive deﬁnition axioms in Tu as possible. Another intuitively obvious possibility is to preferentially absorb into the deﬁnition axiom of the most speciﬁc primitive concept, although this only helps in the case that A1 ⊑A2 or A2 ⊑A1. Other more sophisticated schemes might be possible, but have yet to be investigated. The advantages of absorption are:

r It can lead to a dramatic improvement in performance. For example, without absorption, satisﬁability of the Galen KB (i.e., the satisﬁability of ⊤) could not be proved by either FactorDlp,evenafterseveralweeksofCPUtime.Afterabsorption,theproblembecomes so trivial that the CPU time required is hard to measure. r It is logic and algorithm independent.

The disadvantage is the overhead required for the pre-processing, although this is generally small compared to classiﬁcation times. However, the procedure described isalmostcertainlysuboptimal,andtryingtoﬁndanoptimalabsorptionmaybemuch more costly.

9.5.2 Optimizing classiﬁcation

DL systems are often used to classify a KB, that is to compute a partial ordering or hierarchy of named concepts in the KB based on the subsumption relationship. As subsumption testing is always potentially costly, it is important to ensure that the classiﬁcation process uses the smallest possible number of tests. Minimizing the number of subsumption tests required to classify a concept in the concept hierarchy can be treated as an abstract order-theoretic problem which is independent of the d i l ti H dditi l ti i ti b hi d b i

the structure of concepts to reveal obvious subsumption relationships and to control the order in which concepts are added to the hierarchy (where this is possible). The concept hierarchy is usually represented by a directed acyclic graph where nodes are labeled with sets of concept names (because multiple concept names may be logically equivalent), and edges correspond with subsumption relationships. The subsumption relation is both transitive and reﬂexive, so a classiﬁed concept A subsumes a classiﬁed concept B if either:

(i) both A and B are in the label of some node x, or (ii) A is in the label of some node x, there is an edge ⟨x, y⟩in the graph, and the concept(s) in the label of node y subsume B.

It will be assumed that the hierarchy always contains a top node (a node whose label includes ⊤) and a bottom node (a node whose label includes ⊥) such that the top node subsumes the bottom node. If the KB is unsatisﬁable then the hierarchy will consist of a single node whose label includes both ⊤and ⊥. Algorithms based on traversal of the concept hierarchy can be used to minimize the number of tests required in order to add a new concept [Baader et al., 1992a]. The idea is to compute a concept’s subsumers by searching down the hierarchy from the top node (the top search phase) and its subsumees by searching up the hierarchy from the bottom node (the bottom search phase). When classifying a concept A, the top search takes advantage of the transitivity of the subsumption relation by propagating failed results down the hierarchy. It concludes, without performing a subsumption test, that if A is not subsumed by B, then it cannot be subsumed by any other concept that is subsumed by B:

T ̸|= A ⊑B and T |= B′ ⊑B implies T ̸|= A ⊑B′.

To maximize the effect of this strategy, a modiﬁed breadth-ﬁrst search is used [Ellis, 1992] which ensures that a test to discover if B subsumes A is never performed until it has been established that A is subsumed by all of the concepts known to subsume B. The bottom search uses a corresponding technique, testing if A subsumes B only when A is already known to subsume all those concepts that are subsumed by B. Information from the top search is also used by conﬁning the bottom search to those concepts which are subsumed by all of A’s subsumers. This abstract partial ordering technique can be enhanced by taking advantage of the structure of concepts and the axioms in the KB. If the KB contains an axiom A ⊑C or A ≡C, then C is said to be a told subsumer of A. If C is a conjunctive concept (C1 ⊓· · · ⊓Cn), then from the structural subsumption relationship

D ⊑(C C ) i li D ⊑C d d D ⊑C

it is possible to conclude that C1, . . . , Cn are also told subsumers of A. Moreover, due to the transitivity of the subsumption relation, any told subsumers of C1, . . . , Cn are also told subsumers of A. Before classifying A, all of its told subsumers which have already been classiﬁed, and all their subsumers, can be marked as subsumers of A; subsumption tests with respect to these concepts are therefore rendered un- necessary. This idea can be extended in the obvious way to take advantage of a structural subsumption relationship with respect to disjunctive concepts,

(C1 ⊔· · · ⊔Cn) ⊑D implies C1 ⊑D and . . . and Cn ⊑D.

If the KB contains an axiom A ≡C and C is a disjunctive concept (C1 ⊔· · · ⊔Cn), then A is a told subsumer of C1, . . . , Cn. To maximize the effect of the told subsumer optimization, concepts should be classiﬁed in deﬁnition order. This means that a concept A is not classiﬁed until all of its told subsumers have been classiﬁed. When classifying an unfoldable KB, this ordering can be exploited by omitting the bottom search phase for primitive concept names and assuming that they only subsume (concepts equivalent to) ⊥. This is possible because, with an unfoldable KB, a primitive concept can only subsume concepts for which it is a told subsumer. Therefore, as concepts are classiﬁed in deﬁnition order, a primitive concept will always be classiﬁed before any of the concepts that it subsumes. This additional optimization cannot be used with a general KB because, in the presence of general axioms, it can no longer be guaranteed that a primitive concept will only subsume concepts for which it is a told subsumer. For example, given a KB T such that

T = {A ⊑∃R.C, ∃R.C ⊑B},

then B is not a told subsumer of A, and A may be classiﬁed ﬁrst. However, when B is classiﬁed the bottom search phase will discover that it subsumes A due to the axiom ∃R.C ⊑B. The advantages of the enhanced traversal classiﬁcation method are:

r It can signiﬁcantly reduce the number of subsumption tests required in order to classify a KB [Baader et al., 1992a]. r It is logic and (subsumption) algorithm independent.

There appear to be few disadvantages to this method, and it is used (in some form) in most implemented DL systems.

9.5.3 Optimizing subsumption testing

The classiﬁcation optimizations described in Subsection 9.5.2 help to reduce the b f b ti t t th t f d h l if i KB d th

{A, C, ∃R1.C1, ∃R2.C2} {¬B, D, ∃R3.C3}

R2

R1

R3

{C1} {C2}

{C3}

{A, ¬B, C, D, ∃R1.C1, ∃R2.C2, ∃R3.C3}

R1

R3 R2

C1 C2

C3

Fig. 9.5. Joining expansion trees for A and ¬B.

combination of normalization, simpliﬁcation and lazy unfolding facilitates the detection of “obvious” subsumption relationships by allowing unsatisﬁability to be rapidly demonstrated. However, detecting “obvious” non-subsumption (satis- ﬁability) is more difﬁcult for tableau algorithms. This is unfortunate as concept hierarchies from realistic applications are typically broad, shallow and tree-like. The top search phase of classifying a new concept A in such a hierarchy will there- fore result in several subsumption tests being performed at each node, most of which are likely to fail. These failed tests could be very costly (if, for example, proving the satisﬁability of A is a hard problem), and they could also be very repetitive. This problem can be tackled by trying to use cached results from previous tableau tests to prove non-subsumption without performing a new satisﬁability test. For example, given two concepts A and B deﬁned by the axioms

A ≡ C ⊓∃R1.C1 ⊓∃R2.C2, and B ≡ ¬D ⊔∀R3.¬C3,

then A is not subsumed by B if the concept A ⊓¬B is satisﬁable. If tableau expansion trees for A and ¬B have already been cached, then the satisﬁability of the conjunction can be demonstrated by a tree consisting of the trees for A and ¬B joined at their root nodes, as shown in Figure 9.5 (note that ¬B ≡D ⊓∃R3.C3). Given two fully expanded and clash-free tableau expansion trees T1 and T2 representing models of (satisﬁable) concepts A and ¬B respectively, the tree created by joining T1 and T2 at their root nodes is a fully expanded and clash-free tree representing a model of A ⊓¬B provided that the union of the root node labels does not contain a clash and that no tableau expansion rules are applicable to the new tree. For most logics, this can be ascertained by examining the labels of the t d d th l b l f th d ti th ith th i With

the ALC logic for example, if x1 and x2 are the two root nodes, then the new tree will be fully expanded and clash-free provided that

(i) the union of the root node labels does not contain an immediate contradiction, i.e., there is no C such that {C, ¬C} ⊆L(x1) ∪L(x2), and (ii) there is no interaction between value restrictions in the label of one root node and edges connecting the other root node with its successors that might make the ∀-rule applicable to the joined tree, i.e., there is no R such that ∀R.C ∈L(x1) and T2 has an edge ⟨x2, y⟩ with L(⟨x2, y⟩) = R, or ∀R.C ∈L(x2) and T1 has an edge ⟨x1, y⟩with L(⟨x1, y⟩) = R.

With more expressive logics it may be necessary to consider other interactions that could lead to the application of tableau expansion rules. With a logic that included number restrictions, for example, it would be necessary to check that these could not be violated by the root node successors in the joined tree. It would be possible to join trees in a wider range of cases by examining the potential interactions in more detail. For example, a value restriction ∀R.C ∈L(x1) and an R labeled edge ⟨x2, y⟩would not make the ∀-rule applicable to the joined tree if C ∈L(x2). However, considering only root nodes and edges provides a relatively fast test and reduces the storage required by the cache. Both the time required by the test and the size of the cache can be reduced even further by only storing relevant components of the root node labels and edges from the fully expanded and clash-free tree that demonstrates the satisﬁability of a concept. In the case of ALC, the relevant components from a tree demonstrating the satisﬁability of a concept A are the set of (possibly negated) atomic concept names in the root node label (denoted Lc(A)), the set of role names in value restrictions in the root node label (denoted L∀(A)), and the set of role names labeling edges connecting the root node with its successors (denoted L∃(A)).5 These components can be cached as a triple (Lc(A), L∀(A), L∃(A)). When testing if A is subsumed by B, the algorithm can now proceed as follows.

(i) If any of (Lc(A), L∀(A), L∃(A)), (Lc(¬A), L∀(¬A), L∃(¬A)), (Lc(B), L∀(B), L∃(B)) or (Lc(¬B), L∀(¬B), L∃(¬B)) are not in the cache, then perform the appropriate satisﬁability tests and update the cache accordingly. In the case where a concept C is unsatisﬁable, Lc(C) = {⊥} and Lc(¬C) = {⊤}. (ii) Conclude that A ⊑B (A ⊓¬B is not satisﬁable) if Lc(A) = {⊥} or Lc(B) = {⊤}. (iii) Conclude that A ̸⊑B (A ⊓¬B is satisﬁable) if (a) Lc(A) = {⊤} and Lc(B) ̸= {⊤}, or (b) Lc(A) ̸= {⊥} and Lc(B) = {⊥}, or (c) L∀(A) ⊓L∃(B) = ∅, L∀(B) ⊓L∃(A) = ∅, ⊥/∈Lc(A) ∪Lc(B), and there is no C such that {C, ¬C} ⊆Lc(A) ∪Lc(B).

5 Consideration can be limited to atomic concept names because expanded conjunction and disjunction concepts

(iv) Otherwise perform a satisﬁability test on A ⊓¬B, concluding that A ⊑B if it is not satisﬁable and that A ̸⊑B if it is satisﬁable.

When a concept A is added to the hierarchy, this procedure will result in satisﬁability tests immediately being performed for both A and ¬A. During the subsequent top search phase, at each node x in the hierarchy such that some C ∈L(x) subsumes A, it will be necessary to perform a subsumption test for each subsumee node y (unless some of them can be avoided by the classiﬁcation opti- mizations discussed in Subsection 9.5.2). Typically only one of these subsumption tests will lead to a full satisﬁability test being performed, the rest being shown to be obvious non-subsumptions using the cached partial trees. Moreover, the satisﬁabil- itytestthatisperformedwilloftenbean“obvious”subsumption,andunsatisﬁability will rapidly be demonstrated. The optimization is less useful during the bottom search phase as nodes in the concept hierarchy are typically connected to only one subsuming node. The excep- tion to this is the bottom (⊥) node, which may be connected to a very large number of subsuming nodes. Again, most of the subsumption tests that would be required by these nodes can be avoided by demonstrating non-subsumption using cached partial trees. The caching technique can be extended in order to avoid the construction of obviously satisﬁable and unsatisﬁable subtrees during tableau expansion. For example, if some leaf node x is about to be expanded, and L(x) = {A}, unfolding and expanding L(x) is clearly unnecessary if A is already known to be either satis- ﬁable (i.e., (Lc(A), L∀(A), L∃(A)) is in the cache and Lc(A) ̸= {⊥}) or unsatisﬁable (i.e., (Lc(A), L∀(A), L∃(A)) is in the cache and Lc(A) = {⊥}). This idea can be further extended by caching (when required) partial trees for all the syntactically distinct concepts discovered by the normalization and simpli- ﬁcation process, and trying to join cached partial trees for all the concepts in a leaf node’s label before starting the expansion process. For example, with the logic ALC and a node x such that

L(x) = {C1, . . . , Cn},

x is unsatisﬁable if for some 1 ⩽i ⩽n, Lc(Ci) = {⊥}, and x is satisﬁable if for all 1 ≤i ≤n and i < j ≤n,

(i) L∀(Ci) ⊓L∃(C j) = ∅, (ii) L∃(Ci) ⊓L∀(C j) = ∅, and (iii) there is no C such that {C, ¬C} ⊆Lc(Ci) ∪Lc(C j).

As before, additional interactions may need to be considered with more expres- i l i M ith l i th t t i l th ff t th t th

subtree might have on its predecessor must also be considered. For example, if x is an R-successor of some node y, and R−∈L∀(Ci) for one of the Ci ∈L(x), then the expanded L(x) represented by the cached partial trees would contain a value restriction of the form ∀R−.D that could augment L(y). The advantages of caching partial tableau expansion trees are:

r When classifying a realistic KB, most satisﬁability tests can be avoided. For example, the number of satisﬁability tests performed by the Fact system when classifying the Galen KB is reduced from 122,695 to 23,492, a factor of over 80%. r Without caching, some of the most costly satisﬁability tests are repeated (with minor variations) many times. The time saving due to caching is therefore even greater than the saving in satisﬁability tests.

The disadvantages are:

r The overhead of performing satisﬁability tests on individual concepts and their negations in order to generate the partial trees that are cached. r The overhead of storing the partial trees. This is not too serious a problem as the number of trees cached is equal to the number of named concepts in the KB (or the number of syntactically distinct concepts if caching is used in subproblems). r The overhead of determining if the cached partial trees can be merged, which is wasted if they cannot be. r Its main use is when classifying a KB, or otherwise performing many similar satisﬁability tests. It is of limited value when performing single tests.

9.5.4 Optimizing satisﬁability testing

In spite of the various techniques outlined in the preceding sections, at some point the DL system will be forced to perform a “real” subsumption test, which for a tableau-based system means testing the satisﬁability of a concept. For expressive logics, such tests can be very costly. However, a range of optimizations can be applied that dramatically improve performance in typical cases. Most of these are aimed at reducing the size of the search space explored by the algorithm as a result of applying non-deterministic tableau expansion rules.

9.5.4.1 Semantic branching search

Standard tableau algorithms use a search technique based on syntactic branching. When expanding the label of a node x, syntactic branching works by choosing an unexpanded disjunction (C1 ⊔· · · ⊔Cn) in L(x) and searching the different models obtained by adding each of the disjuncts C1, . . . , Cn to L(x) [Giunchiglia and Sebastiani, 1996b]. As the alternative branches of the search tree are not dis- joint, there is nothing to prevent the recurrence of an unsatisﬁable disjunct in dif- f t b h Th lti t d i ld b tl if di i th

x

L(x) = {(A ⊔B), (A ⊔C)}

⊔ ⊔

x

L(x) ∪{B} L(x) ∪{A} ⇒clash x

⊔ ⊔

L(x) ∪{A} ⇒clash x x

L(x) ∪{C}

Fig. 9.6. Syntactic branching search.

expansion of a node x, where {(A ⊔B), (A ⊔C)} ⊆L(x) and A is an unsatisﬁable concept, could lead to the search pattern shown in Figure 9.6, in which the unsat- isﬁability of L(x) ∪A must be demonstrated twice. This problem can be dealt with by using a semantic branching technique adapted from the Davis–Putnam–Logemann–Loveland procedure (DPLL) commonly used to solve propositional satisﬁability (SAT) problems [Davis and Putnam, 1960; Davis et al., 1962; Freeman, 1996].6 Instead of choosing an unexpanded disjunction in L(x), a single disjunct D is chosen from one of the unexpanded disjunctions in L(x). The two possible subtrees obtained by adding either D or ¬D to L(x) are then searched. Because the two subtrees are strictly disjoint, there is no possibility of wasted search as in syntactic branching. Note that the order in which the two branches are explored is irrelevant from a theoretical viewpoint, but may offer further optimization possibilities (see Section 9.5.4.4). The advantages of semantic branching search are:

r A great deal is known about the implementation and optimization of the DPLL algorithm. In particular, both local simpliﬁcation (see Subsection 9.5.4.2) and heuristic guided search (see Subsection 9.5.4.4) can be used to try to minimize the size of the search tree (although it should be noted that both these techniques can also be adapted for use with syntactic branching search). r It can be highly effective with some problems, particularly randomly generated problems [Horrocks and Patel-Schneider, 1999].

The disadvantages are:

r It is possible that performance could be degraded by adding the negated disjunct in the second branch of the search tree, for example if the disjunct is a very large or complex concept. However this does not seem to be a serious problem in practice, with semantic branching rarely exhibiting signiﬁcantly worse performance than syntactic branching. r Its effectiveness is problem dependent. It is most effective with randomly generated problems, particularly those that are over-constrained (likely to be unsatisﬁable). It is also effective with some of the hand crafted problems from the Tableaux’98 benchmark suite. However, it appears to be of little beneﬁt when classifying realistic KBs [Horrocks and Patel-Schneider, 1998a].

x

L(x) = {(A ⊔B), (A ⊔C)}

⊔ ⊔

L(x) ∪{A} ⇒clash L(x) ∪{¬A, B, C} x x

Fig. 9.7. Semantic branching search.

9.5.4.2 Local simpliﬁcation

Local simpliﬁcation is another technique used to reduce the size of the search space resulting from the application of non-deterministic expansion rules. Before any non-deterministic expansion of a node label L(x) is performed, disjunctions in L(x) are examined, and if possible simpliﬁed. The simpliﬁcation most commonly used (although by no means the only one possible) is to deterministically expand disjunctions in L(x) that present only one expansion possibility and to detect a clash when a disjunction in L(x) has no expansion possibilities. This simpliﬁcation has been called Boolean constraint propagation (BCP) [Freeman, 1995]. In effect, the inference rules

¬C1, . . . , ¬Cn, C1 ⊔· · · ⊔Cn ⊔D

D and C1, . . . , Cn, ¬C1 ⊔· · · ⊔¬Cn ⊔D

D

are being used to simplify the conjunctive concept represented by L(x). For example, given a node x such that

{(C ⊔(D1 ⊓D2)), (¬D1 ⊔¬D2 ⊔C), ¬C} ⊆L(x),

BCP deterministically expands the disjunction (C ⊔(D1 ⊓D2)), adding (D1 ⊓D2) to L(x), because ¬C ∈L(x). The deterministic expansion of (D1 ⊓D2) adds both D1 and D2 to L(x), allowing BCP to identify (¬D1 ⊔¬D2 ⊔C) as a clash (without any branching having occurred), because {D1, D2, ¬C} ⊆L(x). BCP simpliﬁcation is usually described as an integral part of SAT-based algo- rithms [Giunchiglia and Sebastiani, 1996a], but it can also be used with syntactic branching. However, it is more effective with semantic branching as the negated concepts introduced by failed branches can result in additional simpliﬁcations. Tak- ing the above example of {(A ⊔B), (A ⊔C)} ⊆L(x), adding ¬A to L(x) allows BCP to deterministically expand both of the disjunctions using the simpliﬁcations (A ⊔B) ∧¬A ⇒B and (A ⊔C) ∧¬A ⇒C. The reduced search space resulting from the combination of semantic branching and BCP is shown in Figure 9.7. The advantages of local simpliﬁcation are:

r It is applicable to a wide range of logics and algorithms. I i h i f h h

x

⊔

⊔

x x

L(x) ∪{C1} (x) ∪{¬C1, D1}

L

⊔

⊔

x

L(x) ∪{¬C2, D2}

⊔ L(x) ∪{Cn-1}

x

⊔

x

x L(x) ∪{¬Cn, Dn}

L(x) ∪{Cn}

R

y L(y) = {(A ⊓B), ¬A, A, B} R

y

L(y) = {(A ⊓B), ¬A, A, B}

clash clash clash . . . clash

Fig. 9.8. Thrashing in backtracking search.

The disadvantages are:

r It may be costly to perform without using complex data structures [Freeman, 1995]. r Its effectiveness is relatively limited and problem dependent. It is most effective with randomly generated problems, particularly those that are over-constrained [Horrocks and Patel-Schneider, 1998a].

9.5.4.3 Dependency directed backtracking

Inherent unsatisﬁability concealed in subproblems can lead to large amounts of unproductive backtracking search, sometimes called thrashing. The problem is exacerbated when blocking is used to guarantee termination, because blocking may require that subproblems only be explored after all other forms of expansion have been performed. For example, expanding a node x (using semantic branching), where

L(x) = {(C1 ⊔D1), . . . , (Cn ⊔Dn), ∃R.(A ⊓B), ∀R.¬A},

could lead to the fruitless exploration of 2n possible R-successors of x before the in- herent unsatisﬁability is discovered (note that if L(x) simply included ∃R.A instead of ∃R.(A ⊓B), then the inherent unsatisﬁability would have been detected imme- diately due to the normalization of ∃R.A as ¬∀R.¬A). The search tree resulting from the tableau expansion is illustrated in Figure 9.8. This problem can be addressed by identifying the causes of clashes, and using this information to prune or restructure the search space – a technique known as dependency directed backtracking. The form most commonly used in practice, called backjumping, is adapted from a technique that has been used in solving constraint satisﬁability problems [Baker, 1995] (a similar technique was also used i th H th [O h d S 1988]) B kj i k

by labeling each concept in a node label and each role in an edge label with a dependency set indicating the branching points on which it depends. A concept C ∈L(x) depends on a branching point if C was added to L(x) at the branching point or if C depends on another concept D (or role R), and D (or R) depends on the branching point. A concept C ∈L(x) depends on a concept D (or role R) when C was added to L(x) by the application of a deterministic expansion rule that used D (or R); a role R = L(⟨x, y⟩) depends on a concept D when ⟨x, y⟩was labeled R by the application of a deterministic expansion rule that used D. For example, if A ∈L(y) was derived from the expansion of ∀R.A ∈L(x), then A ∈L(y) depends on both ∀R.A ∈L(x) and R = L(⟨x, y⟩). Labeling roles with dependency sets can be avoided in algorithms where a combined ∃∀-rule is used, as the dependency sets for concepts in the label of the new node can be derived in a single step. On the other hand, more com- plex algorithms and optimization techniques may lead to more complex depen- dencies. For example, if Cn ∈L(x) was derived from a BCP simpliﬁcation of {(C1 ⊔· · · ⊔Cn), ¬C1, . . . , ¬Cn−1} ⊆L(x), then it depends on the disjunction (C1 ⊔· · · ⊔Cn) and all of ¬C1, . . . , ¬Cn−1. When a clash is discovered, the dependency sets of the clashing concepts can be used to identify the most recent branching point where exploring the other branch might alleviate the cause of the clash. It is then possible to jump back over intervening branching points without exploring any alternative branches. Again, more complex algorithms and optimizations may lead to more com- plex dependencies. For example, if the clash results from a BCP simpliﬁcation of {(C1 ⊔· · · ⊔Cn), ¬C1, . . . , ¬Cn} ⊆L(x), then it depends on the disjunction (C1 ⊔· · · ⊔Cn) and all of ¬C1, . . . , ¬Cn. When testing the satisﬁability of a concept C, the dependency set of C ∈L(x) is initialized to ∅(the empty set) and a branching depth counter b is initialized to 1. The search algorithm then proceeds as follows:

(i) Perform deterministic expansion, setting the dependency set of each concept added to a node label and each role assigned to an edge label to the union of the dependency sets of the concepts and roles on which they depend. (a) If a clash is discovered, then return the union of the dependency sets of the clashing concepts. (b) If a clash-free expansion is discovered, then return {0}. (ii) Branch on a concept D ∈L(y), trying ﬁrst L(y) ∪{D} and then L(y) ∪{¬D}. (a) Add D to L(y) with a dependency set {b}, and increment b. (b) Set D1 to the dependency set returned by a recursive call to the search algorithm, and decrement b. (c) If b /∈D1, then return D1 without exploring the second branch. (d) If b D h dd D L( ) i h d d D \ {b} d (i)

x

Pruning Backjump ⊔ ⊔

x

x

L(x) ∪{C1} L(x) ∪{¬C1, D1}

⊔

⊔

x

L(x) ∪{¬C2, D2}

L(x) ∪{Cn-1}

x

⊔

⊔

x

x L(x) ∪{¬Cn, Dn}

L(x) ∪{Cn}

R

y

L(y) = {(A ⊓B), ¬A, A, B}

clash

Fig. 9.9. Pruning the search using backjumping.

If the search returns {0}, then a successful expansion was discovered and the al- gorithm returns “satisﬁable”, otherwise all possible expansions led to a clash and “unsatisﬁable” is returned. Let us consider the earlier example and suppose that ∃R.(A ⊓B) has a depen- dency set Di, ∀R.¬A has a dependency set D j and b = k (meaning that there have already been k −1 branching points in the search tree). Note that the largest values in Di and D j must be less than k, as neither concept can depend on a branching point that has not yet been reached. At the kth branching point, C1 is added to L(x) with a dependency set {k} and b is incremented. The search continues in the same way until the (k + n −1)th branching point, when Cn is added to L(x) with a dependency set {k + n −1}. Next, ∃R.(A ⊓B) is deterministically expanded, generating an R-successor y with R = ⟨x, y⟩labeled Di and (A ⊓B) ∈L(y) labeled Di. Finally, ∀R.¬A is determin- istically expanded, adding ¬A to L(y) with a label Di ∪D j (because it depends on both ∀R.¬A ∈L(x) and R = ⟨x, y⟩). The expansion now continues with L(y), and (A ⊓B) is deterministically ex- panded, adding A and B to L(y), both labeled Di. This results in a clash as {A, ¬A} ⊆L(y), and the set Di ∪Di ∪D j = Di ∪D j (the union of the depen- dency sets from the two clashing concepts) is returned. The algorithm will then backtrack through each of the preceding n branching points without exploring the second branches, because in each case b /∈Di ∪D j (remember that the largest val- ues in Di and D j are less than k), and will continue to backtrack until it reaches the branching point equal to the maximum value in Di ∪D j (if Di = D j = ∅, then the algorithm will backtrack through all branching points and return “unsatisﬁable”). Figure 9.9 illustrates the pruned search tree, with the number of R-successors l d b i d d b 2n 1

Backjumping can also be used with syntactic branching, but the procedure is slightly more complex as there may be more than two possible choices at a given branchingpoint,andthedependencysetofthedisjunctionbeingexpandedmustalso be taken into account. When expanding a disjunction of size n with a dependency set Dd, the ﬁrst n −1 disjuncts are treated like the ﬁrst branch in the semantic branching algorithm, an immediate backtrack occurring if the recursive search discovers a clash that does not depend on b. If each of these branches returns a dependency set Di such that b ∈Di, then the nth disjunct is added with a dependency set (D1 ∪· · · ∪Dn−1 ∪Dd) \ b. The advantages of backjumping are

r It can lead to a dramatic reduction in the size of the search tree and thus a huge performance improvement. For example, when trying to classify the Galen model using either Fact or Dlp with backjumping disabled, single satisﬁability tests were encountered that could not be solved even after several weeks of CPU time. r The size of the search space can never be increased.

The disadvantage is the overhead of propagating and storing the dependency sets. The storage overhead can be alleviated to some extent by using a pointer-based implementation so that propagating a dependency set only requires the copying of a pointer. A simpler scheme using single maximal dependency values instead of sets would also be possible, but some dependency information would be lost and this could lead to less efﬁcient pruning of the search tree.

9.5.4.4 Heuristic guided search

Heuristic techniques can be used to guide the search in a way that tries to minimize thesizeofthesearchtree.AmethodthatiswidelyusedinDPLLSATalgorithmsisto branch on the disjunct that has the Maximum number of Occurrences in disjunctions of Minimum Size – the well-known MOMS heuristic [Freeman, 1995]. By choosing a disjunct that occurs frequently in small disjunctions, the MOMS heuristic tries to maximize the effect of BCP. For example, if the label of a node x contains the unexpanded disjunctions C ⊔D1, . . . , C ⊔Dn, then branching on C leads to their deterministic expansion in a single step: when C is added to L(x), no further expansion of the disjunctions is required (they are all fully expanded) and when ¬C is added to L(x), BCP will expand all of the disjunctions, causing D1, . . . , Dn to be added to L(x). Branching ﬁrst on any of D1, . . . , Dn, on the other hand, would only cause a single disjunction to be expanded. The MOMS value for a candidate concept C is computed simply by counting the number of times C or its negation occur in minimally sized disjunctions. There are several variants of this heuristic, including the heuristic from [Jeroslow and W 1990] Th J l W h i ti id ll f di j t

weighting them according to the size of the disjunction in which they occur. The heuristic then selects the disjunct with the highest overall weighting, again with the objective of maximizing the effect of BCP and reducing the size of the search tree. When a disjunct C has been selected from the disjunctions in L(x), a BCP max- imizing heuristic can also be used to determine the order in which the two possible branches, L(x) ∪{C} and L(x) ∪{¬C}, are explored. This is done by separat- ing the two components of the heuristic weighting contributed by occurrences of C and ¬C, trying L(x) ∪{C} ﬁrst if C made the smallest contribution, and trying L(x) ∪{¬C} ﬁrst otherwise. The intention is to prune the search tree by maximizing BCP in the ﬁrst branch. Unfortunately, MOMS-style heuristics can interact adversely with the backjump- ing optimization because they do not take dependency information into account. This was ﬁrst discovered in the Fact system, when it was noticed that using MOMS heuristic often led to much worse performance. The cause of this phenomenon turned out to be the fact that, without the heuristic, the data structures used in the implementation naturally led to “older” disjunctions (those dependent on ear- lier branching points) being expanded before “newer” ones, and this led to more effective pruning if a clash was discovered. Using the heuristic disturbed this or- dering and reduced the effectiveness of backjumping [Horrocks, 1997b]. Moreover, MOMS-style heuristics are of little value themselves in DL systems because they rely for their effectiveness on ﬁnding the same disjuncts recurring in multiple unexpanded disjunctions: this is likely in hard propositional problems, where the disjuncts are propositional variables, and where the number of different variables is usually small compared to the number of disjunctive clauses (otherwise problems would, in general, be trivially satisﬁable); it is unlikely in concept satisﬁa- bility problems, where the disjuncts are (possibly non-atomic) concepts, and where the number of different concepts is usually large compared to the number of disjunc- tive clauses. As a result, these heuristics will often discover that all disjuncts have similar or equal priorities, and the guidance they provide is not particularly useful. An alternative strategy is to employ an oldest-ﬁrst heuristic that tries to max- imize the effectiveness of backjumping by using dependency sets to guide the expansion [Horrocks and Patel-Schneider, 1999]. When choosing a disjunct on which to branch, the heuristic ﬁrst selects those disjunctions that depend on the least recent branching points (i.e., those with minimal maximum values in their depen- dency sets), and then selects a disjunct from one of these disjunctions. This can be combined with the use of a BCP maximizing heuristic, such as the Jeroslow–Wang heuristic, to select the disjunct from amongst the selected disjunctions. Although the BCP and backjumping maximizing heuristics described above have been designed with semantic branching in mind they can also be used with syn- t ti b hi Th ld t ﬁt h i ti t ll l t di j ti th th

disjuncts, and is thus a natural candidate for a syntactic branching heuristic. BCP maximizing heuristics could also be adapted for use with syntactic branching, for example by ﬁrst evaluating the weighting of each disjunct and then selecting the dis- junction whose disjuncts have the highest average, median or maximum weightings. The oldest-ﬁrst heuristic can also be used to advantage when selecting the order in which existential role restrictions, and the labels of the R-successors which they generate, are expanded. One possible technique is to use the heuristic to select an unexpanded existential role restriction ∃R.C from the label of a node x, apply the ∃-rule and the ∀-rule as necessary, and expand the label of resulting R-successor. If the expansion results in a clash, then the algorithm will backtrack; if it does not, then continue selecting and expanding existential role restrictions from L(x) until it is fully expanded. A better technique is to ﬁrst apply the ∃-rule and the ∀-rule exhaustively, creating a set of successor nodes. The order in which to expand these successors can then be based on the minimal maximum values in the dependency sets of all the concepts in their label, some of which may be due to universal role restrictions in L(x). The advantages of using heuristics are

r They can be used to complement other optimizations. The MOMS and Jeroslow–Wang heuristics, for example, are designed to increase the effectiveness of BCP while the oldest-ﬁrst heuristic is designed to increase the effectiveness of backjumping. r They can be selected and tuned to take advantage of the kinds of problem that are to be solved (if this is known). The BCP maximization heuristics, for example, are generally quite effective with large randomly generated and hand crafted problems, whereas the oldest-ﬁrst heuristic seems to be more effective when classifying realistic KBs.

The disadvantages are

r They can add a signiﬁcant overhead as the heuristic function may be expensive to evaluate and may need to be re-evaluated at each branching point. r They may not improve performance, and may signiﬁcantly degrade it. – Heuristics can interact adversely with other optimizations, as was the case with the MOMS heuristic and backjumping in the Fact system. – When they work badly, heuristics can increase the frequency with which pathological worst cases can be expected to occur. For example, with problems that are highly disjunctive but relatively under-constrained, using a BCP maximizing heuristic to select highly constraining disjuncts can force backtracking search to be performed when most random branching choices would lead rapidly to a clash-free expansion. – The cost of computing the heuristic function can outweigh the beneﬁt (if any). r Heuristics designed to work well with purely proposition reasoning, such as the BCP maximizing heuristics, may not be particularly effective with Description Logics, where much of the reasoning is modal (it involves roles and subproblems). There has been little k ﬁdi d h i i f d l i bl

9.5.4.5 Caching satisﬁability status

During a satisﬁability check there may be many successor nodes created. Some of these nodes can be very similar, particularly as the labels of the R-successors for a node x each contain the same concepts derived from the universal role restrictions in L(x). Considerable time can thus be spent re-computing the satisﬁability of nodes that have the same label. As the satisﬁability algorithm only needs to know whether a node is satisﬁable or not, this time is wasted. Moreover, when classifying a KB, similar satisﬁability tests may be performed many times, and may provide further opportunities for the re-use of satisﬁability results for node labels if these are retained across multiple concept satisﬁability tests. If the expansion of existential value restrictions in the label of a node x is delayed untilallotherexpansionpossibilitieshavebeenexhausted(asinthetracetechnique), then as each existential role restriction ∃R.C is expanded it is possible to generate the complete set of concepts that constitute the initial label of the R-successor; this will consist of C plus all the concepts derived from universal role restrictions in L(x).7 If there exists another node with the same set of initial concepts, then the two nodes will have the same satisﬁability status. Work need be done only on one of the two nodes, potentially saving a considerable amount of processing, as not only is the work at one of the nodes saved, but also the work at any of the successors of this node. Care must be taken when using caching in conjunction with blocking as the satisﬁability status of blocked nodes is not completely determined but is simply taken to be equal to that of the blocking node. Another problem with caching is that the dependency information required for backjumping cannot be effectively calculated for nodes that are found to be unsatisﬁable as a result of a cache lookup. Although the set of concepts in the initial label of such a node is the same as that of the expanded node whose (un)satisﬁability status has been cached, the dependency sets attached to the concepts that made up the two labels may not be the same. However, a weaker form of backjumping can still be performed by taking the dependency set of the unsatisﬁable node to be the union of the dependency sets from the concepts in its label. A general procedure for using caching when expanding a node x can be described as follows.

(i) Exhaustively perform all local expansions, backtracking as required, until only existential value restrictions (if any) remain to be expanded. (ii) If there are no unexpanded existential value restrictions in L(x), then return the satisﬁability status satisﬁable to the predecessor node.

7 This ordering is used in the trace technique to minimize space usage, and may be useful or even required for

(iii) Select (heuristically) an unexpanded existential role restriction from L(x), expanding it and any applicable universal role restrictions to create a new node y with an initial label L(y) (or create all such nodes and heuristically select the order in which they are to be examined). (iv) If y is blocked, then its satisﬁability status S is directly determined by the algorithm (normally satisﬁable, but may depend on the kind of cycle that has been detected [Baader, 1991]). (a) If S = satisﬁable, then return to step (ii) without expanding L(y). (b) If S = unsatisﬁable, then backtrack without expanding L(y). The dependency set will need to be determined by the blocking algorithm. (v) If a set equal to L(y) is found in the cache, then retrieve the associated satisﬁability status S (this is called a cache “hit”). (a) If S = satisﬁable, then return to step (ii) without expanding L(y). (b) If S = unsatisﬁable, then backtrack without expanding L(y), taking the depen- dency set to be the union of the dependency sets attached to the concepts in L(y). (vi) If a set equal to L(y) is not found in the cache, then set L = L(y) and expand L(y) in order to determine its satisﬁability status S. (a) If S = satisﬁable and there is no descendant z of y that is blocked by an ancestor x′ of y, then add L to the cache with satisﬁability status S and return to step (ii). (b) If S = satisﬁable and there is a descendant z of y that is blocked by an ancestor x′

of y, then return to step (ii) without updating the cache. (c) If S = unsatisﬁable, then add L to the cache with satisﬁability status S and back- track, taking the dependency set to be the one returned by the expansion of L(y).

The problem of combining caching and blocking can be dealt with in a more sophisticated way by allowing the cached satisﬁability status of a node to assume values such as “unknown”. These values can be updated as the expansion progresses and the satisﬁability status of blocking nodes is determined. Such a strategy is implemented in the Dlp system. A further reﬁnement is to use subset and superset instead of equality when retreiving satisﬁability status from the cache: if L(x) is satisﬁable, then clearly any L(y) ⊆L(x) is also satisﬁable, and if L(x) is unsatisﬁable, then clearly any L(y) ⊇L(x) is also unsatisﬁable [Hoffmann and Koehler, 1999; Giunchiglia and Tacchella, 2000]. However, using subsets and supersets signiﬁcantly increases the complexity of the cache, and it is not yet clear if the performance cost of this added complexity will be justiﬁed by the possible increase in cache hits. The advantages of caching the satisﬁability status are:

r Itcanbehighlyeffectivewithsomeproblems,particularlythosewitharepetitivestructure. For example, the Dlp system has been used to demonstrate that some of the problem sets from the Tableaux’98 benchmark suite are trivial when caching is used (all problems were solvedinlessthan0.1sandtherewaslittleevidenceofincreasingdifﬁcultywithincreasing bl i ) Wi h hi h bl d d l l i l

growth in solution time with increasing problem size, and the system was unable to solve the larger problems within the 100 s time limit imposed in the test [Horrocks and Patel-Schneider, 1999]. r It can be effective with both single satisﬁability tests and across multiple tests (as in KB classiﬁcation). r It can be effective with both satisﬁable and unsatisﬁable problems, unlike many other optimization techniques that are primarily aimed at speeding up the detection of unsatis- ﬁability.

The disadvantages are:

r Retaining node labels and their satisﬁability status throughout a satisﬁability test (or longer, if the results are to be used in later satisﬁability tests) involves a storage overhead. As the maximum number of different possible node labels is exponential in the number of different concepts, this overhead could be prohibitive, and it may be necessary to implement a mechanism for clearing some or all of the cache. However, experiments with caching in the Dlp system suggest that this is unlikely to be a problem in realistic applications [Horrocks and Patel-Schneider, 1999]. r The adverse interaction with dependency directed backtracking can degrade performance in some circumstances. r Its effectiveness is problem dependent, and (as might be expected) is most evident with artiﬁcial problems having a repetitive structure. It is highly effective with some of the hand crafted problems from the Tableaux’98 benchmark suite, it is less effective with realistic classiﬁcation problems, and it is almost completely ineffective with randomly generated problems [Horrocks and Patel-Schneider, 1999]. r The technique described depends on the logic having the property that the satisﬁability of a node is completely determined by its initial label set. Extending the technique to logics that do not have this property, for example those which support inverse roles, may involve a considerable increase in both complexity and storage requirements.

9.6 Discussion

To be useful in realistic applications, DL systems need both expressive logics and fast reasoners. Procedures for deciding subsumption (or equivalently satisﬁability) in such logics have discouragingly high worst-case complexities, normally exponential with respect to problem size. In spite of this, implemented DL systems have demonstrated that acceptable performance can be achieved with the kinds of problem that typically occur in realistic applications. This performance has been achieved through the use of optimization techniques, a wide variety of which have been studied in this chapter. These techniques can operateateverylevelofaDLsystem;theycansimplifytheKB,reducethenumberof b ti t t i d t l if it l t bl b ti t t ith l

costly tests, and reduce the size of the search space resulting from non-deterministic tableau expansion. Amongst the most effective of these optimizations are absorption and backjumping; both have the desirable properties that they impose a very small additional overhead, can dramatically improve typical case performance, and hardly ever degrade performance (to any signiﬁcant extent). Other widely applicable op- timizations include enhanced traversal, normalization, lazy unfolding, semantic branching and local simpliﬁcation; their effects are less general and less dramatic, but they too impose low overheads and rarely degrade performance. Various forms of caching can also be highly effective, but they do impose a signiﬁcant additional overhead in terms of memory usage, and can sometimes degrade performance. Finally, heuristic techniques, at least those currently available, are not particularly effective and can often degrade performance. Several exciting new application areas are opening up for very expressive Description Logics, in particular reasoning about database schemata and queries, and providing reasoning support for the Semantic Web. These applications require logics even more expressive than those implemented in existing systems, in par- ticular logics that include both inverse roles and number restrictions, as well as reasoning with general axioms. The challenge for DL implementors is to demon- strate that highly optimized reasoners can provide acceptable performance even for these logics. This may require the extension and reﬁnement of existing techniques, or even the development of completely new ones. One promising possibility is to use a more sophisticated form of dependency directed backtracking, called dynamic backtracking [Ginsberg, 1993], that pre- serves as much work as possible while backtracking to the source of a contradiction. Another useful approach, indicative of the increasing maturity of existing imple- mentations,istofocusonproblematicalconstructorsanddevisemethodsfordealing with them more efﬁciently. Good examples of this can be seen in the Racer system, where signiﬁcant improvements in performance have been achieved by using more sophisticated techniques to deal with domain and range constraints on roles (see Chapter 2 for an explanation of these constructs) and qualiﬁed number restrictions [Haarslev and M¨oller, 2001c; 2001d; 2001a]. Finally, it should be re-emphasized that, given the immutability of theoretical complexity, no (complete) implementation can guarantee to provide good perfor- mance in all cases. The objective of optimized implementations is to provide ac- ceptable performance in typical applications and, as the deﬁnition of “acceptable” and “typical” will always be application dependent, their effectiveness can only be assessed by empirical testing. Hopefully, the new generation of highly optimized DL systems will demonstrate their effectiveness by ﬁnding more widespread use in applications than did their predecessors.

Part III

Applications

10

Conceptual Modeling with Description Logics

ALEX BORGIDA RONALD J. BRACHMAN

Abstract

The purpose of the chapter is to help someone familiar with DLs to understand the issues involved in developing an ontology for some universe of discourse, which is to become a conceptual model or knowledge base represented and reasoned about using Description Logics. We brieﬂy review the purposes and history of conceptual modeling, and then use the domain of a university library to illustrate an approach to conceptual modeling that combines general ideas of object-centered modeling with a look at special modeling/ontological problems, and DL-speciﬁc solutions to them. Among the ontological issues considered are the nature of individuals, con- cept specialization, non-binary relationships, materialization, aspects of part-whole relationships, and epistemic aspects of individual knowledge.

10.1 Background

Informationmodelingisconcernedwiththeconstructionofcomputer-basedsymbol structures that model some part of the real world. We refer to such symbol structures as information bases, generalizing the term from related terms in Computer Science, such as databases and knowledge bases. Moreover, we shall refer to the part of a real world being modeled by an information base as its universe of discourse (UofD). The information base is checked for consistency, and sometimes queried and updated through special-purpose languages. As with all models, the advantage of information models is that they abstract away irrelevant details, and allow more efﬁcient examination of both the current, as well as past and projected future states of the UofD. An information model is built up using some language, and this language inﬂuences (more or less subtly) the kinds of details that are considered. For example early information models (e g relational data models) were built on

conventional programming notions such as records, and as a result focused on the implementation aspects of the information being captured, as opposed to the repre- sentationalaspects.Conceptualmodelsoffermoreexpressivefacilitiesformodeling applications directly and naturally [Hammer and McLeod, 1981], and for structur- ing information bases. These languages provide semantic terms for modeling an application, such as entity and relationship (or even activity, agent and goal), as well as means for organizing information. Conceptual models play an important part in a variety of areas. The following is a brief summary of these areas, as reviewed in [Mylopoulos, 1998]:

r Artiﬁcial intelligence programs turned out to require the representation of a great deal of human knowledge in order to act “intelligently”. As a result, they relied on conceptual models built up using knowledge representation languages, such as semantic networks – directed graphs labeled with natural language identiﬁers. DLs are the historical descen- dants of attempts to formalize semantic networks. r The design of database systems was seen to have as an important initial phase the con- struction of a “conceptual level schema”, which determined the information needs of the users, and which was eventually converted to a physical implementation schema. Chen’s Entity–Relationship model [Chen, 1976], and later semantic data models [Hull and King, 1987], were the result of efforts in this direction. r More generally, the development of all software has an initial requirements acquisition stage, which nowadays is seen to consist of a requirements model that describes the relationship of the proposed system and its environment. The environment in this case is likely to be a conceptual model. r Independently, the object-oriented software community has also proposed viewing soft- ware components (classes/objects) as models of real-world entities. This was evident in the features of Simula, the ﬁrst object-oriented programming language, and became a cornerstone of most object-oriented techniques, including the current leader, UML [Rumbaugh et al., 1998].

One interesting aspect of conceptual modeling in the database context has been the identiﬁcation of a number of abstraction mechanisms that support the development of large models by abstracting details initially, and then introducing them in a stepwise and systematic manner. Among the important abstractions are the following:

r thinking of objects as wholes, not just a collection of their attributes/components (“aggregation”); r abstracting away the detailed differences between individuals, so that a class can represent the commonalities (“classiﬁcation”1); r abstracting the commonalities of several classes into a superclass (“generalization”).

1 This term is used in a completely different way than in DL terminology, where it refers to the DL-KBMS i f ﬁdi th l t b f t i di id l

An important claim regarding the beneﬁts of abstraction in conceptual modeling is that it results in a structured information model, which is easier to build and main- tain. Interestingly, Description Logics further this goal by supporting the automatic classiﬁcation of concepts with respect to others, thereby revealing generalizations that may not have been recognized by the modeler.

10.2 Elementary Description Logic modeling

Most conceptual models, including Description Logics, subscribe to an object- centered view of the world. Thus, their ontology includes notions like individual objects, which are associated with each other through (usually binary) relationships, and which are grouped into classes. In this chapter we use freely the notation and concrete syntax of Description Logics (see Appendix), and extend it with additional constructs that make it more suitable for modeling. In the domain of a university library, we might encounter a particular person, GIANNI, or a particular book, BOOK23. Most of the information about the state of the world is captured by the interrelationships between individuals, such as GIANNI having borrowed BOOK23. Binary relationships are modeled directly in Description Logics using roles and attributes: either GIANNI is a ﬁller of the lentTo role for BOOK23, or BOOK23 is the ﬁller of the hasBorrowed role for GIANNI. Note that lentTo and hasBorrowed are converse relationships, and this should be captured in a model, since frequently one wants to access information about associations in either direction. In Description Logics, this is accomplished using the role constructor inverse:

hasBorrowed ≡ (inverse lentTo).

Note that in order to avoid inadvertent errors during modeling due to confusion between a role and its converse, or between a role and the kind of values ﬁlling it, one heuristic is to use a natural language name that is asymmetric, and adopt the convention that the relationship R(a, b) should be read as “a R b”; therefore in the above case lentTo(BOOK23,GIANNI) reads “BOOK23 lentTo GIANNI,” while lentTo(GIANNI,BOOK23) reads “GIANNI lentTo BOOK23”, which makes it clear that the ﬁrst, but not the second, is the proper way to use the role lentTo in the model. On the other hand, loan would be a poor choice of a role identi- ﬁer because one could equally well imagine loan as a role of books or of per- sons, so that neither loan(GIANNI,BOOK23) nor loan(BOOK23,GIANNI) “reads” properly. In addition, it is always important to distinguish functional relationships, like lentTo (a book can be loaned to at most one borrower at any time) from non functional ones like hasBorrowed This is done most cleanly if the

particular Description Logic being used allows the declaration of functional re- lationships, sometimes called “attributes” or “features”. Attributes themselves come in two ﬂavors: total and partial. Thus lentTo is a partial attribute because a book can only be loaned to one person, but may not be on loan at some point of time; on the other hand, every book has to have an isbnNr. It is im- portant to check which interpretation of attributes is offered by the particular Description Logic being used. In the rest of this chapter we assume that attributes are total, and the concept constructor the will be used as an abbreviation, so that (the p C) is equivalent to the conjunction of (all p C), (at-most 1 p) and (at-least 1 p). Individuals are grouped into classes; for example, Book might be a natural class in our domain. Classes usually abstract out common properties of their instances, e.g., every book in the library has a call number. Classes are modeled by concepts in Description Logics, and usually the common properties are expressed as subsump- tion axioms about the concept. These conditions usually involve superconcepts, as well as the kinds of values that can ﬁll roles, and limits on the number of (various kinds of) role ﬁllers. By design, these are exactly the kinds of things that can be expressed using DL constructors:

/* Books are materials, whose callNr is an integer */ Book ⊑ (and Material (the callNr Integer) . . . ).

As mentioned in earlier chapters, one of the fundamental properties of Descrip- tion Logics is support for the distinction between primitive/atomic concepts – for which instances can only be declared explicitly – and deﬁned concepts – which offer necessary and sufﬁcient conditions for membership. So, for example, we can dis- tinguish the notion of “borrower” as someone who can borrow a book (an approved customer of the library)

/* Borrower is previously declared as a primitive concept.

Here it is indicated what restrictions on borrowing are in force for this concept */ Borrower ⊑ (all hasBorrowed Book)

from the notion of “borrower” as someone who has actually borrowed a book from the library

/* Borrower is deﬁned as someone who has borrowed books */ Borrower ≡ (and (all hasBorrowed Book) (at least 1 hasBorrowed))

We now turn to a variety of more subtle issues that arise when modeling a domain. Almost all of these issues arise independently of the modeling language used; what we emphasize here is the range of possible solutions in the DL framework.

10.3 Individuals in the world

Some individuals are quite concrete, like a particular person, Gianni, or a particular copy of a book. Some are more abstract, like the subject matter covered by a book. The important property of most individuals is that they have an identity, which allows them to be distinguished from one another and to be counted. Modeling of individuals is therefore made easier if they have unique identiﬁers. Unfortunately, this may not always be the case. For example, if one sees on a bookshelf two brand new copies of a book, which may not be distinguishable by any property known to us, one can still say that they are different copies of the book. In information management systems, and sometimes in the real world, this leads us to devise some kind of “extrinsic” identiﬁcation scheme. For example, books on the library shelf are assigned a copy number. In this paper, as in object-oriented software systems, we will tend to assign arbitrary internal identiﬁers to objects, such as GIANNI or BOOK23. The following examples concerning books show that what constitutes a relevant individual in a UofD depends very much on what we want to do with the infor- mation. In a domain concerning literature courses, one might consider something like Dickens’ HARD-TIMES as the kind of individual appearing on an assigned reading list. For an Internet book-seller interface, it is necessary to consider a more concrete level of modeling – that of book editions, since these may have different prices. Finally, in a library, we need to keep track of actual physical book copies. In the last two cases, one must then decide whether to model books (as opposed to editions or copies) as individuals, or as concepts that have the other kinds of individuals as instances. A general heuristic is that if we expect certain notions to be counted, then they must be modeled as individuals. Another heuristic is that notions that do not have an inception time are usually modeled as concepts. Modeling of the particular kind of relationship that exists, for example, between a book and its editions is further examined in Subsection 10.7.2.

10.3.1 Values vs. objects

It is important to distinguish what we may call individual objects, such as GIANNI, fromvalues,suchasintegers,strings,lists,tuples,etc.Theformerhaveanassociated intrinsic and immutable identity, and need to be created in the knowledge base. The later are “eternal” mathematical abstractions whose identity is determined by

some procedure usually involving the structure of the individual. For example, the two strings “abc” and “abc” are the same individual value because they have the same sequence of characters; similarly for dates, such as 1925/12/20, which can be considered as 3-tuples. Many Description Logics only support reasoning with objects, in which case composite values such as dates need to be modeled as objects with attributes for day, month and year. The danger here is that, for example, multiple date individu- als can be created with the same attribute values, in which case they are treated as distinct for the purposes of counting and identity checking, resulting in reasoning anomalies. Implemented Description Logics such as Classic support values from the underlying programming language (so-called “host values”), and relatively sim- ple concept hierarchies over them. Others, such as ALC(D) [Baader and Hanschke, 1991a] and SHOQ(D) [Horrocks and Sattler, 2001] allow attributes to have values from so-called “concrete domains”, which can contain entirely new kinds of val- ues. These concrete domains are required to have their own, independent reasoners, which are then coupled with the DL reasoner. Equally desirable would be mathematical types such as sets, bags, sequences, and tuples, as supported by modern programming languages and certain semantic data models. Currently, only the highly expressive DLR languages support notions such as n-tuples and recursive ﬁxed-point structures, from which one can build lists, trees, etc. Even here, one can only provide the description of concepts (“list of Persons”), as opposed to the speciﬁcation of individuals (“the list [GIANNI,ANNA]”).

10.3.2 Individuals vs. references to them

It is important to distinguish an individual from various references to it: Gianni vs. “the person whose ﬁrst name is the 6-letter string “Gianni” vs. “the borrower with library card number 32245” vs. “the chairman of the Psychology Department”. This distinction becomes crucial when we express relationships: there is a difference between relating two objects and relating their names, because we usually want objects to remain related, even if names are changed. Thus “GIANNI hasBorrowed BOOK25” is different from “card-holder number 32245 hasBorrowed BOOK25”, because if Gianni gets a new card (after losing his old one, say), then the relationship between Gianni and the book is lost. So, in general, one should always deal with the individual objects, unless there is a bijection between a class of objects and a class of referents to them, and this bijection is universal (it always exists) and is unchanging.2 Kent [1979] has eloquently argued the importance of these issues in

2 S h bij ti tl th “k ” d i th d t b t t

record-based database systems, and shows that in the real world such bijections are much rarer than assumed. For example, Neumann [1992] reports that the same US social security number (the prototypical identiﬁer for persons in the USA) has been issued to two people, who even have the same name and birth-date! Conversely, in some cases one wants to state relationships between intensional references, rather than speciﬁc objects. For example, we might want to say that, in general, the director of the library is the head of the book selection committee (COMMITTEE3). If Gianni happens to be the current director of the NBU library, then asserting headOf(GIANNI,COMMITTEE3) is improper because, for example, if Gianni steps down as director, according to the above model he would still be com- mittee chair. One needs the ability to use unnamed expressions as arguments of rela- tionships,alongthelinesofthepredicatelogicexpressionheadOf(directorOf(NBU- LIBRARY),COMMITTEE3). In Description Logics, intensional referents can be expressed as roles that are applied to individuals. (The roles may often be complex chains, resulting from the composition of atomic roles, as in “the zipCode of the address of the lentTo”.) Assuming that we use the notation NBU-LIBRARY.director to refer to the ﬁller of the director role for the NBU-LIBRARY individual, the above relationship is actually stated as “NBU-LIBRARY.director is identical to COMMITTEE3.head”. The concept constructor same-as, indicating that two chains of roles have the same value, is used to express exactly such relationships, so the above situation might be modeled, naively, using the concept (same-as director head). The problem is that we need a single individual of which to assert this property, yet it is libraries that have directors while committees have heads. In such situations, in Description Logics one must ﬁnd or create some chain of attributes relating the two individuals NBU-LIBRARY and COMMITTEE3. The natural relationship in this case is the attribute hasBookSelectionCommittee. Therefore the appropriate way of modeling this situation is

/* NBU-LIBRARY has book selection committee COMMITTEE3 */ hasBookSelectionCommittee(NBU-LIBRARY, COMMITTEE3)

/* NBU-LIBRARY.director equals

NBU-LIBRARY.hasBookSelectionCommittee.head */ (same-as director (hasBookSelectionCommittee ◦head))(NBU-LIBRARY).

10.4 Concepts

For the university library, some obvious classes of individuals include people, insti- tutions the material that can be loaned by the library the staff dates library cards

and ﬁnes. These classes are normally modeled using atomic/primitive concepts in Description Logics. It may be worth noting that in Description Logics the same individual may be an instance of multiple classes, without one being necessarily a subclass of another: some book might be an instance of both hardcover and science books. This is in contrast with many other object-oriented software systems, where one is forced to create a special subclass for this notion, in order to guarantee a unique “minimal” class for every individual. However, this is not a modeling principle – it is an implementation obstacle.

10.4.1 Essential vs. incidental properties of concepts

As explained in the earlier example involving the two possible meanings for the term “borrower”, an important feature of Description Logics is the ability to distinguish primitive from deﬁned concepts, where the latter have necessary and sufﬁcient conditions for concept membership. For example, BookOnLoan might naturally be deﬁned as

/* A book is on loan if it is borrowed by someone */ BookOnLoan ≡ (and Book (at-least 1 lentTo)).

Suppose that we also want to require that only hardcover books can be loaned out. There seem to be two options for modeling this:

/* Option 1 — being hardcover is part of the deﬁnition */ BookOnLoan ≡ (and Book (at-least 1 lentTo) (ﬁlls binding ’hardcover))

/* Option 2 — being hardcover is an additional necessary condition */ BookOnLoan ≡ (and Book (at-least 1 lentTo)) BookOnLoan ⊑ (ﬁlls binding ’hardcover).

The ﬁrst approach is not quite right because being hardcover is an incidental property of books on loan, albeit one universally shared by all such objects. Among other things, this means that if the system is to recognize some individual book as being on loan, it is enough to know that it has been lent to someone – one does not also need to know it is hardcover. Hence the second modeling option is the right one, since one can actually deduce that a book on loan is hardcover, if this was not known ahead of time

The distinction between deﬁnitional and incidental properties is also important if weconsiderthetaskofclassifyingconceptsintoataxonomy,sinceithasbeenargued that the taxonomy should not depend on contingent facts. This suggests that inciden- tal properties, even universal inclusion assertions like the one for hardcover books in Option 2 above, should appear in the ABox, not the TBox deﬁning the terminology. Another subtle problem arises when there are multiple sufﬁcient conditions for a concept. For example, suppose we associated a due date with books on loan (in the physical world, this might be recorded as a date stamped in the back of the book). Then encountering a book with a due date in the future would rightly classify it as a book on loan. If we model the due date as an attribute of books, which has a value only as long as the date is in the future, then we would represent this situation as

(and Book (at-least 1 dueDate)) ⊑ BookOnLoan

and, of course, requiring books on loan to have a due date would lead to

BookOnLoan ⊑ (at-least 1 dueDate).

We thus have multiple sufﬁcient conditions for being a book on loan, although one of them appears to be the primary deﬁnition.

10.4.2 Reiﬁed concepts and meta-roles

In some cases it seems natural to associate information with an entire concept, rather than with each of its individual instances. One situation where this arises is in capturing aggregate information, such as the count of current individual instances of the concept, or the average value of their attributes. In the library example, attributes such as numberOfBooks and mostRequestedBooks would fall into this category. In some object-oriented systems this can be modeled directly because classes are themselves objects, and as such are instances of meta-classes and have meta- properties. Currently, Description Logics do not have a facility to treat classes as objects. One must therefore create a separate “meta-individual” that is related to the concept by some naming convention, for example. In our example, we would create the individual BOOK-CLASS-OBJECT, and then attach the information regarding numberOfBooks, mostRequestedBooks, etc., as roles of this individual. In the Classic system, given a named concept, this meta-individual can be retrieved using a special, new knowledge base operation.

10.4.3 Concepts dependent on relationships

The following interesting modeling problem arises in many situations: some concepts such as Book stand on their own Others such as Borrower rely on the

implied existence of some relation/event (e.g., lending), which has a second argu- ment, and from which their meaning is derived. It is important to discern this second category of concepts, and explicitly introduce the corresponding binary relationship in the model. In the data modeling literature (e.g., [Albano et al., 1993]) categories of this second type, such as Borrower, are called “roles”, but to avoid confusion with DL roles, we will call them “relationship-roles”. The modeling of these will be considered further in Subsection 10.7.1.

10.5 Subconcepts

For many of the above concepts, there are specialized subconcepts representing subsets of individuals that are also of interest. For example, the concept Material (referring to the holdings of libraries) could have specializations Book, Journal, Videotape, etc. In turn, Book may have subconcepts Monograph, EditedCollection, Proceedings, etc.3 And Borrowers may be Institutions or Individuals, with the latter being divided into Faculty, Student, Staff. There are a number of special aspects of the subclass relationship that should be modeled in order to properly capture the semantics of the UofD.

10.5.1 Disjointness of subconcepts

In many cases, subclasses are disjoint from each other. For example, Book and Journal are disjoint subclasses of Material. In Description Logics that support negation, this is modeled by adding the complement of one concept to the necessary properties of the other concept:

Book ⊑ not Journal

Often, entire collections of subclasses are disjoint.4 For this purpose, some Description Logics provide the ability to describe disjointness by naming a dis- criminator, and a special declaration operation for primitive subclasses. For exam- ple, one might discriminate between various kinds of material on the basis of the medium as follows:

Print ⊑ (disjointPrim Material in group medium with discriminant paper) Video ⊑ (disjointPrim Material in group medium with discriminant light) Audio ⊑ (disjointPrim Material in group medium with discriminant sound)

3 For this section, we will think of the material to be loaned as physical individuals that can be carried out the door of the library, so to speak. 4 Thi i i ll th t th t f th b l hi h P M t i l t

At the same time, one might discriminate between different kinds of material on the basis of the format:

Book ⊑ (disjointPrim Material in group format with discriminant book) Journal ⊑ (disjointPrim Material in group format with discriminant journal) . . .

Two points are worth making here: (i) the advantage of a syntax based on dis- criminators is that it avoids the multiplicative effect of having to state disjointness for every pair of disjoint concepts; (ii) as in the above example, it is important to allow during modeling for multiple groups of disjoint subconcepts for the same concept.

10.5.2 Covering by subconcepts

In addition to disjointness, it is natural to consider whether some set of subclasses fully covers the superclass. For example, we might want to say that Circulating material must be either short-term or long-term. For Description Logics that support concept disjunction, this is easy:

Circulating ⊑ (or ShortTerm LongTerm).

Note that since ShortTerm, in turn, has Circulating as a superclass, the possibility arises of modeling Circulating as a deﬁnition:

Circulating ≡ (or ShortTerm LongTerm).

However, this approach is not available for languages like Classic, which avoid disjunction in order to gain tractable reasoning. We discuss in the next section an approach to the problem based on subconcept deﬁnitions and enumerated values.

10.5.3 Deﬁned vs. primitive subconcepts

In the case of material that is either circulating or non-circulating, the name of the second class provides a hint: after introducing Material and Circulating as primitives, NonCirculating should be deﬁned:

Circulating ⊑ Material NonCirculating ≡ (and Material (not Circulating))

In this case, the Description Logic can deduce both the disjointness of Circu- lating and NonCirculating, and the fact that Material is the union of Circulat- ing and NonCirculating, without having stated anything explicitly about either. This shows clearly the power of a reasoning system that is capable of supporting deﬁnitions. By joining covering and disjointness one gets the partitioning of a class by some group of subclasses. In some Description Logics – those supporting the constructor one-of – it is possible to simulate the effect of declaring concepts as partitioned into subconcepts through the use of a special attribute. For example, we could add the attribute format to Books, with an enumerated set of possible values:

Book ⊑ (the format (one-of ’monograph ’journal ’editedCollection))

and then deﬁne the corresponding subclasses:

Monograph ≡ (and Book (ﬁlls format ’monograph)) Journal ≡ (and Book (ﬁlls format ’journal)) EditedCollection ≡ (and Book (ﬁlls format ’editedCollection)).

These concepts will be disjoint because format can have at most one value, and they cover the original class Book, because format must have (at least) one value from among the set enumerated.

10.5.4 Dynamics of (sub)concept membership

When changes in the model are allowed, there is a distinction between concepts that represent inherent properties of objects that do not change over time (called “rigid” in [Guarino and Welty, 2000]) such as Book, and concepts that represent more transient properties, such as MisplacedBook. Note that while it is possible for a transient property to be a subconcept of rigid one, the converse does not make sense. StandardDescriptionLogicshavenotdevelopedmodelingtoolsforissuesinvolv- ing the dynamics of the world, and hence usually cannot represent such distinctions. Description Logics extended with the notion of time, such as [Artale and Franconi, 1998], are of course well suited to express them.

10.5.5 The structure of the subconcept hierarchy

Recent work by Guarino and Welty (e.g., [Guarino and Welty, 2000]) has presented several interesting ontological dimensions along which a concept can be positioned

The dimensions are related to many of the topics we discuss elsewhere in this chapter, including the existence or absence of criteria for identifying individuals (Section 10.3), the rigid vs. non-rigid nature of concept membership (Subsection 10.5.4), the nature of the part-whole relationship (Subsection 10.7.3), and aspects resembling relationship roles (Subsection 10.7.1). The signiﬁcance of these dimensions is that they can be used to both clarify the intended meaning of concepts in an ontology, and to better organize the tax- onomy of primitive concepts. The conditions for proper taxonomies are based on observations such as “a concept some of whose current instances may cease to be instances at some point in the future (e.g., Student) cannot subsume a concept whose membership cannot change (e.g., Person).” We refer the reader to the original paper for further details.

10.6 Modeling relationships

As mentioned earlier, binary relationships are modeled in Description Logics using roles and attributes. Just as with subclasses, there are a number of special constraints that are frequently expressed about relationships: cardinality constraints state the minimum and maximum number of objects that can be related via a role; domain constraints state the kinds of objects that can be related via a role; and inverse relationships between roles need to be recorded. For example, a book has exactly one title, which is a string, and exactly one call number, which is some value that depends on the cataloging technique used. On the other hand, there may be zero or more authors for a book:

Book ⊑ (and (the title String) (the callNr MaterialIdentifier) (all author Person)).

As mentioned in Section 10.2, we can use the attribute lentTo to model when someone borrows a book:

Book ⊑ (all lentTo Borrower).

Suppose we also want to record that the material in the library may be on loan, available or missing. This can be modeled by adding appropriate roles to the library:

Library ⊑ (and (all hasOnLoan Material) (all hasAvailable Material) (all hasMissing Material))

In such a case we would like to say that these roles are non-overlapping. This could be accomplished through the use of a concept constructor non-overlapping, syntactically similar to same-as: (non-overlapping hasOnLoan hasAvailable). However, if only one library is involved, it would be better to model the situation using an appropriate subclass of Material, such as MissingMaterial, because we already have tools for modeling disjointness of subclasses, and reasoning with them is not inherently hard as is the case of general constructors such as same-as and non-overlapping.

10.6.1 Reiﬁed relationships

It is sometimes useful to be able to give “properties of properties”. For example, when some material is lent to a borrower, it is useful to record on what date the loan took place and when the material is due back. In the Entity–Relationship approach this would be modeled by the creation of a relationship class, called Loan, which would have attributes onLoan, lentTo, as well as lentOn and dueOn, describing the loan. This can be thought of as the reiﬁcation of the relationship, and results in the following DL class speciﬁcation:

Loan ⊑ (and (the lentTo Borrower) (the onLoan Material) (the lentOn Date) (the dueOn Date) (the NrOfRenewals (max 3))).

Unless the DL supports n-ary relations, reiﬁed relationships become essential when modeling associations that involve more than two objects, as would be the case, for example, if we had several libraries (or branches), and we wanted to record from which library the loan was made. Reiﬁed relationships have the disadvantage of requiring the modeler to distin- guish somehow the subset of attributes determining the relationship R(a, b, . . .) from those qualifying it. In the above case, we may imagine that Loan represents a binary relationship Loan(Borrower,Material) between lentTo and onLoan (in which case lentOn is there just to qualify the relation); alternatively, we may inter- pret Loan as a ternary relationship Loan(Borrower,Material,Date) between lentTo, onLoan and lentOn. The former records loans (a borrower may have a book at most once) while the latter records the history of loans. The notion of “keys/unique iden- tiﬁers” from databases, as adapted to Description Logics [Borgida and Weddell, 1997] can be used for this task, by marking the collection of attributes that describe the relationship as a key

We remark that the DLR Description Logic can express n-ary relationships directly, so it does not require reiﬁcation for this purpose.

10.6.2 Role hierarchies

In many applications, two roles on the same concept may be related by the constraint that every ﬁller of the ﬁrst role must be a ﬁller of the second role. For example, in the library domain, the ﬁllers of the role hasOnShortTermLoan, recording a borrower’s materials that need to be returned within a week, are also ﬁllers of hasBorrowed, recording all the materials borrowed (this would be true by deﬁnition). Similarly, the editorInChief of a journal would be included in its editorialStaff. One of the important features of frame knowledge representation schemes, and Description Logics in particular, is that they encourage the modeler to think of roles as ﬁrst-class citizens. This includes support for the notion of a role taxonomy (subroles). This is all the more reasonable, since once we reify a relationship, we would be allowed to create subconcepts of it at will. As a result, the above kinds of constraints on the containment of role ﬁllers can be modeled through the use of role hierarchies—a notion supported by most Description Logics, at least for primitive roles:

hasOnShortTermLoan ⊑ hasBorrowed.

10.7 Modeling ontological aspects of relationships

The material in this section deals with some special kinds of relationships and approaches to modeling them. The cognoscenti will recognize these as issues re- lated to the ontological aspects of a UofD (constructs relating to the essence of ob- jects), as opposed to epistemological aspects (constructs relating to the structure of objects), which are captured by notions such as InstanceOf and IS-A. The kinds of relationships to be discussed below do however occur relatively frequently, and pose difﬁculties to the uninitiated.

10.7.1 Relationship roles

A subtle, but important, distinction can be drawn between objects that may participate in a relationship (the domain restrictions on the role) and the objects that actually do take part in one or more relationships. For example, the objects participating in a lending relationship can be said to be playing certain “roles”: LentObject and Borrower It was exactly this second meaning of borrower as

a relationship role – that was contrasted with the original meaning of “potential borrower” in our example of Section 10.2. Description Logics allow one to deﬁne the relationship roles associated with a relationship. In the case when the relationship is modeled by a regular DL role, such as borrowedBy, we can deﬁne lent objects as ones that are being borrowed, and borrowers as objects that are the values of borrowedBy:

LentObject ≡ (at-least 1 borrowedBy) Borrower ≡ (at-least 1 (inverse borrowedBy)).

In the case of the reiﬁed Loan relationship, the deﬁnition of these classes would be

LentObject ≡ (at-least 1 (inverse onLoan)) Borrower ≡ (at-least 1 (inverse lentTo)).

10.7.2 Materialization

There is a family of situations whose modeling is complicated by the fact that several concepts can be referred to by the same natural language term. For ex- ample, one might say “Shakespeare wrote ‘Hamlet’,” “The ‘Hamlet’ in London this season is a success,” and “‘Hamlet’ was canceled tonight.” But there is a difference between the abstract notion of the play ‘Hamlet’, various stagings of the play, and particular performances. Other familiar distinctions of this kind in- clude the difference between an airline ﬂight (“Air France ﬂight 25 from Paris to London”) and a particular “instance” of it – the one that will leave on May 24, 2002. Failure to model such differences can result in the same kind of problem that arises with any other form of ambiguity – inappropriate use in a context. So one can only buy tickets to play performances, but theatrical awards are given to stagings. In each of these cases there is a relationship between a general notion (e.g., play staging) and 0-to-N more speciﬁc notions (e.g., performance of that play staging), which has been called materialization, and was investigated in [Pirotte et al., 1994]. Let us ﬁrst model some information that we would like to capture in the library domain:

/* Books have information about authors, etc. */ Book ⊑ (and . . . (all hasAuthors Person) (the hasTitle String))

/* Editions of books are related to the book (in a way yet to be speciﬁed)

but have their own roles too */ BookEdition ⊑ (and . . . (the publishedBy PublishingCompany) (the isbnNr IsbnNumber) (the format (one-of ’printed ’audio)))

/* Book copies are related to book editions, and in turn have their own roles */ BookCopy ⊑ (and . . . (the callNr CallNumber) (the atBranch LibraryBranch)).

There are several alternative ways of proceeding with the modeling of such a UofD. Since objects in each of these classes are seen to naturally have attributes like hasTitle, it is tempting to think of BookCopy as being a subclass of BookEdition so that this attribute is inherited. However, this would mean that each individual instance of BookCopy is a separate BookEdition, which seems wrong. If we are not committed to modeling separate individual instances of each of these concepts, it is possible to combine their description into a single concept that records all the relevant information. So, for example, we could deﬁne Books to have all the attributes of the three concepts above, and thus really refer to book copies. (But see below.) Finally, according to the results in [Pirotte et al., 1994], a more appropriate approach is to view each edition of a book as determining a subclass of BookCopy. Each of these subclasses can then be viewed as an instance of BookEdition, for which it provides so-called “meta-roles.” Materialization is the combination of these ideas. The materialization relationship can be modeled in Description Logics by a role materializationOf, connecting in our case book editions and books, and book copies and book editions. However, this sounds very unnatural when read out loud, so a better approach may be to create subroles of the general role materializationOf. This means that the above model would be completed by adding the following assertions

/* editionOf is a kind of materialization relationship */ editionOf ⊑ materializationOf

/* Book editions are materializations of books */ BookEdition ⊑ (the editionOf Book)

/* copyOf is a kind of materialization relationship */ copyOf ⊑ materializationOf

/* Book copies are materializations of book editions */ BookCopy ⊑ (the copyOf BookEdition).

Often, the properties of the more abstract concept are inherited by the material- ization. For example, the book edition, and then the book copy, has the same title and author as the book. In Description Logics, this relationships can be expressed by identifying the appropriate attribute values on the general and the materialized object:

BookEdition ⊑ (same-as hasTitle (editionOf ◦hasTitle)).

Several additional kinds of relationships between attributes of an object and its materialization are identiﬁed in [Pirotte et al., 1994], but they are rather unclear and cannot be represented in Description Logics. Probably the most interesting is the case when an attribute of the more general concept has no correspondent on materialized individuals. For example, though a book edition may reasonably record the date when it was ﬁrst and last printed, it seems very questionable to say that a book copy has a last printing date. This looks like a case of meta-roles of the kind mentioned earlier. The main importance is that if one wants to have in the model attributes such as firstPrinting, then one cannot “melt” objects (book editions) into their various materializations (book copies), and is forced to model them separately.

10.7.3 Part–whole aggregation

The part–whole relationship distinguishes roles of a book such as its chapters, from others such as its publisher. There is a long history of discussions concerning this topic, with [Artale et al., 1996b] being an excellent and comprehensive survey that considers, among other things, a variety of DL solutions to the problem. We present here some interesting observations. Cognitive scientists have distinguished a variety of part-whole relationships, whose mixture has caused apparent paradoxes; according to one hypothesis these can be distinguished by differentiating three kinds of wholes – complexes, col- lections and masses – with parts called components, members and quantities re- spectively; furthermore parts can be portions (sharing intrinsic properties with the whole) and segments Most physical objects like book copies are complexes of

their parts (e.g., pages), but in the book domain we also ﬁnd uses for collections in modeling books that are anthologies of other literary pieces. In addition, one can qualify the nature of two aspects of the relationship between parts and wholes:

r Existence: A whole may depend on particular individual(s) for its continued existence and identity, as in the case when the part is irreplaceable (e.g., a book must have an author); or it may depend generically on a class of parts (e.g., a book copy must have a cover). Conversely, the part may depend on the whole for its existence (e.g., the chapter of a book). Finally, a part may belong exclusively to only one whole or it might be shared. r Properties: Properties may be “inherited” from the whole to the part (e.g., ownedBy) or from the part to the whole (e.g., isDefective).

At the very least, the above provides a checklist of issues to consider whenever a part–whole relationship is encountered during modeling. In the realm of Description Logics, Sattler [1995] offers an approach to dealing with these topics, exploiting various role-forming operators such as role hierarchies, role inverse, and transitive closure to capture the semantics of aggregation. Speciﬁcally, special roles are introduced for the different kinds of part–whole relationships mentioned above: hasDComponent, hasDMember, hasDSegment, hasDQuantity, hasDStuff, hasDIngredient, where “D” stands for “direct”. One then deﬁnes more complex relationships from these primitives:

hasComponent ≡ (transitive-closure (orrole hasDComponent (hasDMember ◦hasDComponent))) hasPart ≡ (orrole hasComponent hasMember . . .)

indicating that members of collections of components are also components, and that hasPart is the union of the various subkinds of relationships. Let us concentrate here on the component-of relationship, which is probably the one most frequently encountered in practical applications. We shall consider the table of contents of a book as an exemplar of a component attribute. One idea is to declare attributes and roles that represent components (e.g., tableOfContents) as specializations of hasDComponent. This allows us to distinguish such component roles from other roles, like lentTo and publisher. Obviously, the inverses of such roles provide access from a part to its containing whole:

isDComponentOf ≡ (inverse hasDComponent) hasTableOfContents ≡ (inverse contentsOf).

Turning to “existence” constraints, a book (but not a copy of a book!) depends on the existence of its speciﬁc table of contents and conversely Although we

can specify that a book must have table of contents, as with earlier “dynamic” aspects (such as (im)mutable class membership) standard Description Logics are not currently equipped to express constraints stating that an attribute value cannot change. To model the fact that each table of contents belongs exclusively to one book, we can use qualiﬁed number restrictions

TableOfContents ⊑ (the contentsOf Book).

Finally, the inheritance of properties (e.g., isDefective) across component-like attributes is modeled using constructs such as same-as, which relate attribute/role chains set-theoretically, in the same manner as shown with materialization:

Book ⊑ (same-as isDefective (hasTableOfContents ◦isDefective)).

Note however that several of these representations require quite expressive lan- guage constructs, whose combination may result in a language for which subsump- tion is undecidable.

10.7.4 General constraints

In many modeling exercises one will encounter general constraints that characterize valid states of the world. For example, the dueDate of a book must be later than the lentOn date. Except for a few cases involving identity of attribute paths, these constraints will not be expressible in standard Description Logics, due to their limited expressive power. Several widely distributed systems, such as Classic and Loom, offer “es- cape hatches”—concept constructors that allow one to describe sets of individuals using some very powerful language, such as a programming language (Classic’s test-concepts) or some variant of ﬁrst-order logic (Loom’s assertions). These concept deﬁnitions are usually opaque as far as concept-level reasoning is con- cerned, because the system cannot guarantee correctness for such an expressive formalism. However, these concepts can have an impact as far as the ABox rea- soning is concerned, since the latter resembles a logical model, and therefore we can do relatively simple “evaluation” as a way of recognizing individuals. Thus, in Classic, the test-concept (test date-after (dueDate lentOn)) would invoke the date-after function on the dueDate and lentOn attributes of an individual object, and check that the ﬁrst is temporally after the second, thus classifying individuals, or detecting errors in the ABox. More general than these procedural extensions are DL systems that are extensible in the sense that a “knowledge language engineer” can add new

concept constructors, and extend the implementation in a principled way. For example, if we wanted to deal with dates and durations (clearly a desirable feature for libraries), we would want to be able to compare dates, add dura- tions to dates, etc. General approaches to extending Description Logics have been described, among others, in [Baader and Hanschke, 1991b; Borgida, 1999; Horrocks and Sattler, 2001].

10.7.5 Views and contexts

Although the initial goal is usually to provide a single model of the UofD, it turns out to be very important to preserve the various “views” of the information seen by different stake-holders and participants. For example, a book that is in the library (and by deﬁnition, this would mean that it has no value for the lentTo role) is of interest to the staff, for example to help ﬁnd it; for this, it may have a role location, which might specify some shelf or sorting area; this attribute may be attached to the MaterialInLibrary concept. On the other hand, a view of Material called MaterialOnLoan (which requires a lentTo role value), would be a natural place to keep information about dueDate and nrOfRenewals – attributes that would normally appear on the relationship itself. This view is of particular interest to the borrower, but also the staff in charge of sending overdue notices. Incidentally, the above pattern of replacing a binary relationship having attributes by two views can be applied any time one of the participants in the relationship is restricted to appear in at most one tuple (e.g., every book can be loaned to at most one borrower).

10.8 A conceptual modeling methodology

The world of object-oriented software development has produced a vast literature on methodologies (e.g., [Shlaer and Mellor, 1988]) for identifying objects, classes, methods, etc., for a particular application. Instead of considering this voluminous material here, we will recapitulate some of the issues raised above by extending the outline of a simple DL knowledge engineering methodology ﬁrst presented in [Brachman et al., 1991]. The reader is referred to that article for more details, including a long worked-out example. We present the main steps of modeling, with suggestions for reﬁnements to be accomplished in later passes; this is in order to avoid the modeler becoming overwhelmed by details:

r Identify the individuals one can encounter in the UofD. Revisit this later considering iss es s ch as materiali ation and al es

r Enumerate concepts that group these values. r Distinguish independent concepts from relationship-roles. r Develop a taxonomy of concepts. Revisit this later considering issues such as disjointness and covering for subconcepts. r Identify any individuals (usually enumerated values) that are of interest in all states of the world in this UofD. r Systematically search for part–whole relationships between objects, creating roles for them. Later, make them subroles of the categories of roles mentioned in Section 10.7.3. r Identify other “properties” of objects, and then general relationships in which objects participate. r Determine local constraints involving roles such as cardinality limits and value restric- tions. Elaborate any concepts introduced as value restrictions. r Determine more general constraints on relationships, such as those that can be mod- eled by subroles or same-as. (The latter often correspond to “inheritance” across some relationship other than IS-A, and have been mentioned in several places earlier.) r Distinguish essential from incidental properties of concepts, as well as primitive from deﬁned concepts. r Consider properties of concepts such as rigidity, identiﬁers, etc., and use the tech- niques of [Guarino and Welty, 2000] to simplify and realign the taxonomy of primitive concepts.

10.9 The ABox: modeling speciﬁc states of the world

So far, we have concentrated on describing the conceptual model at the level of concepts. In some applications we may want to use our system to keep models of speciﬁc states of the world – somewhat like a database. As discussed in Chapter 2, this involves stating for each speciﬁc individual zero or more ﬁllers for its attributes and roles, and asserting membership in zero or more concepts (primitive, but also possibly deﬁned). One of the challenging aspects of modeling the state of the world with Descrip- tion Logics is remembering that unlike databases, DL systems do not make the closed-world assumption. Thus, in contrast with standard databases, if some rela- tionship is not known to hold, it is not assumed to be false. One consequence of this is that any question about the membership of an in- dividual in a concept, or its relationship to another individual, has three pos- sible answers: deﬁnitely yes, deﬁnitely no, or unknown. The positive side of this is that it allows the modeling of states with partial information: one can model that BOOK22 is an instance of Book, and hence has exactly one ﬁller for isbnNr, yet not know what that value is. Chapter 12 shows how this feature has been exploited in developing a family of DL applications for conﬁguring various devices

Another consequence of the above stance is that in some cases individuals are not recognized as satisfying deﬁnitions when one might expect them to. For example, suppose we only know that hasAuthor relates BOOK22 to SHAKESPEARE, who in turn is known to be an instance of Englishman. This, by itself, is not enough to classify BOOK22 as an instance of concept (all hasAuthor Englishman); we must also know that there are no other possible ﬁllers for BOOK22’s hasAuthor role – i.e., that BOOK22 is an instance of (at-most 1 hasAuthor) – be- fore we can try to answer deﬁnitively whether BOOK22 is an instance of (all hasAuthor Englishman). Even in this case, if the answer is not ‘yes’, we may get ‘no’ or ‘maybe’. A ﬁnal consequence of not making the closed-world assumption is that there is a clear distinction between the state of the world (out there) and our (system’s) knowledge of it. This is reﬂected by the terminology used above (e.g., “we must also know there are no other possible ﬁllers”). As a result, in modeling a domain one may ﬁnd it necessary to specify concepts that involve the state of our knowledge base, rather than the state of the world. For example, we might want to ﬁnd out exactly which books in the KB are not known to have a ISBN number. The description (and Book (at-most 0 isbnNr)) will not do the job, because the second constraint would conﬂict with one of the the necessary conditions of Book, which is that it must have have exactly one isbnNr. What is happening here is that the at-most 1 constraint concerns the state of the world, while the at-most 0 condition involves the KB’s knowledge of the world. To deal with this, we need some form of epistemic operator, so we can deﬁne the concept

UnknownIsbnBook ≡ (and Book (at-most 0 (known isbnNr))).

The general problem of adding an epistemic operator to Description Logics is con- sidered in [Donini et al., 1998a], but this is not available in currently implemented Description Logics. A “hack” would be to introduce for such roles a subrole, whose identiﬁer indicates its epistemic nature:

knownToHaveAuthor ⊑ hasAuthor

and then be sure to assert ﬁllers only about the “known” variant. Unfortunately, there is no way to tell a Description Logic that such roles automatically have the “closed-world assumption”.

10.10 Conclusions

There are a wide variety of sources that discuss the application of object-oriented approaches to modeling a domain The same principles apply to conceptual

modeling in general. For this reason, we have concentrated here on some of the more subtle ontological issues that arise during modeling, and the different ways in which these can be encoded in Description Logics. In some cases the issues examined were suggested by features of Description Logics themselves. In the process, we covered most of the kinds of questions that would have to be addressed while modeling something like the library domain, and uncovered some of the strengths and also some of the weaknesses of Description Logics in representing this conceptual model. The latter include difﬁculty in representing (structured) values, constraints related to the dynamic aspects of the domain, certain forms of “inheritance” (e.g., for materialization), and meta-information. These were balanced by the multitude of features dealing with primitive and deﬁned concepts, necessary and sufﬁcient conditions for concept speciﬁcation, and the treatment of roles as ﬁrst-class citizens in subclasses and composition. Probably the biggest problem in developing an appropriate conceptual model for a domain is that of testing it for correctness and completeness. The former is supported by the reasoning and explanation facilities provided by Description Logics. The latter, as usual, is much more difﬁcult to achieve.

11

Software Engineering

CHRISTOPHER A. WELTY

Abstract

This chapter reviews the application of Description Logics to software engineering, following a steady evolution of DL-based systems used to support the program understanding process for programmers involved in software maintenance.

11.1 Introduction

One of the ﬁrst large applications of Description Logics was in the area of software engineering.Insoftware,programmersandmaintainersoflargesystemsareplagued with information overload. These systems are typically over a million lines of code, some approach ﬁfty million. The size of the workforce dedicated to maintaining these enormous systems is often over a thousand. In addition, turnover is quite high, as is the training investment required to make someone a productive member of the team. This seems, on the surface, to be a problem crying out for a knowledge- based solution, but understanding precisely how Description Logics can play a role requires understanding the basic problems of software engineering “in the large”.

11.2 Background

The three principal software maintenance tasks are pro-active (testing), reactive (debugging), and enhancement. Central to effective performance of these tasks is understanding the software. In the 1980s, cognitive studies of programmers involved in program understanding [Soloway et al., 1987] revealed two things:

(i) Programmers typically solve problems by realizing “plans” in their programs. This seems to tie the notion of program understanding to plan recognition [Soloway et al., 1986]

(ii) Delocalized plans (plans which are not implemented in localized regions of code) are a serious impediment to plan recognition, for both humans and automated methods [Soloway and Letovsky, 1986].

While these observations were interesting, the studies from which they were derived were slightly ﬂawed from the industrial perspective described above: the subjects of these studies were almost exclusively students working alone with small domain-independent programs (i.e., sorting, searching, etc.). It was not clear how these results applied to experienced programmers working in teams with huge domain-speciﬁc programs. An ambitious effort launched by AT&T [Brachman et al., 1990] attempted to address this problem by studying maintainers of a large software system, and mea- suring the time they spent performing different categories of tasks. What they found was a bit startling: up to 60% of the time was spent performing simple searches across the entire software system. A part of what was termed discovery, and as pointed out later in [Welty, 1997], the need for these searches was the result of the delocalization not only of plans in software, but of information in general; informa- tion a maintainer needs to understand a section of code is frequently not found in the vicinity of that section of code, but may be before or after in the ﬁle, in a different ﬁle, in a different directory, etc. For a large software system whose source code is spread out over a large number of ﬁles in a deep and complex directory structure, ﬁnding something as simple as, e.g., the deﬁnition of a datatype, with tools such as ﬁnd (the Unix program that runs another program on all ﬁles recursively down a directory structure) and grep (the Unix program that searches ﬁles for strings) was both difﬁcult and time-consuming. Another more comprehensive study was performed by MCC around the same time [Curtis et al., 1988], which concluded, among other things, that a prerequisite to understanding the software is understanding the domain in which the software operates and is a part – if you don’t know what a “dial tone” is, you can’t be expected to debug the code that generates a dial tone.

11.3 Lassie

In an attempt to have a direct impact on the maintenance group, the researchers at AT&T developed the notion of a Software Information System (SIS) [Brachman et al., 1990]. An SIS is basically an information system which treats the software system source code itself as data, and stores relationships that can provide the information maintainers frequently search for during discovery. The ﬁrst SIS, Lassie [Devanbu et al., 1991], was developed to assist the understanding of AT&T’s Deﬁnity 75/85 software system Inﬂuenced by their

LASSIE-THING

UNIX-THING

CODE-THING

EXTENSION

MACRO

FILE

GLOBAL

CODE-FILE DIRECTORY TYPEDEF

FUNCTION

C-FILE

H-FILE

Fig. 11.1. The Lassie code-level ontology.

THING

STATE DOER

ACTION

OBJECT

RESOURCE-STATE

USER GROUP

EXTERNAL-ACTION

INTERNAL-ACTION

SOFTWARE-OBJECT

RESOURCE-OBJECT

PROCESS

OFF-HOOK-ACTION

GENERATE-DIAL-TONE

TRUNK

DIAL-TONE-GENERATOR

Fig. 11.2. The Lassie telephony ontology.

own study and that of MCC, it contained two components: a domain model and a code model. The code model was implemented with a simple ontology of source code ele- ments, shown in Figure 11.1, which was derived empirically from the basic kinds of searches maintainers performed. The knowledge base (the actual assertions about individual functions, ﬁles, datatypes, etc.) was populated automatically from the source code. The domain model was reverse engineered from the code and contact with the domain experts, and contained knowledge about the telephony domain, i.e. the things the software system dealt with. These included entities such as telephones, microphones, cables, cable-trunks, etc. A sample of the ontology is shown in Figure 11 2

One of the most interesting aspects of this work, and perhaps the most signif- icant from the perspective of exploring Description Logics, is an analysis of the differences between these two models. The code model was founded on a very sim- ple ontology, containing perhaps twenty concepts, and was populated with a large number of individuals, on the order of thousands (at least one for each ﬁle, datatype, function, and variable in the system). The domain model had a large and complex ontology, containing perhaps two hundred concepts, but very few individuals. The reason for this difference was that the trivial searches that characterized software discovery were performed for two reasons:

(i) Discovering speciﬁc information about the software, e.g., what is the datatype of the variable dial-tone? (ii) Discovering speciﬁc information about the domain, e.g., what is a dial tone?

In case (i), the maintainer requires speciﬁc information about the software, and thus raw data that represents that information is required. For example, by far the most common question asked during discovery is, “Where is this variable used?” [Welty, 1997]. Normally, a maintainer would grep for the variable in the rest of the code to ﬁnd the answers to this question, and as if this didn’t take enough time and effort, the results would have to be pruned by hand to remove various kinds of “semantic noise” such as:

(i) variables with longer names that include the desired variable name (ii) names of functions that include the desired variable name (iii) comments that include the variable name (iv) other non-variable string matches.

In this particular case, the amount of semantic noise was quite high as a result of mandated naming conventions whose intent was to make the source code easier to understand (semantic noise, also known as false positives, is a general problem with string-based search methods, and will be discussed further in Chapter 14). The SIS code model immediately solved these problems by identifying “vari- able” as a semantic category (as well as ﬁle, function, etc. See Figure 11.1). This meant, quite simply, that where a string search for places in which e.g., the variable error-value was used might yield such unwanted results as: compute-error- value, display-error-value-result-code, error-value-lookup-table, etc., limiting the search to variables would remove up to 80% of the noise. In addition to trivially being able to restrict searches to speciﬁc categories, other information that could be extracted automatically was mined from the code. For variables, it is simple to automatically determine:

r the ﬁle it was deﬁned in r each f nction in hich the ariable as sed

In addition, for each function, information was extracted regarding the ﬁle it was deﬁned in. From this, a simple inference could be made as follows:

Variable ≡∀usedInFile.File ⊓∀usedInFunction.Function ⊓ usedInFile = usedInFunction ◦definedInFile.

In other words, if a function uses a variable then the variable is used in the ﬁle that function is deﬁned in; this produces all the locations where the variable is used. In this manner, the Lassie system augmented the basic data in a number of ways through inference. A similar and nearly as common maintenance task was, e.g., after modifying a function, searching for all the places that function is used to see if the changes affect other sections of the code. Information about what functions call others (i.e., the call graph) was also kept in the code model, and an expression similar to the one in the example above can be used to derive all the ﬁles in which a function is called. The code model alone was able to simplify several of the common discovery tasks maintainers experienced during code modiﬁcation, but as suggested in case (ii) of the reasons for engaging in discovery listed above, there are other reasons for a maintainer to be searching through the code. For these cases, in which domain information is the desired result of a search, a robust description of the domain is required, and was provided by the domain model (see Figure 11.2). For example, a maintainer may want to know what kinds of actions a user of the system can take by themselves. To answer this question from the code – the usual approach before Lassie– would be quite difﬁcult. One method might be to grep through the code for the string “user” – hoping of course that the documentation is up to date or consistent with respect to user actions. Clearly the semantic noise would be quite high in such a case. Another approach might be to start with a piece of code the maintainer is familiar with, and draw some clues from that for where to look next. The point here is that, whereas for code-model queries the goal is quite speciﬁc, domain-oriented queries are not, and imply a lot of time browsing, searching for new ideas, etc. The code is organized around speciﬁc functions, not around speciﬁc domain concepts, and of course multiple “views” of the code are not supported. Toaddressthistypeofneed,theLassiedomainmodelexpressedknowledgeabout the domain of telephony. It presented numerous key concepts that let maintainers view the knowledge in the code in a variety of different ways. The domain model was mostly terminological, since it was a description of the things that the software could do. An action concept, such as “generating a dial tone” was a description of the action, whereas an individual would be an actual action of generating a dial tone at some ﬁxed time These individuals did not normally exist in the domain model

except as examples. The concept would roughly be

GenerateDialToneAction ≡Action ⊓∀initiatedBy.LatBox ⊓ ∀follows.OffHookAction ⊓ ∀recipient.LocalPhone ⊓⩾1 hasConnection.

In other words, a “generate dial tone action” is an action that is initiated by a local telephone service following an “off hook action.” The recipient of the prod- uct of the action (the dial tone) is a phone for which a connection has been allocated. Other domain concepts described things that the software reacted to, such as

OffHookAction ≡Action ⊓∀initiatedBy.User ⊓⩽0 follows ⊓ ∀recipient.LatBox ⊓∀activates.AllocateConnectionAction.

In other words, an “off hook action” is an action that is initiated by a user (more commonly the result of pressing a button these days than lifting the receiver off the hook). It follows no previous action, and the recipient of the product of the action is the local telephone service (on which the software is running). The action activates a search for a connection. Returning to the randomly chosen example above, the maintainer looking for all actions that can be initiated by a user would simply enter a query such as

Action ⊓∀initiatedBy.User

and the system would ﬁnd all the concepts subsumed by that expression. Lassie contained a facility for deﬁning new domain concepts identiﬁed by maintainers during discovery, and adding them to the domain model by simply assigning them a name (e.g., USER-ACTION in this example). While these two models independently solved existing problems, it soon became clear that integrating the two models was an important requirement. Using the tool exposed the fact that most domain queries were followed by code queries. For example, after exploring the domain model to discover the signiﬁcance of a “connect action”, the maintainer will typically ask, “What are the functions that implement it?” In addition, classifying software components by their relevance in the domain was viewed to be a very signiﬁcant bit of functionality, as this permitted components to be found and retrieved with this information – something that was not previously possible. This integration between the two models made it possible to use subsumption to ﬁnd different software objects. For example, all functions that implement connect actions would be

Function ⊓ConnectAction

Variables used in functions that implement user actions would be

Variable ⊓∀usedInFunction.UserAction.

The Lassie system underwent steady development for several years at AT&T, and was shown to cut down on the time maintainers spent in discovery. In order to further improve the process, it was observed that:

r The connection between the domain and code models needed to be made by hand. This was time-consuming to create, and difﬁcult to maintain since the domain model changed over time as new features were added to the software system. Maintainers began to lose faith in the domain model, as a result, and usage deteriorated. r The code model, though extremely simple, was used far more frequently than the domain model, and became an important part of every maintainer’s tool set. It did not, however eliminate the searches maintainers made, and therefore did not completely replace ﬁnd and grep.

11.4 CodeBase

Because the code model proved quite useful and easy to maintain, the demand for it began to increase. This introduced two problems for the Lassie SIS:

r Like all DL-systems, it was based on main memory. The software contained many thou- sands of functions, variables, and ﬁles. More importantly, the complexity of the function call graph, variable usage graph, and location maps, exceeded one million. It was not possible to store this amount of information in main memory of any computer at that time. r The natural language interface, while simple and easy to understand, did not facilitate using the system quickly. One still had to compose a proper query and type it in. If the result of one query were to be used in another, the maintainer had to re-type the name(s) of the concepts or individuals involved. Increased usage demanded a better user interface.

The CodeBase system [Selfridge and Heineman, 1994] offered solutions to both oftheseproblems.Perhapsthemostsigniﬁcantachievementwasthedevelopmentof a system for off-line storage of individuals. The relatively small code-model TBox was always kept in memory, but individuals were kept on a disk, in a technique similar to virtual memory. The difference was in the heuristics used for predicting what portions of the ABox to pre-load. Whereas a virtual memory system normally uses heuristics based on temporal or spatial proximity, for a knowledge base like Lassie, this was not relevant. The location of an individual in physical memory was no indication of its relevance to other individuals near it in physical memory. The heuristics for virtual memory are based on the empirical observation that when one location is accessed it is probable that the next access will be to a nearby

location in memory. The Lassie developers observed that, in a DL ABox, when an individual is accessed it is probable that the next access will be to one of its role ﬁllers, or to objects along some role path from the accessed individual. Because a role may have many ﬁllers, and because an individual may have many roles, there is no way to arrange the individuals in memory so that the normal virtual memory heuristics will be efﬁcient. CodeBase also provided numerous graphical tools for viewing and browsing the information in the knowledge base. While this is less signiﬁcant from the general perspective of Description Logics, it is important from the standpoint of developing knowledge-based systems. One must never forget that these systems interact with people, and can not be considered as viable systems unless the human is “in the loop”.

11.5 CSIS and CBMS

Development of Lassie was eventually halted by the trivestiture of AT&T in 1995. Research into software information systems did not stop, however, and Description Logics have played an important role in this continued development. Two issues were brought to light by the Lassie system:

r The deterioration of the domain model over time was another manifestation of the classic software documentation problem: the same information being stored in different ways. The code model stayed relevant because it was automatically generated from the only thing that had to be maintained: the software. It did not, therefore, need to be maintained separately to remain accurate. The documentation and the domain model were different representations of the knowledge that was, perhaps implicitly, in the code. These repre- sentations always lagged the “real” one, since they had to be maintained independently. r The delocalization of information in software, which is the central obstacle to code understanding, required new ways of viewing the code. Looking at code on the screen, analogously to the heuristics for operating system virtual memories, is inherently two- dimensional. It does not allow relationships between code-level entities to be viewed, or localized.

The ﬁrst step in determining how to address these problems was to perform further studies of programmers involved in discovery to gain more detailed insight into speciﬁcally what they were doing. One such study, in this case of programmers maintaining a moderate-sized object-oriented software system, found that the most common high level queries were:

(i) Where is this variable modiﬁed? (ii) What are the available slots and methods on this instance? (iii) What is the datatype of this variable or function? (i ) What are the s perclasses of this class?

(v) What does this function return? (vi) Does this function have side-effects? (vii) Is this datatype used?

Clearly, to provide answers to questions like these requires far more ﬁne-grained information about the software than simply the locations of the deﬁnitions. Further- more, this study conﬁrmed that object-oriented languages actually increase under- standing problems by delocalizing much more information than their imperative predecessors [Huitt and Wilde, 1992]. Inheritance, in particular, spreads method and slot (instance variable) declarations up the class hierarchy, making it harder to ﬁnd answers to questions about class composition, among other things. These issues spurred research into Comprehensive Software Information Systems [Welty, 1995], which soon became Code-Based Management Systems. The idea of CBMS was to deﬁne the most precise level of granularity of representation needed to have complete knowledge of the software system in the knowledge base. In other words, to have the knowledge-based representation be the artifact that is maintained. From a DL perspective, such a comprehensive representation of software in a knowledge base required the ability to deal with large amounts of information efﬁciently. In addition, such a deep representation made it possible for a wide range of inferences that were well-suited for subsumption reasoning. A CBMS is based on a full-scale parse of the code to construct an abstract syntax tree (AST), which is basically the parse tree. The AST has all the information of the source code, such that the source code can be completely generated from the AST. The AST is augmented with semantic information that can be derived automatically from the syntax. In C++, for example, we know that the left side of an assignment operator is the variable to be changed, and the right side is the new value. The ability to represent everything in the code requires a deeper ontology of code-level software elements than the original Lassie ontology, that includes state- ments, blocks, conditions, etc. In fact, every syntactic element of the programming language is in the ontology. A simpliﬁed ontology for an object-oriented language is shown in Figure 11.3. In addition to these concepts representing the syntactic elements of the source language, roles were use to relate instances of these concepts to each other for control ﬂow, data ﬂow, call graphs, etc. For example, take the following C++ code fragment:

void group_deliver ( MAIL_MESSAGE message, GROUP group) { LIST members; members = get members(group);

SOFTWARE-THING

SOFTWARE-VALUE SOFTWARE-OBJECT

SOFTWARE-ACTION

CODE-BLOCK

DATA-TYPE-INSTANCE ACTION-WHOLE ACTION-PART

DATA-TYPE

CONSTANT MESSAGE

PASS-PARAMETER

METHOD PROGRAM

RETURN

CHANGEABLE-INSTANCE

DESTROY

SELECT-SWITCH-CASE

SWITCH

DESTROY-METHOD

VARIABLE

ASSIGNMENT

INSTANTIATE

SLOT

CREATE-METHOD

SELF-VARIABLE

PARAMETER

Fig. 11.3. A simpliﬁed code-level ontology.

while (! empty(members)) { ind_deliver(message,car(members)); members = cdr(members); } }

The CBMS representation of that fragment is shown in Figure 11.4. Note that Figure 11.4 shows only the ABox corresponding to the small code fragment, and that role ﬁllers are shown as binary relations. With an interface that showed individuals in the code representation with role ﬁllers displayed as hypertext links (see [Welty, 1996a]), this ontology alone localizes far more information than the standard text view of software dis- played in an editor window. Again, an editor window localizes only the control ﬂow information; a maintainer looking, e.g., at the code fragment shown above, only sees the text. The lines are arranged in roughly control-ﬂow order. Using a CBMS representation, a maintainer’s view is focused on a particular object, such as the assignment statement on the ﬁrst line of the function. This view would be:

new-value

argument

function-call-01

parameter-02

group

has-data-type has-data-type

start

function-01

assignment-03

has-data-type

data-type-07

slot-13

next

has-data-type

has-slot

changes

data-type-08

local-variable-05

members

while-01

when false

argument

test

argument argument

function-call-02

return-04

while-true

function-call-04

function-call-05

new-value changes argument

parameter-01

function-call-03

message

assignment-04

has-data-type

data-type-09

next

Fig. 11.4. A CBMS representation of the code fragment.

ASSIGNMENT-STATEMENT-23: implementation-of: {FUNCTION-03: group_deliver} next: {WHILE-STATEMENT-14} changes: {LOCAL-VARIABLE-16: members} new-value: {FUNCTION-INVOCATION-34: get-members(group)}

In this kind of view, anything in {. . . } is a hypertext link to a similar description of the individual named in the link, and localization takes on a new meaning: the number of hypertext links a desired piece of information is from the current context (individual being viewed). For example, information about control ﬂow is accessiblethroughachainofnextlinks,butinaddition,informationaboutdataﬂow is accessible through the new-value link, about the function being implemented, about the variable being used, etc. Another advantage of the CBMS approach is that reasoning can be employed to augment the data and automate the localization of even more information. In existing work in Classic, three types of reasoning were employed:

Role inverses. Every role in the ontology has an inverse, and this provides a tremendous amount of simple bookkeeping information useful to maintainers

In the example above, the changes role is ﬁlled through parsing with mem- bers, and the inverse relationship, that the variable members is changedBy ASSIGNMENT-STATEMENT-23, is added as well. The power of this simple in- ference can not be understated. Studies showed that this was the most useful kind of information the system provided, as it answered the most common question asked by maintainers. Path tracing. Many useful pieces of information were a few clicks away, but would be more useful if brought within one click (i.e., one link). A simple set of forward chaining “ﬁller” rules in Classic are capable of handling this. For ex- ample, it is also useful to know within which functions a variable is changed. Without inference, the maintainer must click on the changedBy role for a variable to get to the statement that changes it (or statements), and then must click on the implementationOf role for the statement to get to the function. Instead, with “path-tracing rules”, we can ﬁll the changedInFunction role au- tomatically with all the values from the path (changedBy implementationOf). Thus in our example we can conclude that members is changedInFunction group deliver. Subsumption. With subsumption reasoning, membership in a number of useful classes can be inferred for individuals representing pieces of the code. For example, the concept GlobalAssignmentStatement is deﬁned:

GlobalAssignmentStatement ≡AssignmentStatement ⊓ ∀changes.GlobalVariable

which allows all the assignment statements that modify global variables to be identiﬁed.

The most compelling result that came out of the CBMS work so far has been the automatic detection of side-effects, answering the sixth most commonly asked question. This detection was not originally believed to be possible. To simplify the discussion, we assume a pure object-oriented language without pointers or call-by- reference parameters. The latter can be handled in a similar way, the former is still believed to be undecidable. There can be two kinds of direct side-effects in a method: a change to a global variable, and any sort of output. A third kind of side-effect is a call to a method that has a side-effect. In this case, the side-effect does not actually occur within the callingmethod,yetaside-effectwilloccurwhenthecallingmethoditselfisinvoked, so it can be important to discover it. A change to a global variable occurs whenever that variable appears in an assignment statement as the variable to be changed. The CBMS ontology contains a fairly simple extension which can automatically detect side effects on global variables and calls to methods with side effects Output

SOFTWARE-THING

SIDE-EFFECT-THING

SIDE-EFFECT

DIRECT-SIDE-EFFECT INDIRECT-SIDE-EFFECT

OUTPUT-SIDE-EFFECT

Fig. 11.5. The side-effect ontology.

methods must be speciﬁcally identiﬁed as such in order that calls to them may be recognized. This is not really a problem, since output functions are generally part of a support library which would be provided to any developer. The extension begins with a new part of the code-level ontology, shown in Figure 11.5. This new ontology of primitive concepts ﬁts under the SoftwareThing concept. Next, any individual of GlobalAssignmentStatement (deﬁned above) is a side-effect – an AssignmentSideEffect. In order to put individuals of AssignmentSideEffect into the side-effect ontology shown in Figure 11.5, a forward chaining rule is added:

AssignmentSideEffect ⇒DirectSideEffect.

This rule is required because if the relationship it speciﬁes were part of the deﬁned concept, being a direct side-effect would become a sufﬁcient condition for recog- nizing assignment side-effects, and they would never be found automatically. In other words, the rule says “once an assignment side-effect is recognized, it should be also be classiﬁed as a direct side-effect”, whereas putting direct side-effect after assignment in the deﬁned concept deﬁnition would say, “An assignment side-effect must already be known to be a direct side-effect to be recognized”. The latter is not productive. At this point we can classify all assignments that change global variables as assignment side-effects and direct side-effects. The next addition is a set of roles that will help identify the methods that contain these side-effects: hasDirectSideEffect, its inverse directSideEffectOf, and their role parents hasSideEffect and SideEffectOf With these roles deﬁned a path tracing rule is

added for DirectSideEffect that says directSideEffectOf = implementationOf. In other words, the directSideEffectOf role should be ﬁlled with the value in the implementationOf role of the assignment. Through the role hierarchy, this also adds the SideEffectOf role, and through the inverse, the individual of Method that ﬁlls this role gets the hasDirectSideEffect and hasSideEffect roles pointing back to the assignment. With these inverse roles ﬁlled in, we can create a new deﬁned concept to recognize methods with side-effects:

MethodWithSideEffects ≡Method ⊓⩾1 hasSideEffects

and a more speciﬁc one for methods with direct side-effects:

MethodWithDirectSideEffects ≡Method ⊓⩾1 hasDirectSideEffects.

Note that the second concept will automatically be classiﬁed under the ﬁrst. Now, as a result of the rules that added the hasSideEffect links, every method that has in its implementation a slot assignment side-effect will have at least one ﬁller in its hasDirectSideEffects role, and will be classiﬁed as a method with direct side- effects. The next case is detecting indirect side-effects, which ﬁrst requires recognizing invocations of methods that have side-effects (in object-oriented terms, a method invocation is a message):

MessageSideEffect ≡Message ⊓∀callMethod.MethodWithSideEffects.

Individuals of this new concept can be recognized since all methods with side-effects have been found with the previous two deﬁned concepts. A simple forward chaining rule then links these message side-effects back into the side-effect ontology:

MessageSideEffect ⇒IndirectSideEffect.

Next we deﬁne two more roles: hasIndirectSideEffect and its inverse indirectSideEffectOf, and make them children of hasSideEffect and SideEffectOf, respectively. Once these roles have been deﬁned, and the message side-effects have been found, we can identify all the methods that have them in a similar manner to assignment side-effects. First, create a path-tracing rule for IndirectSideEffect: indirectSideEffectOf = implementationOf which will ﬁll in roles. Now we identify all these methods with indirect side-effects with the concept

MethodWithIndirectSideEffects ≡Method ⊓⩾1 hasIndirectSideEffects

The ﬁnal step is simply to link methods with side-effects into the side-effect ontol- ogy with one last forward chaining rule:

MethodWithSideEffects ⇒SideEffectThing

The addition of this rule basically creates the side-effect ontology shown in Figure 11.5. Not only do these deﬁnitions identify functions with side-effects, but they also lead a maintainer directly to the side-effect itself. The point here, from a software understanding perspective, is that subsumption makes it possible to localize infor- mation that otherwise would be difﬁcult (or at least time-consuming) to discover. The inferences for ﬁnding side-effects are clearly very deep, yet the developer or maintainer need not be aware of them. All these side-effect inferences come with no extra work by the developer or maintainer at all. In fact, answers to all of the top questions asked by maintainers during discovery can be localized to within one link, therefore one mouse click in the simple hypertext interface described.

12

Conﬁguration

DEBORAH L. McGUINNESS

Abstract

Description Logics are used to solve a wide variety of problems, with conﬁguration applications being some of the largest and longest-lived. There is concrete, commer- cial evidence that shows that DL-based conﬁgurators have been successfully ﬁelded for over a decade. Additionally, it appears that conﬁguration applications have a number of characteristics that make them well-suited to DL-based solutions. This chapter will introduce the problem of conﬁguration, describe some requirements of conﬁguration applications that make them candidates for DL-based solutions, show examples of these requirements in a conﬁguration example, and introduce the largest and longest-lived family of DL-based conﬁgurators.

12.1 Introduction

In order to solve a conﬁguration problem, a conﬁgurator (human or machine) must ﬁnd a set of components that ﬁt together to solve the problem speciﬁcation. Typi- cally, that means the answer will be a parts list that contains a set of components that work together and that the system comprising the components meets the spec- iﬁcation. This task can be relatively simple, such as choosing stereo components in order to create a home stereo system. The problem can also be extremely complex, such as choosing the thousands of components that must work together in order to build complicated telecommunications equipment such as cross-connect devices or switches. Oneimportantfactorthatmakesconﬁgurationchallengingisthatmakingachoice for one component typically generates constraints on other components as well. For example, a customer who chooses a receiver that only supports up to four speakers may not conveniently support a surround sound system with a subwoofer (since this would require more than four speakers)

Conﬁguration continues to have strong interest in the academic and commercial communities. It has been a prominent area in artiﬁcial intelligence at least since the R1/XCON [McDermott, 1982] work on conﬁguring computer systems. Since then, many conﬁguration systems have been built in domains including commu- nication networks, trucks, cars, operating systems, buildings, furniture layout, and even wine properties to match a meal description. Today, there are active mailing lists, workshops and conferences (such as the conﬁguration workshops at ECAI- 2002 [ECAI, 2002] IJCAI 2001 [Soininen et al., 2001], AAAI’99 [Faltings et al., 1999], and the Fall Symposium Workshop on Conﬁguration [Faltings and Freuder, 1996]), special issues of journals (such as IEEE Intelligent Systems [Faltings and Freuder, 1998] and Artiﬁcial Intelligence for Engineering Design, Analysis and Manufacturing [Darr et al., 1998]), and research groups at a number of universi- ties and companies. Approaches include constraints, expert systems, model-based reasoning, and case-based reasoning as well as Description Logics. Conﬁguration is an important and growing commercial concern. There are a number of companies dedicated to conﬁguration such as Trilogy, Calico, etc. Other companies in broader markets such as the enterprise integration software compa- nies, Baan and SAP, have a major emphasis in conﬁguration. Companies that sell complicated products, such as computers, are providing their own conﬁgurators (e.g., the Dell personal computer online conﬁgurators). There are spinoff compa- nies of general conﬁguration companies that are aiming at particular domain areas, such as PCOrder (a spinoff of Trilogy focusing on personal computer conﬁgura- tion). There are also some domain-oriented companies that include conﬁguration as a major component such as CarsDirect’s conﬁguration of United States consumer car orders. Although the commercial conﬁguration market may appear to be a recent event since it has been exploding recently, it does have at least a decade of history. Trilogy, for example, one of the earlier companies focusing primarily on con- ﬁguration, was founded in 1989. Forrester Research reports that the conﬁgura- tion market was valued at eight billion dollars in 1997 and it predicts that the market will grow to 327 billion in 2002. Conﬁguration is also seen as impor- tant by companies not originally classifying themselves as “conﬁguration compa- nies”. In a study of ﬁfty eCommerce executives from top ﬁrms in the business- to-business and business-to-consumer space, Forrester Research found that search and conﬁgurators were considered the two tools most critical for customer support [Koetzle et al., 2001]. The DL community has been addressing conﬁguration needs for over a decade as well. Owsnicki-Klewe [1988] presented a view of conﬁguration as a consistency maintenance task for Description Logics and AT&T independently began work in 1988 on its family of conﬁgurators for telecommunications equipment [Wright

et al., 1993; McGuinness et al., 1995; McGuinness and Wright, 1998b; 1998a]. Similarly Ford Motor Company has had a DL-based conﬁgurator [Rychtyckyj, 1996] in the ﬁeld for over 10 years. Others in the DL area have explored Description Logics for conﬁguration as well, e.g., [Buchheit et al., 1994c; Kessel et al., 1995].

12.2 Conﬁguration description and requirements

In this chapter, we will be considering large-scale conﬁguration problems. If one only has a small number of constraints to satisfy and a small number of possible component choices, then any somewhat reasonable solution will work. If however the ﬁnal product is complicated and there are thousands of choices and constraints, then there is more need for a well-suited solution. We will consider the generic conﬁguration problem where there is a complex artifact being assembled from components. Potentially the components have subcomponents, and thus the artifact may be modular or hierarchical in nature. Also, each of the components typically has anumberofproperties,suchaspowerrestrictions,connectionstoothercomponents, etc., and thus components may be tightly interconnected. If one looks at modern conﬁguration descriptions [Fleischanderl et al., 1998; Juengst and Heinrich, 1998], one can see only large, interconnected, tightly constrained, complex systems. The input description for the conﬁguration problems we will consider will be a speciﬁcation of a complex, probably highly interconnected system. The input should be able to be entered incrementally by a user as well as being able to be uploaded from sales programs. The input speciﬁcation may be:

r incomplete r ambiguous r incrementally evolving r granular to different levels of speciﬁcity r inconsistent r entered in any arbitrary order r interconnected r nested with complex structure.

The output for the system, in its simplest form, will be some kind of parts list. The parts list may be organized hierarchically so that there is a parts list of high level components (such as bays in switching systems or speaker sets in home theater systems) as well as a detailed parts list of the individual components. In this chapter, we will only address conﬁguration and not the related area of parts layout. The output of the system should be:

r correct r complete

r consistent (with respect to other parts, preferences, pre-existing components in the cus- tomer’s environment) r modiﬁable r understandable / explainable r capable of being queried r interconnected and interoperable with related data.

The conﬁgurator needs to accept the problem input along with any previously entered domain information concerning valid conﬁgurations. It must then check the constraints it has (calculating the constraints that are implicit in the input data from the input and background information) in order to start building a parts list. It may ﬁnd that a complete and correct parts list may not be built from the given input. In actuality, it is common for the problem speciﬁcation to be either overconstrained (i.e., contain a contradiction such as “I want a pair of speakers that is of the highest quality available yet I do not want to pay more than ﬁfty dollars for them”) or under- constrained (i.e., “I want to buy a high quality stereo system”). In the ﬁrst case, the conﬁgurator needs to identify the source of the conﬂicting information and deter- mine (probably along with user input) which conﬂicting constraint(s) to relax. In the second case, the conﬁgurator needs either to solicit more speciﬁc information from the user, or to generate a list of possible conﬁgurations, or both. If the conﬁgurator makes arbitrary choices for the user (e.g., it chooses some receiver for the stereo system yet there were many possible choices), then it needs to make it possible for the user to change the arbitrary choices and also to ﬁnd out which choices were arbitrary and which choices were mandated by constraints. Additionally it needs to let the user enter partial additional input that would further constrain the choices. The conﬁgurator also needs to accept information from multiple data sources. There will be a number of databases with which a conﬁgurator may need to interact. Typically, there will be databases of parts and prices, other databases of parts and availability, and possibly many other databases with user information or just information about different product families. It is likely that information (such as pricing and availability) will change frequently. Also, there will be information concerning what parts are compatible together and how the choice of one part constrains the choices of other parts. These might be considered the conﬁguration rules. Although these rules might not change on a frequent basis, modiﬁcations are typically necessary. The rules may come from multiple sources as well. They may need to be imported from many different source languages and they may need to be input by people who have no training in computer science, let alone knowledge representation systems. Finally, the system may be long-lived and thus require support and maintenance. It may be necessary to staff a help desk to help users of the system The customer

service representatives may know very little about any one individual product about which they are answering questions (because they are supporting a large number of products). The technical staff maintaining the individual conﬁgurator may not include people who originally built the system, and over time, it may not even include people who know much about the product (although they may be quite capable of researching the product if necessary). Also, the technical staff may need to generate new conﬁgurators for updated or similar products. We might summarize the requirements from the input, output, and core conﬁg- urator requirements starting from the requirements presented in one conﬁgurator family of applications [McGuinness and Wright, 1998b] and augmenting them slightly here. A solution methodology should have the following properties:

r object-oriented modeling r rule representation, organization, and triggering r active inference and knowledge completion r explanation, product training, and help desk support r ability to handle incrementally evolving speciﬁcations r extensible schemas r reasoning mechanisms that handle incomplete or ambiguous information r inconsistency detection, error handling, and retraction r modularity r maintainability.

This list of needs represents those in many complicated reasoning tasks. Although we could argue that this general architecture and approach is more broadly applica- ble, we will limit our discussion to conﬁguration applications. In the next set of sub- sections, we will describe each of these needs with respect to the task of conﬁguring astereosystem(basedontheconﬁguratordemobyAT&T[McGuinnessetal.,1995; 1998] and mention how the DL-based solution met the need. When useful or neces- sary, we will mention how the need was addressed in the larger Prose conﬁgurator family. In the stereo conﬁguration application, the goal was to require the user to enter a small number of constraints concerning the end system and generate a complete, correct, and consistent parts list. Although the system would accept a large set of constraints as input as well, the goal was to reduce the user’s task and thus require minimal input. The system used the user input along with its extensive do- main knowledge and parts information to determine if the user’s input speciﬁcation was consistent. It used the underlying theorem prover within the DL system to compute the deductive closure of the input and generated a more complete input description. User input was solicited on the system quality (high, medium, or low with associated price ranges) and the typical use (audio only home theater only

typically generated descriptions for 6–20 subcomponents which restrict properties such as price range, television diagonal, power rating, etc. A user might then in- spect any of the individual components possibly adding further requirements to it which may, in turn, cause further constraints to appear on other components of the system. Also, a user may ask the system to “complete” the conﬁguration task (even if the user speciﬁcation was incomplete), completely specifying each component so that a parts list is generated and an order may be completed. An on- line demonstration of the web conﬁgurator application is available at Stanford (http://www.ksl.stanford.edu/people/dlm/dls/stereo-demo/) and a number of examples are available in the extended online version of the IJCAI paper [McGuinness et al., 1995] available at: http://www.research.att.com/ sw/tools/classic/tm/ijcai-95-with-scenario.html. This application is convenient for illustrating our points since it is small and in a broadly understandable domain. It is potentially more interesting than some simple pedagogical examples since it was developed as an application that had representa- tion and reasoning requirements that were isomorphic to the needs observed in the Prose family [Wright et al., 1993; McGuinness and Wright, 1998b] of conﬁgura- tors. The examples in this paper can be seen in more detail in [McGuinness et al., 1995; 1998].

12.2.1 Object-oriented modeling

A system that is being conﬁgured may be viewed as a structured object composed of smaller objects. Even our simple example domain of stereo equipment presents a natural hierarchy of concept descriptions and instances that have a number of properties. We have a top level node like ElectricalThing and then have subclasses of that node such as HomeTheaterSystem and StereoOrVideoComponent. Fur- ther, subclasses of StereoOrVideoEquipment might include Receiver, Speaker, and Television. Any particular term may have properties associated with it. For example, a Television might have a property called diagonal (that must be ﬁlled with a positive integer), another called price (that must be ﬁlled with a monetary value), a repairHistory (that must be ﬁlled with one of the following values: {BAD, OK, GOOD}), a manufacturer (that must be ﬁlled with a company), and a height, width, and depth (all of which must be ﬁlled with a positive number). All of the properties might have cardinality requirements on them. For example, there must be at least one manufacturer (although possibly more than one manufacturer), there must be exactly one ﬁller for the diagonal role, etc. In the simple examples so far, we have seen a need for number (cardinality) restrictions, value restrictions (choosing the type of a ﬁller for a role), roles, and class hierarchies Further we should note in the description that the objects

determined to be a company. Companies themselves might have further proper- ties like headquarter locations, CEOs, etc. A user might subsequently want to choose speakers made by companies in the United States and televisions made by companies headquartered in Japan. It is argued more extensively elsewhere [McGuinness and Wright, 1998a] and in this book in Chapter 10 that Description Logics are convenient modeling tools for such objects. We can show a simple example of this diagrammatically where a HomeTheaterSystem inherits a price role with a value restriction of MonetaryUnit. We might also have a particular HomeTheaterSystem named MY-HTS that is the system we will be building through the example. It will also have a price role with some unknown value at the moment. We might also have a subclass of HomeTheaterSystem called HighQualSystem. In our simple example, this might be deﬁned simply as a home theater system that costs at least 6000 dollars. In a Description Logic system, once MY-HTS contains either a price that is over 6000, or contains a partial description such as “a minimum price of 8000 dollars” that restricts the price to be greater than 6000, then it can be recognized to be an instance of a HighQualSystem. This kind of automatic recognition and organization of terms based on their deﬁnitions is a convenience for organizing and maintaining partial descriptions and is arguably one reason that Description Logics are thought to be particularly useful for modeling and maintenance of applications that require object-oriented models.

12.2.2 Rule representation

A knowledge base that contains information about active deductions will contain some sort of rules. Typical large conﬁguration systems will contain many rules. Also, these rules may change frequently. It is reported that 40% of the rules in R1 changed yearly. Thus, support for modeling, organizing, and later, maintaining the rules will be important in large conﬁguration systems. A simple rule may take the form of “If something is an A, then it is a B”. For example, if something is a HighQualSystem, then its television is a HighQualTelevision (which has a minimum price and diagonal value), its speakers are HighQualSpeakers (which have minimum price restrictions), etc. In fact, in our stereo demo, there are dozens of rules that ﬁre once a system is determined to be a HighQualSystem. If the minimum price restriction were ever removed from the speciﬁcation requirement, we would want the results of those rules retracted automatically (unless the same results could be deduced in other ways as well). A DL-based system can support modeling of rules described above in a hier- archical fashion. Rules can be associated at what ever level of the hierarchy is appropriate Thus we might associate minimum price and diagonal for televisions

at the level of a HighQualSystem and we might associate repair-history restrictions with another concept such as HighReliabilitySystem. If we just wanted to have this kind of simple rule encoding, we would not need to use a separate mechanism. If one has an encoding scheme that includes negation and disjunction (or some other way of encoding an “if–then” rule), as do most of the modern Description Logic languages, then one does not need to introduce a separate rule notion. For example, one might encode a simple if–then relationship such as (or (not HighReliabil- itySystem) GoodRepairHistory). This states that either something is not a high reliability system or it has a good repair history, which is typically viewed as equiv- alent to “if something is a high reliability system, then it has a good repair history”. The Description Logic that this example was encoded in (Classic [Borgida et al., 1989; Brachman et al., 1991; Patel-Schneider et al., 1991; McGuinness and Patel-Schneider, 1998]) had a rather limited set of constructors and also had the simple rules introduced above and also more sophisticated rules such as those which compute role values based on context. In some conﬁguration applications of this Description Logic, the more sophisticated rules in combination with other constructors have encoded expressive rule-based reasoning, and in fact many of the rules in those conﬁguration system required Classic’s more sophisticated rule representation system. The examples we have seen in this chapter only use a simple form of if–then rules. For a more detailed discussion of how powerful these rules can be in practice, see [Borgida et al., 1996]. Description logics are not required of course in order to capture rule represen- tation and reasoning; this example simply shows that they can be a convenient technique for capturing rules and reasoning with them.

12.2.3 Active inference

Description logics deduce logical consequences of information and are thus said to provide active inference. In fact, one of the typical patterns of inference observed in many DL-based conﬁguration systems includes:

r asserting new information about an existing term r recognizing that the updated term is an instance of a class r ﬁring a rule on the term that is associated with the class r propagating information from the updated term to related terms.

For example, let’s consider MY-HTS again. Let it have a hasTelevision slot ﬁlled with a particular television TV-11. Once it is asserted that the user is willing to pay more than 8000 dollars for this system, it is recognized to be an instance of the HighQualSystem. The rules associated with that concept ﬁre and now it becomes an instance of something that has a television diagonal minimum of 50 inches

(or possibly a high deﬁnition television with a smaller diagonal) and a television price of a minimum of 1000 dollars. These restrictions are propagated onto TV-11. This kind of deduction chain comprises over 50% of the inferences that are done in the stereo conﬁgurator example. In this manner, users only need to specify a small number of restrictions on their system and they can have a large number of deductions performed for them. It should be noted that this particular example conﬁgurator was built on a Descrip- tion Logic that did not contain default reasoning. Some Description Logics have been expanded to include default reasoning (i.e., if it is not known to be otherwise, use the default rule) [Padgham and Zhang, 1993; Baader and Hollunder, 1995a; Quantz and Royer, 1992]. For example, if a manufacturer has not been speciﬁed for a television, use Sony as the manufacturer. If the underlying formalism had had a default representation, this would have been used. As the demonstration system was encoded, the stereo conﬁgurator used two sets of concepts on which to hang rules: a concept for all provably correct rules (such as power compatibility) and another concept for the default rules, called a “guidance” concept (for more subjective rules such as minimum prices). The deployed conﬁgu- rators on which this system was based actually used defaults as completion – at a particular point in the speciﬁcation input process, if information is unknown, then “complete” it using the “default” or subjective rules [McGuinness and Wright, 1998b]. This provided one very simple method of implementing a kind of “default” as completion that can be viewed as one of the simplest forms of default reasoning.

12.2.4 Explanation

Customer help desk staff need to be able to help users understand potentially every- thing about a conﬁguration speciﬁcation and the ﬁnal parts list. In fact, the Prose family of conﬁgurators faced extinction had it not been able to respond with a full explanation capability. It was evident that consumers needed to be able to ﬁnd out why some particular part was in their ﬁnal system, why it had the particular value restrictions it did, what the possible alternatives were, and from what portion of the speciﬁcation this information had been derived. In this simple example, a cus- tomer might want to ﬁnd out why the television in the ﬁnal system costs over 1000 dollars or why it has a particular minimum diagonal requirement. The explanation would be that a high quality system was requested and high quality systems in- clude a suggested minimum diagonal size and a minimum price on their television components. The demonstration system allows customers to point to particular compo- nents and ask questions about everything that has been deduced about them. It also anticipates the most common explanation questions that users ask and

provides pulldown menus containing explanation question that were dynamically generated based on the item a user was pointing to and that a user could just click on to ask quickly. An extensive explanation foundation was designed for the underlying DL-based system in order to support that [McGuinness, 1996; McGuinnessandBorgida,1995].Theexplanationsystemprovidesaproof-theoretic foundation for explaining any deduction in terms of proof rules and arguments. It also provides an automatic followup capability that generates the questions that would lead to this inference being deducible. The followup question generation was found to be needed since user studies showed that users wanted fairly simple expla- nations along with the capability to ask followup questions. Further studies found that users appreciated help in generating syntactically correct followup questions that made sense given the previous question that was asked. The followup questions were automatically generated from the model-theoretic form of the explanation. The basic explanation structure was originally done for a normalize–compare DL-based system but has since been used as the foundation for a tableau-based De- scription Logic [Borgida et al., 1999] and also a model-elimination theorem prover in an implementation of the ATP and JTP theorem proving systems at Stanford University. Explanation in general is one of the strengths of Description Logics as opposed to some of the other conﬁguration approaches. It may be much more difﬁcult to explain a line of reasoning in a typical constraint-based approach than it is to ﬁlter and prune an inference-rule-based theorem prover such as a DL prover. Filtering object presentations and explanations in Description Logic has also been addressed in [McGuinness, 1996; Borgida and McGuinness, 1996; Baader et al., 1999a]. Also, it has been argued elsewhere [McGuinness and Patel-Schneider, 1998; Brachman et al., 1999] that explanation is a requirement for many kinds of applications, but is particularly important for conﬁguration systems [McGuinness and Wright, 1998a]. Recent work has been done in constraint-based approaches that starts to address explanation in constraint-based conﬁgurators. While progress is being made, the more interesting constraint-based explanation systems [Freuder et al., 2001] utilize extensive domain speciﬁc information and are not generic solutions to the problem of understanding explanations.

12.2.5 Evolving speciﬁcations

In many common conﬁguration scenarios, a user begins with an incomplete set of speciﬁcations for an end product. Conﬁguration applications built to support users should take input of the known speciﬁcations (in an order that is convenient for the user and not just an order convenient for the program), and then solicit remaining required input

A conﬁgurator system should allow mixed initiative input, where the user may input the speciﬁcations the user is aware of at a particular time and the system should request input that it needs to meet a task. Description Logics can allow users to input descriptions of end products or individual components at any time. For example, in the home theater system, a user could specify information about the entire system – such as a requirement for the entire system to be high quality – and also could specify information about any of the particular components that was known at a particular time. The user might, for example, prefer to buy a particular model television or might want to set a diagonal size and a number of other constraints on the television, but might not know anything at the moment about the restrictions on the DVD player. A user interface, such as the one depicted in the stereo example, allowed a user to choose components from dropdown menus. The dropdown menus were generated on the ﬂy in order to take into account all of the information that the system currently had about a component. This was used as a query to the database of all components that met that speciﬁcation. Thus, the user was kept from choosing many components that would be incompatible with the system that was conﬁgured to date. The user could also browse the current conﬁguration and delete any requirements that were stated. (The user was not allowed to delete requirements that were in- ferred, but was allowed to ask how a particular requirement was deduced, thereby discovering the source of that requirement.) Once a requirement was deleted, then new dropdown menus were generated to include components that met the current set of speciﬁcations instead of the previous set. This architecture provides a great deal of ﬂexibility for incrementally evolving (sometimes non-monotonically evolving) speciﬁcations. It worked well to provide users with menus of choices that were recalculated as needed, with updated com- ponent lists that met the current speciﬁcations that were stated or implied about any component. For example, if a user speciﬁed a high quality stereo system and then decided to choose an ampliﬁer for the system, the conﬁgurator would only present options for ampliﬁers that had been determined to be of high quality. Description Logics are not the only modeling scheme that supports evolving speciﬁcations, but this section attempts to point out that they can be used rather easily to support evolving conﬁguration speciﬁcations.

12.2.6 Extensible schemas

Many conﬁguration applications ﬁnd that information about components is contin- ually updated. It is not always the case that only the simple data about components is updated but sometimes properties of the components change or new properties

are discovered after an application has been encoded. Thus, it becomes impor- tant to work with a schema or a description of a component that can be updated. For example, in our home theater application, when we began development, DVD players were not in the consumer market. It later became common for home theater systems to include DVD players, and thus our schema needed to be extended with the new class—DVDPlayer—as well as with roles that were appropriate for DVD players. This need for updatable and conﬁgurable schemas is sometimes a requirement for design. For example, in AT&T evaluation of software, one criterion is extensible schemas. Our experience in the deployed Prose and Questar conﬁgurator family was that products were extended often in practice.

12.2.7 Reasoning for incomplete information

Many conﬁguration speciﬁcations are almost by necessity incomplete when input initially. In large systems, it may be common for one person who may be an expert in one area to input speciﬁcations for that area while another person who is an expert in another area may update the speciﬁcation later. For example, in a two- person household, one person may be much more literate in audio quality and thus may input the requirements for speakers, while the others may have more interest and knowledge in video displays and thus may input speciﬁcations for the television (along with its input and output requirements). It may be important to allow speciﬁcation to be done across multiple sessions as well. One would not want a conﬁgurator that could not make deductions until all of the input requirements had been presented. For example, in the stereo system, one would want a conﬁgurator that could infer the implications of the speaker restrictions on say minimum power requirements for the ampliﬁer, even though the television speciﬁcations had not been input yet. Description Logics have been demonstrated to be useful at determining logical consequences of information even when that information is incomplete. They can also be used to determine information that is still required. For example, they can determine that two speakers need to be input as parts in the parts list before the conﬁguration can be considered complete. Thus, it is not enough to say that two high quality main speakers are required but the parts list actually needs to have the actual speakers chosen before the job is considered complete. In the home theater application, there was a one-pane display dedicated to show- ing which ﬁnal component choices still remained before a conﬁguration could be considered completed. The display could be used to view the current parts already implied and/or chosen along with the other components yet to be chosen. The other components could be clicked on to obtain the current description of the component

so that a user could view what had been derived to date about that component. The application allowed a user to save a partial speciﬁcation of a conﬁguration for further requirements to be input at another point. The application also allowed a user to “complete” the conﬁguration at any point that would force the system to make consistent decisions for remaining underconstrained components. The user could also inspect individual component choices and click on them and see a pull- down menu list of alternative choices that the system could have made. The user could also click on the component and view a description of the constraints that the application had determined must hold for that component. The description of the component was what was used to query the knowledge base about compo- nents that would ﬁt the characteristics. The description could also be passed along to another user (or another application) so that it could see what constraints had been deduced so far and then have that other user (or application) either add new constraints or make the ultimate product choice, thereby facilitating collaborative conﬁguration.

12.2.8 Inconsistency detection

Conﬁguration applications should minimize the chances for users to generate in- consistent speciﬁcations. The stereo conﬁgurator, for example, uses the information that can be deduced about any particular component in order to form a query to the database about possible components. This greatly limits the chances that a user may choose a component in their system that will cause an inconsistent speciﬁcation to result. The deployed application did not take a greater step, however, before choos- ing to put a component on a pulldown list. It did not make the hypothetical choice of the component for the user and then check to see if the remaining components that were still unspeciﬁed could be completed with a component in the database. (Of course, this would be an exponential search with the remaining components yet to be speciﬁed.) Thus the deployed example could still allow a user to generate an inconsistent speciﬁcation – the application just made it more difﬁcult for this to happen. The back end reasoning system was required to determine when an incremental speciﬁcation became inconsistent. Sometimes users of other deployed conﬁgurators generate a large set of con- straints and want to input them into other (connected) conﬁguration applications. Thus one additional requirement on a user friendly conﬁgurator (that is expected to interact with other conﬁguration applications) is for the reasoner to take input constraints and determine if they are inconsistent. The Prose conﬁgurator family, for example, supported batch input of requirements with consistency checking. Reasoners may choose different methods of handling inconsistencies. A require- ment for a conﬁguration system is that the underlying reasoner must be able to

identify the inconsistency and notify the user. A helpful reasoner will also support users by allowing them to ask how the inconsistency was deduced. The reasoner could also give users the option to “roll back” the speciﬁcation to the last consis- tent state. For example, the Classic knowledge representation system required its information to be consistent, and thus once an inconsistency was detected, it dis- allowed the last statement that generated the inconsistency (maintaining a separate error state for debugging support) and then rolled back to the last consistent state. This was common for early DL-based systems. Today, however, Description Logics do not necessarily require consistent axioms to function. They may allow a set of inconsistent axioms to be input and then conﬁgurators can be built that utilize the Description Logic to identify if a description is satisﬁable. This model of allowing inconsistent input with a user-identiﬁed checkpoint may be a model that supports collaboration and web-oriented development most naturally.

12.2.9 Modularity

In large systems, it is important to allow multiple people to work on speciﬁcations in what appears to be a simultaneous environment. In Prose for example, care was taken to design a set of classes and roles that a number of developers could use. Multiple users were then allowed to work on speciﬁcations of different portions of the conﬁguration information simultaneously, with previously deﬁned upper level classes and roles for their use in specifying more speciﬁc classes. When the users were ﬁnished with their particular component descriptions, loads were done to see if the different portions interacted. This model of individual users being in charge of speciﬁc portions of the ontology while possibly one chief ontologist is in charge of the upper level ontology is not uncommon. Cycorp, for example, publishes its upper level ontology which is maintained by a core Cycorp group while many other people develop more specialized mid-level ontologies. VerticalNet also has a number of ontologies with many different authors of speciﬁc ontologies that use an upper level ontology that is maintained by a core ontology team. Description Logics can be used to support such modeling, with Prose being an example of one such development. Another notion of modularity support can be considered with environmen- tal support features. Some systems such as OntoBuilder [Das et al., 2001] at VerticalNet have been built to support multiple users working on the same portion of an ontology in a more integrated manner. VerticalNet’s system allows users to be notiﬁed if someone is modifying a portion of the ontology that they are using. While OntoBuilder does not have a DL back end, its input language is quite similar to OIL [Fensel et al., 2001] and thus it is not a hard task to imagine that an OntoBuilder like system could be integrated with today’s DL systems

12.2.10 Maintainability

Once systems are used for a long time period or are used enough so that they require support from someone other than their original author, maintainability becomes an issue. We have used examples from the stereo conﬁgurator for all of the other sections, but in this section we will draw from our experience with the Prose– Questar family of conﬁgurators. The stereo conﬁgurator has been up on the web for some years, yet it has not had many maintenance requirements because it is a demonstration system that is not updated when new stereo information becomes available. However, deployed conﬁgurators typically have help desk support and require data (and sometimes schema) updates. There are at least three components of maintenance that require some thought when planning a conﬁgurator:

r product data updates r product speciﬁcation updates r help desk support.

The ﬁrst is the simplest. Typically, product data requires updates over time. Sim- ple things like prices and availability need updating and sometimes small updates are made with revisions. Typically, this kind of information is not hard to update— someone who does not know much about the encoding can typically ﬁnd a way to do things such as updating price ﬁelds in many applications, whether they are DL-based or not. Description Logics support this requirement since they are aimed at working with incomplete information (e.g., Subsection 12.2.7), and thus updates from incomplete to more complete information are natural for DL-based systems to handle. Similarly, an object-oriented modeling scheme may make updates simpler, but this area alone would not be enough to drive a potential user to a DL-based approach. The second issue of updates to product speciﬁcation might be viewed by a database designer as a schema update. This kind of information is typically more challenging to update in applications since it requires product speciﬁcation descrip- tions and not just simple, data changes. It could be simple, requiring say a change to the range of a ﬁeld; for example, possibly an age range may move from 18–65 to 18–70. Similarly, a business that used to accept only US currency may now accept other currencies, such as euros, requiring updates to the price ﬁeld value restriction. More complicated product speciﬁcation updates may be done when new components become available (thus requiring someone to model the new components and their features). These types of speciﬁcation updates are facilitated in Description Logics by the kinds of features that we noted in Subsections 12.2.6, 12 2 5 12 2 1 and 12 2 9

The third issue of help desk support has been noted as a strength of DL-based systems. One of the goals with the Prose conﬁgurator systems was to allow the help desk personnel to appear to perform at a level above the amount of training they had on individual products. The enabling infrastructure toolset was to provide information to the help desk staff at the time they needed it in real time (instead of requiring them to have been previously trained on products so that they could answer questions from knowledge that they had learned instead of from knowledge that they could look up on demand). The tools were to allow them to explain any of the deductions that the system made when customers called in asking why something was (or was not) in their conﬁguration and also allowed them to answer questions about why conﬁgurations were (or were not) valid. This was most facilitated by the functionality described in Subsection 12.2.4 but also by others such as Subsection 12.2.8. Similarly, they could answer hypothetical questions such as “what would happen if I chose com- ponent X instead of component Y in my conﬁguration?” The goal was to meet individual customer needs without requiring engineering support to answer such questions. Our claim is that it is a combination of the strengths of Description Logics as discussed in the previous sections that helps support maintainability of the applications and in fact, helps support maintainability by people who have not taken classes in Description Logics or knowledge representation.

12.3 The Prose and Questar family of conﬁgurators

The longest-lived and most proliﬁc family of DL-based conﬁgurators has been the Prose and Questar product line [Wright et al., 1993; McGuinness and Wright, 1998b]. AT&T began development on conﬁguration problems in 1988 in response to business requests for help in the streamlining of the Engineer, Furnish, and Install process. Thegoalintheprocessistosolicitaspeciﬁcationrequestfromthecustomer through the sales process, and then engineer a solution that can be “furnished” and of course manufactured and delivered to the customer in a timely and cost effective manner. The initial goals of the project were to decrease the time from speciﬁcation to installation and to minimize the impact of contradictions in the speciﬁcations and mistakes in the engineering. The initial conﬁgurator was built for a ﬁber optic transmission system (the FT Series G) although the initial deployment was for a digital cross-connect system (the DACS IV-2000). The initial conﬁgurator was successful enough that a family of conﬁgurators was built around it. The history of the project proceeded from a research involve- ment to one of development. AT&T’s research division collaborated with develop- ers in order to build the initial system. Researchers helped generate and critique the initial conceptual models and programming effort Developers generated the

initial system but with interactive assistance from research. As the product evolved, project needs emerged for developer independence and an environment was produced that allowed domain knowledgeable people to input conﬁguration rules in a language that was comfortable to them. Developers had the lead responsibility; in the initial deployment they had the assistance of research but in the second through seventeenth system they required little assistance from research for either genera- tion or maintenance of individual conﬁgurators. As the development environment evolved, the developers saw much less of the DL back end – essentially the DL back end veriﬁed input and deduced conclusions and was otherwise hidden behind the interface of the system. There are a few points worth noting about this family of applications. First, the conﬁgurator family has shown longevity with some conﬁgurators deployed a decade after work began. Second, the majority of the generation and maintenance of the conﬁgurators was done by people who knew very little about Description Logics (thus showing empirical evidence that applications do not require PhDs in Description Logics to build and maintain them). An evolution interface was devel- oped by domain literate developers aimed at users who knew the products but did not know Description Logics or sometimes computer science at all. This interface allowed users both to maintain conﬁgurators and also to generate new conﬁgurators in the same product family. Third, there is a consensus that the DL-based approach both facilitates conceptual modeling (e.g., [McGuinness and Wright, 1998b]), and also makes maintenance much easier. Ford Motor Company has also stated similar ﬁndings with its long-lived DL-based conﬁgurator applications.

12.4 Summary

We have introduced the problem of conﬁguration, describing brieﬂy the nature of the problem and why many communities consider it important. We have described properties inherent in the problem that make it an area for which one might consider DL-based approaches. We have provided examples of all of properties in the setting of a stereo conﬁgurator, mentioning how a DL-based approach was used to solve the problem. We made parallel connections to the much larger conﬁgurators used for telecommunications equipment that also included the same issues and had DL-based solutions. We have also introduced the largest family of DL-based conﬁgurators – the Prose–Questar family of systems (noting also that at least one other commercial conﬁgurator at Ford Motor Company also has a similar life-span and a similar Description Logic-based approach). We observe that the Prose–Questar conﬁg- urator family has been in continuous use for over a decade and has conﬁgured billions of dollars of equipment We ﬁnally note that the commercial conﬁguration

examples with long histories state that the DL approach has alleviated the problems of conceptual modeling and conﬁgurator maintenance. Additionally, we speculate that this general architecture that meets the list of conﬁguration needs might also be used in problem areas with similar needs.

Acknowledgements

While of course all errors in the chapter are the responsibility of the author, the chapter has been enhanced by contributions from a number of people. Much of the discussion has been in the setting of either Prose–Questar or Classic work that has been done in conjunction with Jon Wright, Lori Alperin Resnick, Peter Patel-Schneider, Ron Brachman, Alex Borgida, Charles Isbell, Elia Weixelbaum, Gregg Vesonder, Harry Moore, Pat Saleh, Charlie Foster, Chris Welty, Matt Parker, and a number of other important contributors. Also, Nestor Rychtyckyj provided many valuable comments on a previous version of this paper.

13

Medical Informatics

ALAN RECTOR

Abstract

Description Logics and related formalisms are being applied in at least ﬁve applications in medical informatics – terminology, intelligent user interfaces, de- cision support and semantic indexing, language technology, and systems integra- tion. Important issues include size, complexity, connectivity, and the wide range of granularity required – medical terminologies require on the order of 250,000 concepts, some involving a dozen or more conjuncts with deep nesting; the na- ture of anatomy and physiology is that everything connects to everything else; and notions to be represented range from psychology to molecular biology. Technical issues for expressivity have focused on problems of part–whole relations and the need to provide “frame-like” functionality – i.e., the ability to determine efﬁciently what can sensibly be said about any particular concept and means of handling at least limited cases of defaults with exceptions. There are also signiﬁcant problems with “semantic normalization” and “clinical pragmatics” because understanding medical notions often depends on implicit knowledge and some notions defy easy logical formulation. The two best known efforts – OpenGalen and Snomed-rt – both use idiosyncratic Description Logics with generally limited expressivity but specialized extensions to cope with issues around part–whole and other transitive relations. There is also a conﬂict between the needs for re-use and the requirement for easy understandability by domain expert authors. OpenGalen has coped with this conﬂict by introducing a layered architecture with a high level “Intermediate Representation” which insulates authors from the details of the Description Logic, which is treated as an “assembly language” rather than the primary medium for expressing the ontology.

13.1 Background and history

13.1.1 Knowledge representation in medical applications

Description Logics and related frame-based and conceptual graph formalisms are being applied in at least ﬁve applications in medical informatics:

r Terminology development and, more broadly, the representation of information in health records. r Intelligent user interfaces. r Decision support and semantic indexing. r Semantics-oriented natural language processing. r Semantic integration of information systems.

The seminal early work in the use of Description Logics in medical applica- tions focused on the dilemma between expressiveness and tractability. Doyle and Patil [1991] attempted to apply Nikl to medical vocabulary and came to the ﬁrm conclusion that the Nikl TBox language was too restrictive to be useful for this pur- pose. More explicitly they despaired of users accepting the restrictions of minimally expressive TBox languages and predicted that users would ﬁnd “work-arounds” which defeated the logical rigor which was their raison d’ˆetre. A ﬁrst attempt at a more appropriate representation was made by Jang and Patil [1989]. However, as providing a standard controlled medical vocabulary came to be seen as one of the central issues of medical informatics, some researchers saw “compositional systems” as the only plausible route forward. The perceived urgency of the task motivated “pragmatic” approaches. Masarie et al. [1991] used a large frame-based AI environment to produce an “interlingua” linking three of the then current terminologies in one of the exploratory projects to what became the Uniﬁed Medical Language System [Evans, 1987]. Although the US National Library of Medicine chose to use lexical methods to cross map existing terminologies rather than to develop Masarie’s approach to a log- ical interlingua, the project gave rise indirectly to the CANON group who became strong advocates of formal representations in medical terminologies [Cimino, 1994; Evans et al., 1994]. A special issue of the American Journal of Medical Informatics (volume 1, issue 3) summarised the material from its seminal workshop. The CANON group brought together several other strands of then current work:

r The Medical Entities Dictionary developed by Cimino et al. [1989] as a large semantic network. r TherelatedGalen[Rectoretal.,1993;RectorandNowlan,1994]andPen&Pad[Nowlan et al., 1991a; 1991b; Nowlan and Rector, 1991] programs from Europe. r A series of projects on the use of Sowa’s conceptual graphs for representing medical vocabularies, the best known of which is the one by Campbell et al. [1994] but the series

In addition, the group interacted with more linguistic work by Friedman et al. [1994] and Sager et al. [1994] which, along with Tuttle [1994], served as a contrast and a reality check. There have been two large scale outcomes of this work:

r The Snomed-Reference Terminology (Snomed-rt) and Snomed-Clinical Terms (Snomed-ct) projects under the College of American Pathologists,1 which seek to pro- duce a terminology all of whose concepts are represented in a subset of Krss and formally classiﬁed, and which were released at the end of 2000 [Spackman et al., 1997]. A further cooperation with the UK Clinical Terms project is to produce an international version to be released in 2002.2 r OpenGalen, which seeks to produce a reference ontology in a specialized Description Logic for use in developing and managing other terminologies and indexing knowledge required for decision support, user interfaces and other knowledge management tasks.3

In addition there have been a number of projects on language processing in medicine which have included signiﬁcant work on formal knowledge rep- resentation, particularly the work by Hahn using Loom [Hahn et al., 1999a; 1999c], which has produced a range of large scale results in both language en- gineering and ontologies proper, and by Zweigenbaum using a specially restricted frame representation in a similar way [Zweigenbaum et al., 1995]. Another impor- tant task is the indexing and retrieval of medical literature, which has been addressed by McGuinness [1999]. Applications of ontologies within medicine, not based on Description Logics, include the work by Musen [1998] on re-usable problem solving methods and ontology driven knowledge acquisition in the Prot´eg´e project which, at least so far, has speciﬁcally not used a Description Logic or other formal basis for its ontology, but rather based its ontologies around the OKBC and DAML standards. As these standards are converging with Description Logics in OIL and DAML+OIL [Fensel et al., 2001; Horrocks and Patel-Schneider, 2001], convergence with Prot´eg´e is under active discussion. Stefannelli and Schreiber likewise have produced a body of work based around adaptations of the KADS architecture using ontologies as the basis for intelligent systems and agent architectures [Schreiber et al., 1993; Vanheijst et al., 1995; Falasconi et al., 1997]. Another major effort on knowledge representation in medicine is the Digital Anatomist project [Rosse et al., 1998; Agoncillo et al., 1999; Mejino and Rosse, 1999], which currently does not use a Description Logic but which represents a benchmark for a comprehensive, carefully curated and validated knowledge base

1 http://www.snomed.org/ 2

based on carefully analyzed ontological commitments and distinctions manifest in a meticulously deﬁned hierarchy of high level concepts such as “organ”, “tissue”, etc. It poses a challenge to any system aspiring to a comprehensive representation of medical knowledge.

13.1.2 The medical environment

Behind most of these applications is the aspiration to re-use clinical data – either to integrate systems, to link patient records to decision support and knowledge management, or to re-use information collected in the course of patient care for management, remuneration, quality assurance or research. There has been a widespread move to greater integration and to “Electronic Pa- tient Records” (EPRs), also known variously as “Computer based Patient Records” (CPRs) or (CBPRs). The goal behind these moves is threefold:

r To improve patient care through providing better information on current patients, warn- ings, and decision support to healthcare professionals – e.g., to be able to identify patients’ knownproblemsandtreatments,warnofpotentialdruginteractionsandcontraindications, or suggest management based on established guidelines. r To capture improved information for planning and management within healthcare insti- tutions by re-using information collected at the point of care for all secondary functions – e.g., to re-use diagnosis and treatment information collected during patient care for sta- tistical reporting, quality assurance, and remuneration. r To integrate the disparate information systems typical of most healthcare institutions.

Major reports justifying electronic patient records have been issued, amongst others, the Institute of Medicine [Dick and Steen, 1991], the Computer based Patient Record Institute (CPRI), and the UK National Health Service [NHS National Health Service Executive, 1998]. This pressure is increasing with moves to greater clinical accountability and concern with clinical errors [Kohn et al., 2000]. That every patient should have an electronic medical record is now government policy in a number of western countries, including the UK and US. Despite the widespread use of management, billing, and laboratory systems in medicine, the vast majority of the information required for such medical records currently exists only as unstructured narrative text. Capturing more of this infor- mation in structured form is a central task of medical informatics. The absence of a standard “controlled vocabulary” or “coding system” is seen as a major barrier to this task [Sittig, 1994] while its presence is a key to its success [Rossi Mori and Consorti, 1999]. Hence several countries have mandated, or will soon mandate, standard terminologies for use in medical records. However mostexistingterminologiesor“codingsystems”aremono-hierarchical

Classiﬁcation of Diseases—ICD) or bibliographic retrieval (the Medical Subject Headings – MeSH). They are much too coarse grained for recording care of in- dividual patients. Attempts to extend them to make them ﬁner grained have run into combinatorial explosions with some systems now running to over 250,000 “terms” which are beyond manual maintenance. Their structure is largely implicit, and writing software to use them is therefore problematic. An alternative faceted system, Snomed-International, has existed for some time, but has no strong seman- tics deﬁning the relationships amongst the facets and has always been considered difﬁcult to use outside its origin in Pathology – both because of its unfamiliar struc- ture and an organization which reﬂects its origins in pathology and often does not cater for the needs of other medical specialities. The US National Library of Medicine has mounted a major program to tame this chaos in its Uniﬁed Medical Language System (UMLS) which cross maps, insofar as possible, all of the general and special purpose vocabularies [Lindberg et al., 1993]. It has developed into a massive (15 Gb) cross reference and cataloging sys- tem.4 However, although cross referenced, the Uniﬁed Medical Language System is fundamentally limited by the nature of the underlying systems which it cross maps. It itself provides only a minimal amount of additional semantic information – less than 200 categories in a loose semantic network. Hence the hope by various researchers that DL-based ontologies can provide a better solution for at least some of the problems of terminology, decision support, language processing and integration.

13.2 Example applications

13.2.1 Description Logics in terminology development and “coding”

13.2.1.1 Snomed-rt : tightly coupled development and pre-coordination

Snomed-rt is a cooperative enterprise between the College of American Pathol- ogists and Kaiser Permanente, a large health maintenance organization. It has re-represented in a subset of Krss the information in the Snomed-International. In a ﬁrst approximation, the Snomed facets for anatomy, morphology, function, etc. have been turned into roles, hasTopography, hasMorphology, etc. [Campbell et al., 1998]. The initial mechanical translation has then been re-modeled in place by domain experts using a set of tools with a highly developed change management mechanism [Campbell, 1998]. The development methodology has placed a high emphasis on achieving repeatability of domain experts’ results, and made exten- sive use of lexical tools to suggest additional relationships which are implied by the

4 h // l k l ih /

rubrics but may not be explicitly present in the faceted representation; for example the term “retinal vasculitis” was correctly related to “eye” but not to “vasculi- tis” (inﬂammation of the blood vessels) in early versions of Snomed-International [Campbell et al., 1996] The ﬁrst released version consists of a pre-enumerated set of 180,000 or more disease and procedure codes, each deﬁned in an ontology represented in Krss and classiﬁed accordingly into an acyclic directed graph. The intention appears to be a standard pre-coordinated (i.e., pre-deﬁned) set of concepts and associated terms to be presented and used in a form analogous that of traditional hierarchical coding schemes. Recently a collaboration has been formed between Snomed-rt and the UK Clinical Terms (Read Codes) project to produce a combined product which is aimed at being a standard English controlled vocabulary for medicine. Details have not yet been announced, but it is assumed that the form will be closely related to that of Snomed-rt. The ontology used is relatively shallow, including under ten roles in its pre- release version, and avoiding embedded expressions wherever possible. However, thestandardsemanticsofKrsshasbeenenhancedbytheinclusionofright-identities to cater for part–whole relations (see Subsection 13.3.2). Snomed-rt itself includes no tools or transformations for data entry or for other applications involving dynamic post-coordination. However, a range of tools based on Snomed-rt, including the authoring suite, is available from the company that supplies the development tools (Apelon5), which are descended in part from K-Rep, a DL-style KR system used in many of the early experiments which led up to the project [Mays et al., 1991a; 1996].

13.2.1.2 Galen : loosely coupled development and post-coordination

Galen is the result of a series of European Commission funded projects and its ontologies and speciﬁcations as well as some of the tools are available in open source form from http://www.opengalen.org/. The Galen tools are designed for loosely coupled development, and the on- tology is aimed primarily at post-coordinated applications, such as intelligent user interfaces, and tools to empower users to adapt core terminologies to their speciﬁc needs. It is based around the idea of a dynamic “terminology server” rather than an enumerated table of pre-coordinated terms [Nowlan et al., 1994; Rectoretal.,1995a],althoughthereisalimitedsetofcommonconceptspre-deﬁned. An important feature of Galen is the clean separation of functions within the server architecture:

5 h // l /

r logical representation in the Description Logic; r language generation and text recognition; r mapping to and from existing coding systems; r indexing of non-terminological information; r additional calculations such as unit and coordinate transformations.

Galen’s ontology was created de novo but with close reference to the standard classiﬁcations, particularly the International Classiﬁcation of Diseases. It uses the Grail Description Logic [Rector et al., 1997] whose core includes the subset of operations of the Krss used by Snomed-rt, including transitive roles, with the addition of inverse roles and role subsumption. (See Section 13.3.2.2 for a further discussion of transitive roles and related issues.) In addition Grail provides a construct “sanctioning”, analogous to slot deﬁnitions in frame systems or function signatures in object-oriented systems, which supports answering queries of the form “what can be said about this?”. Grail is implemented using a graph comparison algorithm which, although known to be incomplete, has still proved to be extremely useful in practice. Galen’s most distinctive feature is the use in authoring tools for domain experts of a much simpliﬁed “intermediate representation” which is then translated into the Description Logic, which is relegated to the status of an “assembly language” (see Subsection 13.5.1 below). The Galen project has also devoted much effort to mapping to existing coding systems – a more complex task than is at ﬁrst apparent because of the idiosyncratic construction of the target schemes. Each code in such schemes is mapped to the disjunction of one or more Galen concepts. A Galen concept is taken as being mapped to the most speciﬁc code mapped to a subsuming concept, and conversely, a code is mapped to all those Galen concepts subsumed by its mapping except those subsumed by a more speciﬁc mapping. This mechanism deals with almost all of the complex sets of exclusions and inclusions in the International Classiﬁcation of Diseases – e.g., “Hypertension excluding hypertension in pregnancy” is coped with automatically simply by mapping to the general concept “Hypertension”, because there is a mapping to a speciﬁc concept “Hypertension in pregnancy” which will cause it, and its descendants, to be excluded automatically. In the very few cases where conﬂicts occur they are resolved by separate exception-handling tables. A similar mechanism provides a surrogate for inheritance with exceptions as a means of indexing information ranging from triggers for decision support rules to data entry forms and user interface speciﬁcations. Any information may be labeled and attached to the ontology, and the server provides operations to retrieve the set of all the values “inherited”. The Galen server makes no attempt to reduce the set to a single value; if required this is a matter for the client application

13.2.2 Description Logics and language processing

13.2.2.1 Language analysis and information extraction

Most medical information originates and is stored as natural language text. Medical texts present classic “sublanguages” with peculiarities of vocabulary and syntax. Many utterances are telegraphic or highly elliptical, and cannot be easily parsed without semantic knowledge. These features seem natural to combine with lex- icalized grammars in which most or all syntactic information is stored with the lexical item rather than in a separate grammar, e.g., Tree-Adjoining Grammars (TAG) [Joshi, 1994], Lexical-Functional Grammar, and Combinatory Categorical Grammar (CCG) [Steedman, 1996].6

Hahn’s work on medSyndicate [Hahn et al., 1999a], provides a detailed ex- ample using a specially constructed ontology in Loom. The medSyndicate ar- chitecture features close coupling of the ontology (“Domain knowledge base”) with the parser and extensive use of learning techniques to deepen and extend both the ontology and the grammar. It uses the integrity conditions, and concep- tual constraints, and cardinality restrictions in the ontology to reduce ambiguity and select plausible interpretations. It makes use of knowledge within the ontol- ogy to complete ellipses within the original text – e.g., to know that the connec- tion between a gland and its product is “secretes”. It also makes extensive use of partonomic information using a unique approach discussed in Subsection 13.3.2.3 below. Rassinoux and Baud have used the Galen ontology to augment a strongly semantic approach likewise to constrain ambiguous or incomplete parsings [Baud et al., 1993; Rassinoux, 1998]. Zweigenbaum has used a restricted applica- tion speciﬁc ontology to similar purpose [Zweigenbaum et al., 1995]. Ceusters, by contrast, attempted to use natural language processing to understand the text attached to codes (the “rubrics”) to build and make mappings to the Galen ontology. Ceusters’ work was based on a range of pre-existing tools and experienced signiﬁcant difﬁculty because of serious differences in the information-processing- oriented ontology developed by Galen and the language-oriented ontologies which underlay his tools. For example, the distinctions between location and part–whole relations and the distinctions amongst different part–whole relations have no direct linguistic counterpart. An adaptation of the Galen Intermediate representation was used to bridge this gap, but with only partial success [Ceusters and Spyns, 1997; Ceusters, 1998; Ceusters et al., 1999].

6 However, it should be noted that the classic medical natural language work, the Linguistic String Project [Sager et al., 1987; 1994], while it makes extensive use of semantics, makes no use of ontologies or related h i

13.2.2.2 Language generation, user interfaces, and quality assurance

Any ontology intended for use by domain experts presents a problem of quality assurance, or curation, by those experts. Any post-coordinated use of an ontology also presents a serious problem for the user interface – standard DL expressions are not acceptable for most uses by most domain experts. Even if they are simpli- ﬁed to an “intermediate representation” or transformed to conceptual graphs, the complexity is too great for most domain experts to take in quickly. One way to make such expressions accessible to users is to generate language ex- pressions from them. Not only are the language expressions more readable, they are usually much more compact. Galen has found language generation to be essential in virtually all applications involving post-coordination including most approaches to independent quality assurance of the ontology. One of the major applications of Galen technology has been by the French gov- ernment to produce unambiguous deﬁnitions for their new national classiﬁcation of surgical procedures. Curiously, in this application, the usual language gener- ation goals of concise idiomatic expression do not apply. The value of the tech- nique is its pedantic, but completely unambiguous, presentation of the underlying formal deﬁnitions. Once the deﬁnitions are agreed and quality assured, idiomatic “preferred terms” can be composed manually where required [Baud et al., 1997; Rodrigues et al., 1997].

13.2.3 Decision support, indexing, and re-usable ontologies for problem solving

Many decision support methodologies, notably Musen’s Prot´eg´e and Ae´on [Tu et al., 1995; Musen et al., 1996; Musen, 1998; Grosso et al., 1999] and Stefanelli’s Games [Schreiber et al., 1993; Vanheijst et al., 1995; Falasconi et al., 1997], are based around the existence of a domain ontology, but in general the ontologies are constructed speciﬁcally for one application and have proved less re-usable than the problem-solving methods they support. Both use ontologies primarily as frame systems. A more speciﬁc use of the classiﬁcation reasoning in Description Logics is pro- vided by Galen’s work on drug ontologies carried out in collaboration with the Prodigy project on computerized guidelines for prescribing in UK general prac- tice [Johnson et al., 2000]. Traditional classiﬁcations for diseases and drugs have only a single axis of generalization which conﬂates several different criteria. For example, standard drug classiﬁcations conﬂate indication (e.g., for “treatment of asthma”), molecular effects (e.g., “stimulates alpha adrenergic receptors”), phys- iological effects (e.g., “dilates the airways”) and chemical structure. As result, even simple generalizations such as “steroids reduce inﬂammation” are difﬁcult to

operationalize using the classiﬁcation because various steroids may be classiﬁed in many different ways – under anti-asthmatic drugs, topical skin preparations, anti-rheumatic drugs, etc. Separating the conﬂated axes and then using them as the basis of formal descrip- tions which can be classiﬁed by a Description Logic offers a potential solution. After early prototype demonstrations [Solomon and Heathﬁeld, 1994], Galen is now being used to construct an ontology of drugs and related conditions to be used as part of the Prodigy project, a system of protocols for prescribing for patients with chronic diseases which is being developed by the UK Department of Health [Solomon et al., 1999; Wroe et al., 2000]. Experience to date suggests that the ontology provides efﬁciently precise indexing at the varying levels of granularity required and can provide a framework for the necessary default reasoning via the mechanisms described in Subsection 13.2.1.1 for coding. Further evaluation awaits the next phase of the project.

13.2.4 Intelligent data entry

Data capture is the largest single barrier to greater information use in healthcare. Galen developed from the Pen&Pad project [Nowlan et al., 1991a; 1991b] which aimed to improve user interfaces for healthcare professionals and which placed particular emphasis on data entry by attempting to construct forms which would capture most, if not all, of the information currently recorded as narrative text. The ontology provides two services in Pen&Pad – both related to the question “What can be sensibly said in this situation?”:

r Indicating how a given concept could be reﬁned by modiﬁers. r Indexing the form associated with each starting concept – often a disease or a symptom. Each such form may contain numerous subforms allowing further reﬁnement of a concept or inclusion of further less common signs and symptoms.

The total number of forms required to provide a clinical interface is very large – certainly hundreds of thousands and possibly more. The goal of the system is to assemble forms dynamically from the indexed “recipes” in such a way that it would fail soft – i.e., that forms for important frequently encountered situations could be highly tailored at a very ﬁne granularity whereas rarely encountered areas could be served by a form related only to the broad class of condition. In its commercial version, ClinergyTM, a knowledge base of under 10,000 concepts and a similar number of auxiliary facts and forms speciﬁcations covered essentially all data entry for British general practice – a task requiring several hundreds of thousands of forms.7

7 S h // l i i /f h h l f f th i f ti

Related systems were developed by Poon and Fagan [1994] and Lussier et al. [1992]. using conceptual graph representations of Snomed-International.

13.2.5 Integration

Amajorostensiblegoalforcommonterminologiesinmedicineissystemintegration [Evans et al., 1994; Rector et al., 1995b; Spackman et al., 1997]. While specialized terminology systems are being used in a few places as part of an enterprise wide effort at integration [Rocha et al., 1993; 1994; Cimino et al., 1998], ontologies based on Description Logics have yet to be demonstrated convincingly in this context. Much of the reason for this is the sheer scale and coverage required for such mediation tasks.

13.3 Technical issues in medical ontologies

13.3.1 Issues of scaling

13.3.1.1 Size

The fundamental issue in any medical ontology intended to capture clinical termi- nology is scale. The smallest useful medical terminologies contain on the order of 10,000 concepts; “comprehensive” terminologies require on the order of 250,000 or more concepts. The OpenGalen model of basic anatomy alone contains over 5000 concepts, the model of surgical procedures some 15,000. Snomed-rt cur- rently has some 180,000 concepts, and the combined Clinical Terms (Read Codes) Snomed-ct expects to have substantially more. The Uniﬁed Medical Language System has issued nearly a million “Unique Concept Identiﬁers” with over a mil- lion lexical variants.

13.3.1.2 Connectivity

Medical ontologies are notoriously highly connected. Most medical concepts de- pend on anatomy, and every anatomical structure is ultimately connected to every other, at least trivially, by virtue of being part of the body. The causal and func- tional interrelationships are of similar density. Snomed-rt reduces connectivity by omitting inverses. Grail supports role inverses and transitive roles, but Galen’s ontology explicitly avoids expressions of the form “A which is part of B which has part C”, for which the classiﬁer is known to be incomplete. It is not known whether complete and decidable reasoning for a Description Logic including role transi- tivity and inverses is practical for a large scale comprehensive medical ontology: some form of heuristic constraint on the depth or computational resources used for individual inferences may prove necessary

13.3.1.3 Range of granularity or organization

Common medical notions span the range from the molecular to the physiological to the behavioural. To form a truly re-usable framework for medical knowledge representation, the ontology needs to encompass concepts such as “substances which cause mood change and tremor by binding to speciﬁc receptor sites”. If the promise of “genomics” is to be realized, this may soon need to be extended to include concepts which add “. . . by stimulating the expression of a genetic sequence homologous to some speciﬁed allele in some reference source”.

13.3.1.4 Complexity of concepts to be represented

The areas of medicine most resistant to traditional manual terminologies and there- fore most ripe for formal representation tend to include very complicated concepts. For example, a not untypical surgical procedure rubric to be represented might be “Removal of the gall bladder using an endoscope inserted via an abdominal inci- sion” or “Fixation of fracture of the femur by means of insertion of pins”. More complex rubrics may go on for several lines in their natural language formulation. The full expansion in a Description Logic may include several dozen conjuncts nested ﬁve or six levels deep. This complexity is not an academic artifact; these are the categories used to determine payment, quality of outcome, and prognosis.

13.3.1.5 How much to represent – detail of the ontology

Snomed-rt has a relatively simple ontology with less than ten roles. The Galen ontology is relatively complex, with some ﬁfty roles, including seven differ- ent partonomic roles, and sharp distinctions between two-dimensional and three- dimensional objects. The Digital Anatomist appears to be a representation of similar complexity to Galen’s anatomical representation. At the extreme, Gangemi et al. [1996] have produced a high level ontology which claims strong philosophical grounding but is yet more elaborate. How much of this complexity is required for which purposes is still not established.

13.3.2 Issues of expressivity: part–whole relations

13.3.2.1 Transitivity and anatomy

A large fraction of all medical terminology is based on anatomy and dependent on part–whole relations. “Fracture of foot” must be classiﬁed as “trauma to lower extremity”, “repair of the aortic valve” must be classiﬁed as an “operation on heart”, etc. Conﬂation of part–whole and IS-A relations is ubiquitous in informal clinical classiﬁcations and thesauri [Rector 1998] In general this works because for the

key locative attributes it is, in general, true that a disease of the part is a disease of the whole and a procedure on a part is a procedure on the whole. This is closely related to Cyc’s TRANSFERS-THRO notion and to some frame systems’ notion of inheritance of certain slots via relations other than IS-A.

13.3.2.2 Galen’s specialisedBy axioms and Snomed-rt’s right identity axioms

All medical ontologies must face this problem in one way or another. Galen allows axioms equivalent to R ◦S ⊑R (R specialisedBy S in Grail notation). Snomed-rt allows the declaration that S is a right identity for R, which appears to be equivalent [Spackman, 2000]. Hence if R is hasLocation and S is isPartOf, then

∃hasLocation.(∃isPartOf.Heart) ⊑∃hasLocation.Heart

where hasLocation is the relation used to link lesions and diseases to anatomy. Given axioms such as that

AorticValve ⊑∃isPartOf.Heart,

therequiredinferencesthatlesionsoftheaorticvalvearelesionsoftheheartfollows, i.e., it can be inferred that

∃hasLocation.AorticValve ⊑∃hasLocation.Heart.

There are, in practice, a variety of other situations in which this construct seems essential, for example to say that the “risk of a syndrome involving a disease” is subsumed by a “risk of the disease itself”. Galen also makes extensive use of the implication of such axioms for the in- verse roles, i.e., S−◦R−⊑R−. For example, let S be isSubProcessOf and R be isActedOnBy, then S−and R−are hasSubprocess and actsOn respectively. The implication of such an axiom for the inverse roles then allows us to express the rule that surgical procedures can be said to act on all those structures acted on by their subprocedures, e.g.:

∃hasSubprocess.(∃actsOn.FemoralArtery) ⊑∃actsOn.FemoralArtery.

This is a practical example. The femoral artery is the usual route by which the heart is catheterized. Without such inferred subsumptions, cardiac catheteriza- tion would not be found as a target for the procedure – e.g., by a decision support system seeking to identify possible causes of damage to the femoral artery. Numerous parts of the classiﬁcation of surgical procedures depend on such inferences

The Grail language allows chains of such axioms, which can imply complex paths. Such axioms also interact strongly with the role hierarchy. Re-representing these paths as regular expressions of roles taking into account the role hierarchy is a current topic of research.

13.3.2.3 The “triples” approach

Hahn et al. [1999c; 1999b] have developed an alternative representation for parto- nomicrelationsbasedonwhattheyhavetermed“SEP-triples”,whichcapturesmuch partonomic reasoning within a framework compatible with the standard ALC De- scriptionLogic.IntheSEP-tripleformulation,eachanatomicalpart X isrepresented by a parent concept Xs, and two subsumed concepts Xe and X p. Xe represents the entity as a whole, and X p the concept of its parts. For all parts Y of X, X p subsumes Ys, and since Ys subsumes both Ye and Yp, both the entire part Ye and all of its parts Yp are subsumed by the parts of X.

Yp ⊑Ys ⊑X p ⊑Xs X p ⊑∃anatomicalPartOf.Xe.

This captures the transitive relation, i.e., that any part of Y is a part of X. For invariant anatomical relations, a separate existentially qualiﬁed role called hasAnatomicalPart links Xe to Ye.

Xe ⊑∃hasAnatomicalPart.Ye.

This scheme allows Hahn to capture the notion that something is always part of the whole if it is present, but that it may not necessarily be present (e.g., that it may have been removed or be congenitally absent) – this is achieved by omitting the third axiom. This allows inferences such as that a disease of a part must be a disease of the whole structure (s) node, but not of the whole taken as in its entirety (e) node. By careful selection of which of the three members of an SEP-triple is used in an assertion, it appears to be possible to be selective about which properties are “inherited”. For example: “diseases of parts are diseases of the whole”, but “surfaces of parts are not surfaces of the whole”. Hence in Hahn’s schema, “surface of” should always refer to an entity (e) node representing the entire object, whereas diseases should refer to the structure (s) node representing the complex of the entire object and all of its parts. Detailed comparison of the expressiveness of SEP-triples with Snomed-rt’s right identities and Galen’s specialisedBy axioms is not yet known. However, the scheme presents a number of advantages and is relatively easy to implement with existing classiﬁer technology

13.3.2.4 Construct not implemented in any major medical ontology

Padgham and Lambrix [1994] point out a number of other potential patterns for relationships between parts and wholes of which at least one is potentially important for anatomical reasoning but not implemented in any current Description Logic. This formalizes the pattern that from “the hand is part of the arm” we may infer that “the skin of the hand is a part of the skin of the arm”. One way to capture the essence of this notion formally would be to allow axioms of the form R ◦S ⊑S ◦R so that we have

isLayerOf ◦isPartOf ⊑isPartOf ◦isLayerOf,

from which may be inferred, for example,

∃isLayerOf.(∃isPartOf.Arm) ⊑∃isPartOf.(∃isLayerOf.Arm).

The Galen ontology makes the necessary distinctions between different parto- nomic relations but the Grail language does not implement this inference.

13.3.3 Other issues of expressivity

Both Galen and Snomed-rt use Description Logics with a very limited range of core constructors – usually only existential quantiﬁcation and conjunction. Both even exclude conjunctions of primitives. Neither uses universal quantiﬁcation in its constructors, although Grail’s “sanctioning” mechanism provides constraints which serve some of the same functions [Rector et al., 1997]. (Hahn uses Loom, but exploits only a limited subset of the concept language.) On the other hand, both include constructs for transitive relations as described above. Two other issues deserve mention.

13.3.3.1 Negation

Neither Galen nor Snomed-rt uses negation, at least in the subset of the DL used in the ontology itself. This reﬂects real questions about the appropriate interpretation of negative statements in clinical records. In the context of medical records, there needs to be a clear differentiation at all levels between “false” and “not done” or “unknown”. Galen simulates some of the effects in the ontology by the use of “modalities” such as “presence/absence” and “done/not-done” [Rector and Rogers, 2001; Rector et al., 2002].

13.3.3.2 General inclusion axioms

Galen makes extensive use of a subset of general inclusion axioms – i.e., axioms which state that one deﬁned concept is classiﬁed under another concept In Galen

the subsuming term is restricted to be a conjunction of existentially qualiﬁed con- structed concepts. Galen uses such expressions for two purposes:

r To indicate which structures, states and processes are normal, abnormal but harmless, or pathological, i.e., to be treated as “diseases”. In many cases it is the presence of speciﬁc modiﬁers which implies that a structure or process is “pathological”. r To bridge levels of granularity and add implied meaning, e.g., to indicate that “ulcer of stomach” really occurs in the “lining of the stomach” or to cope with normalization as discussed in Subsection 13.4.2.2.

ManyDescriptionLogicshaveexplicitlydisallowedgeneralinclusionaxiomsbe- cause of the difﬁculty of devising suitable algorithms and worries about intractabil- ity. However, motivated by Galen, Horrocks has shown effective optimizations for Description Logics including general inclusion axioms. Furthermore, he has shown that all such axioms in Galen are of a particular form which can be transformed so as to be “absorbed” within term deﬁnitions, and therefore reasoned with relatively efﬁciently [Horrocks and Rector, 1996; Horrocks et al., 1996; Horrocks, 1997b; 1998b].

13.3.4 Frame-like behavior

The use of Description Logics in both decision support and data entry systems stemmed from the use of frame systems to manage default inheritance and identify the slots relevant to a particular object. Neither is easy to implement directly in Description Logics. Both are particularly important in medical applications. Be- cause of their size and variability, exhaustive manual enumeration of cases is neither practical initially nor maintainable.

13.3.4.1 Defaults and indexing

A major function of an ontology in a decision support system is to index informa- tion. However, the natural representation for a domain expert of this indexing is usually in terms of generalizations with exceptions. For example drug indications, interactions and side effects are all almost invariably expressed as general princi- ples plus exceptions (chemical structure, biochemical and physiological actions can usually be treated as being indefeasible). To require all statements to be indefeasible in the domain users’ environment drastically limits its usability and usefulness. Galen’s approach is to attach “extrinsic” statements to the ontology and provide operations in the server which deliver all potential most speciﬁc candidates as described in Subsection 13.2.1.2. Experience has shown that if the ontology is well constructed, the incidence of conﬂict is small and almost always represents a real requirement for additional information Often this information is application

speciﬁc – how seriously a drug’s side effects should be viewed in a given situation, for example, or which of several minor variant codes matches the World Health Organization’s detailed coding criteria – and not appropriate to a re-usable ontology. It has been suggested that similar behavior could be achieved by “compiling” all defaults at the user level to explicit exclusions in the underlying Description Logic. A practical demonstration of this approach on a large scale in the medical ﬁeld has yet to be seen.

13.3.4.2 Available “slots”: “what is it reasonable to say?”

Galen’s original approach was to represent “all and only what it is medically sensible to say”. Pen&Pad (as well as non-medical uses of Grail such as the BioInformatics project Tambis [Baker et al., 1998]) depends on assembling data entry forms and queries dynamically. The total number of potential forms is vastly greater than could be enumerated individually. Both applications depend on being able to determine which roles are “sensibly” applicable to a particular concept. Grail’s sanctioning mechanism provides this information directly, but there is no direct way to form such a query within a standard DL framework. How best to address this issue remains a topic for research. A key part of the Galen experience in this regard is that only part of this “sanc- tioning” information is re-usable. In the original Pen&Pad application, changes to the user interface were made by changing the underlying ontology. In Galen, and in the commercial version of Pen&Pad, ClinergyTM, changing the re-usable ontol- ogy to ﬁt an application speciﬁc requirement was unacceptable, so an additional layer of “perspectives” was interposed between the ontology itself and applications. This layered architecture now seems essential to many applications of ontologies which aspire to be re-usable.

13.4 Ontological issues in medical ontologies

13.4.1 Normative statements and abnormalities

Congenital and other deformities present a major difﬁculty to clinical knowledge representations, because they require that statements which would otherwise be absolute be made somehow contingent and that an extremely wide variety of statements be permitted in exceptional circumstances. They also require drawing distinctions that seem odd. Even in a thalidomide patient with an absent left arm, we still need to be able to make statements about the left arm. Hence physical and potential presence must somehow be distinguished. Likewise, in determining what it is “sensible” to say, congenital anomalies make a nonsense of the usual constraints. For example, most patients have their heart on their left side three lobes to their right lung and two lobes to their left Most patients

have a “right middle lobe” but no “left middle lobe” of the lung. However, a small percentage of patients reverse the pattern. The anomaly is not always complete, so many combinations of abnormalities are possible. Doctors tend to be highly intolerant of being presented with options such as “left middle lobe” in normal circumstances. Unfortunately, they are equally intolerant of the inability to express the notion of a “left middle lobe” in that small number (≪1%) of cases where it is needed. Taken individually, such anomalies are rare. Taken collectively, they are surprisingly common, i.e., a signiﬁcant percentage of all patients are atypical in one respect or another.

13.4.2 Clinical pragmatics

13.4.2.1 Conventional idioms

As in any language, many terms or phrases have conventional meanings differ- ent from their literal interpretation. Such differences are not always immediately obvious. A typical example is “endocrine surgery” which it might seem natural to deﬁne as “surgery on an endocrine organ”. However, procedures on both the male and female reproductive organs are normally excluded, even though no doc- tor would dispute that they are endocrine organs. Similarly, “heart valve” might naively be deﬁned as a “structure in the heart with valvular function”, but this includes numerous embryonic and sometimes congenitally deformed structures as well as the four “major valves” which serve the four “great vessels” enter- ing and leaving the heart. Much of the effort of formulating a satisfactory med- ical ontology goes into reconciling such conventional usages with their apparent meaning.

13.4.2.2 Normalization and implied information

Many medical notions, particularly of actions and procedures, carry strong implica- tions about their purpose. O’Neil’s classic example illustrates this problem [O’Neil et al., 1995; Brown et al., 1998]. A common procedure to treat hip fractures is “insertion of pins in the femur”. The only reason to insert pins in the femur is to “ﬁxate” a fracture, and the operation is expected to be classiﬁed under both “inser- tion of pins” and “procedures to ﬁxate fractures of long bones”. Should the ontology contain axioms to extend the procedure deﬁnition automatically by adding “. . . to ﬁxate fracture of femur”? If so, should the procedure be “ﬁxation of fracture of femur by means of insertion of pins in the femur” or “insertion of pins in order to ﬁxate fracture of femur”? Ordinarily such “qua-induced” duals are distinct – e.g., the “infection caused by a virus” is very different from the “virus caused by an in- fection”. In these cases, two or more logically distinct possible representations are clinically equivalent Most systems cope with this situation by imposing external

“guidelines” on domain expert authors to normalize such expressions to one form or the other, but the problem is far from solved.

13.4.3 Semantic normalization and level of intent

Consider the problem of what constitutes a “surgical procedure”. It is easy to agree that all surgical procedures are constituted by an “act” on some “thing” which either is, or is located in, an anatomical structure. It is less easy to agree on what constitutes an “act” when there is a hierarchy of motivations: for example, “inserting pins to ﬁxate a fracture of a long bone” or “destruction of a polyp by cautery” or “removal of a polyp (by excision)”. Furthermore, important classiﬁcations hang on notions of motivation such as “palliative surgery” versus “corrective surgery”. In addition, some systems wish to be able to record operations just as “correction of X” without describing the exact “act”, while others wish to record “insertion of pins in fractured bone” without recording that the purpose is ﬁxation. To address this problem within Galen, Rossi Mori et al. [1997] proposed a classiﬁcation into four levels:

L4 clinical goal (palliation, cure); L3 physiological goal: (correction, destruction, . . . ); L2 primary surgical method (excision, insertion, lysis, . . . ); L1 low level surgical act (cutting, cautery, . . . ).

It is tempting to believe that a list of concepts in each category could be agreed, so that resolution could be done automatically. However, at least within the Galen project, intuitions and requirements clashed sufﬁciently to make this difﬁcult. For example, “cautery” can sometimes be a low level act or sometimes a primary method. This ambiguity is dealt with in the formal ontology by having separate concepts for “simple cautery” and “removal by cauterization”, and by care in for- mulating the intermediate representation (see Subsection 13.5.1). However, achiev- ing consistent usage amongst a range of authors with different applications requires vigilance and careful quality assurance.

13.5 Architectures: terminology servers, views, and change management

13.5.1 Intermediate representations and views: Galen ’s layered architecture

There is an inevitable conﬂict between the need for an ontology to be re-usable and the requirement that it be easily understood by the domain experts who must author and maintain it. Snomed-rt addresses this problem by keeping the ontol- ogy relatively simple. Galen addresses this problem by placing an “intermediate representation” and views (“perspectives”) between the re usable ontology and

user-oriented applications [Rector et al., 1999; 2001]. The intermediate represen- tation and perspective layers in the architecture hide complexities irrelevant to the current application from domain experts and other users. It also allows for varia- tions amongst domain experts in the vocabulary, structure, and – critically for an international project – language. In this layered architecture, the DL ontology is effectively reduced to a role analogous to that of an assembly language program. Using an intermediate representation both allows loose coupling amongst authors and simpliﬁes the authoring task. Within the Galen project, use of an intermediate representation reduced training time for new authors from months to days. It also drastically reduced the time required centrally to harmonize the work of different authors so that the resulting classiﬁcation would pass an agreed quality assurance. Prior to the introduction of the intermediate representation, central harmonization had consumed over ﬁfty percent of the effort; following introduction of the intermediate representation this dropped to less than ten percent. This is a major saving given that the knowledge engineers required for central harmonization take a year or more to train fully. The experience of developing the drug ontology in Prodigy (see Subsection 13.2.3) has been roughly comparable. In addition, in the drug ontology, the use of the intermediate representation has allowed the quality assurance experts to participate directly in correcting the authored ontology – something which would be entirely impractical in its expanded formulation in the Description Logic.

13.5.2 Learning vs. building

Given the scale of medical ontologies, it would obviously be attractive to use learning techniques for at least some of their construction. Hahn et al. [1999a] are focusing on using language plus the structure of the Uniﬁed Medical Language System as a major source for inducing their ontology. Campbell et al. [1998] have outlined a strategy which makes use of lexical “suggestions” to guide manual modeling as part of the Snomed-rt methodology. Galen has experimented with various linguistic techniques but so far with limited success [Ceusters et al., 1999].

13.5.3 Version and change management

Any medical ontology for general use must be a living developing structure. There are both clinical and technical issues to be dealt with. Campbell et al. [1996] have developed a tightly coupled methodology for change management in conjunction with Snomed-rt, while Oliver et al. [1999] and Cimino [1996] have discussed the issues of changes in medical vocabulary

13.6 Discussion: key lessons from medical ontologies

Medicine is big and complicated. It has a long tradition of controlled vocabularies and coding systems. Developing re-usable medical ontologies presents at least three major classes of issue to the DL community:

r Developing implementations which scale. r Developing architectures which reconcile the needs of users for simplicity with the formal constraints required for tractability and the ontological richness required for re-use. r Developing formalisms expressive enough to cope with constructs of particular concern to medicine, particularly part–whole relations but also other spatio-temporal constructs such as adjacency.

Perhaps most critically, medicine poses the challenge of presenting DL notations in forms which users can use to meet real problems – whether in representation of medical records, indexing of information for decision support, or supporting user interfaces and natural language processing.

14

Digital Libraries and Web-Based Information Systems

IAN HORROCKS DEBORAH L. McGUINNESS CHRISTOPHER A. WELTY

Abstract

It has long been realized that the web could beneﬁt from having its content under- standable and available in a machine processable form, and it is widely agreed that ontologies will play a key role in providing much enabling infrastructure to achieve this goal. In this chapter we review brieﬂy a selected history of Description Logics in web-based information systems, and the more recent developments related to OIL, DAML+OIL and the Semantic Web. OIL and DAML+OIL are ontology lan- guages speciﬁcally designed for use on the web; they exploit existing web standards (XML, RDF and RDFS), adding the formal rigor of a Description Logic and the ontological primitives of object-oriented and frame-based systems.

14.1 Background and history

The research world as well as the general public are uniﬁed in their agreement that the web would beneﬁt from some structure and explicit semantics for at least some of its content. Numerous companies exist today whose entire business model is based on providing some semblance of structure and conceptual search (e.g., yellow pages and search). To paraphrase Milne [1928], “Providing structure is one of the things Description Logics do best!”. In this chapter we review brieﬂy the history of Description Logics in web-based information systems, and the more recent developments related to OIL (the Ontology Inference Layer), DAML (the DARPA Agent Markup Language), DAML+OIL and the Semantic Web. The web has been a compelling place for research activity in the last few years, and as we cannot cover all the many efforts we will choose a few exem- plar efforts that illustrate some of the key issues related to Description Logics on the web

14.1.1 Untangle

The relationship between hypertext and semantic networks has long been realized, but one of the earliest DL systems to realize this relationship was the Untangle system [Welty and Jenkins, 2000], a DL system for representing bibliographic (card-catalog) information. The Untangle project began as a bit of exploratory research in using Description Logics for digital libraries [Welty, 1994], but out of sheer temporal coincidence with the rise of the web, a web interface was added and the ﬁrst web-based Description Logic system was born. The original Untangle web interface was developed in 1994 [Welty, 1996a], and combined Lisp-Classic and the CommonLisp Hypermedia Server (CL-HTTP) [Mallery, 1994] to implement a hypertext view of the ABox and TBox semantic networks, and used nested bullet lists to view the concept taxonomy, with in-page cross references for concepts having multiple parents. The interface was interesting in some respects as a tool to visualize DL and semantic network information, though this aspect was never fully developed. The research in the Untangle project was to apply Description Logics to prob- lems in digital libraries, speciﬁcally the classiﬁcation and retrieval of card catalog information. In the early days of DL applications, researchers scoured the world for taxonomies. One place with well-developed taxonomies is library subject clas- siﬁcations schemes, such as the Dewey Decimal System. The Untangle project sought to utilize Description Logics to formally represent the established and well- documented processes by which books are classiﬁed by subject, with the goal of providing a tool to improve accuracy and increase the throughput of classiﬁcation. The promise of digital libraries clearly seemed to imply that the entirely human- based system of subject classiﬁcation would become backlogged and a hindrance to publication. While the main contribution of the work was actually in the area of digital library ontologies, it had several useful implications for Description Logics. For conceptual modeling, the system made clear the very practical uses for primitive and deﬁned concepts as basic ontological notions. Primitive concepts can be used in a model to represent classes of individuals that users are expected to be able to classify naturally. Deﬁned concepts can be used in a model to represent subclasses of the primitive ones that the system will be able to classify if needed. For example, in libraries we expect a librarian to be responsible for recognizing the difference between a book and a journal. Such a distinction is trivial. On the other hand, they are not responsible for classifying a biography (though they can, of course): a biography is simply a book whose subject is a person. As the World Wide Web (WWW) became the primary means of dissemination of computer science research, the goals of the Untangle project shifted in 1995

to cataloging and classifying pages on the web [Welty, 1996b], which was viewed as a massive and unstructured digital library [Welty, 1998]. A similar project began at roughly that time at AT&T, whose goal was to utilize Classic to represent a taxonomy of web bookmarks. While never published, this early work by Tom Kirk was part of the information manifold project [Levy et al., 1995]. Kirk’s visualization tools were also used internally to provide additional visualization support to the Classic system. This new work exposed some of the limitations of using Description Logics for modeling [Welty, 1998]. One must trade off utilizing automated support for subsumption with the need to reify the concepts themselves. For example, the work started with the motivation that library classiﬁcation schemes were well- developed taxonomies that would be appropriate for use in Description Log- ics. To utilize the power of subsumption reasoning, the elements of the subject taxonomy must obviously be concepts. Some subjects, however, are also use- ful to consider as individuals. For example, Ernest Hemingway is a person, an author of several books, and therefore best represented as an individual. Hem- ingway is also, however, the subject of his (many) biographies, and therefore he must be represented as a concept in the subject taxonomy. This is a simple example of precisely the kind of representation that is difﬁcult for a Descrip- tion Logic, without inventing some special-purpose “hack”. Similar notions have also been reported in the knowledge engineering community [Wielinga et al., 2001].

14.1.2 FindUR

Another early project using Description Logics for the web was the FindUR system at AT&T. FindUR [McGuinness, 1998; McGuinness et al., 1997] was an excellent example of picking “low hanging fruit” for Description Logic applications. The basic notion of FindUR was query expansion,1 that is, taking synonyms or hyponyms (more speciﬁc terms) and including them in the input terms, thereby expanding the query. Information retrieval, especially as it is available on the web, rates itself by two independent criteria, precision and recall. Precision refers to the ratio of desired to undesired pages returned by a search, and recall refers to the ratio of desired pages missed to the total number of desired pages. Alternate terms for these notions are false positives and false negatives.

1 Sometimes other correlated terms are also used in query expansion. In a later piece of work [Rousset, 1999b], similar because it considered a DL-based approach for query expansion, more of the formal issues are addressed in evaluating the soundness and completeness of a particular approach. There have also been others who have considered DL approaches (or DL-inspired approaches) to retrieval, for example [Meghini et al., 1997].

One of the main causes of false negatives in statistically-based keyword searches is the use of synonymous or hyponymous search terms. For example, on the (then) AT&T Bell Labs research site, short project descriptions existed about Description Logics. These never referred to the phrase “artiﬁcial intelligence”. Thus, a search for the general topic “artiﬁcial intelligence” would miss the DL project pages even though Description Logics is a subarea of artiﬁcial intelligence. If the page referred to “AI” instead of “artiﬁcial intelligence” precisely, a keyword search would also miss this clear reference to the same thing. This is a well-recognized failure of shallow surface search techniques that signiﬁcantly impacts recall. The FindUR system represented a simple background knowledge base contain- ing mostly thesaurus information built in a Description Logic (Classic) using the most basic notions of Wordnet (synsets and hyper/hyponyms) [Miller, 1995]. Con- cepts corresponding to sets of synonyms (synsets) were arranged in a taxonomy. These synsets also contained an informal list of related terms. Site speciﬁc search engines (built on Verity – a commercial search engine) were hooked up to the knowledge base. Any search term would ﬁrst be checked in the knowledge base, and if it was contained in any synset, a new query would be constructed consisting of the disjunction of all the synonymous terms, as well as all the more speciﬁc terms (hyponyms). The background knowledge was represented in Classic, but the Description Logic was not itself part of the on-line system. Instead, the information used by the search engine was statically generated on a regular basis and used to populate the search engine. The true power of using a Description Logic as the substrate for the knowledge base was realized mainly in the maintenance task. The Description Logic allowed the maintainer of the knowledge base to maintain some amount of consistency, such as discovering cycles in the taxonomy and disjoint synsets. These simple constraints proved effective tools for maintaining the knowledge since the knowledge itself was very simple. The FindUR system was deployed on the web to support the AT&T research web site and a number of other application areas. Although the initial deployments were as very simple query expansion, some later deployments included more structure. For example, the FindUR applications on newspaper sites and calendar applications (such as the Summit calendar2) included searches that could specify a date range, date ordered returns, and a few other search areas including region or topic area. These searches included use of meta-tagging information on dates, location, topics, sometimes author, etc. This functioned as a structured search similar in nature to the later developed SHOE Search [Heﬂin and Hendler, 2001] for the semantic web, and was also similar to what Forrester reported as being required for search

2 h // i illi / i / l d /

that would support eCommerce [Hagen et al., 1999]. The FindUR applications for medical information retrieval [McGuinness, 1999] also included more sophisticated mechanisms that allowed users to search in order of quality of study method used (such as randomized control trial study). Applications of FindUR ranged in the end to include very simple query expansion, such as those deployed on WorldNet and Quintillion (see Directory Westﬁeld3), as well as more complicated markup searches such as those on the AT&T competitive intelligence site and the P-CHIP primary care literature search.

14.1.3 From SGML to the Semantic Web

Independently of Description Logics, and dating back to the mid 1980s, researchers in other areas of digital libraries were using SGML4 (Standard Generalized Markup Language) as a tool to mark up a variety of elements of electronic texts, such as identifying the characters in novels, cities, etc., in order to differentiate them in search. For example, a reference to Washington the person in some text may appear as <person>Washington</person> whereas a reference to the US state may be <state>Washington</state>. See, for example, the 1986 Text Encoding Initiative [Mylonas and Renear, 1999]. Clearly, a search tool capable of recognizing these tags would be more precise when searching for “Washington the person”. This work may be viewed as establishing some of the ground work for the vision of the Semantic Web that Tim Berners-Lee and colleagues have more recently popularized. As the SGML communities proceeded in their efforts to create large reposito- ries of “semantically” marked-up electronic documents, research in using these growing resources sprang up in the database and DL communities, with some early results making it clear that Description Logics were powerful tools for handling semistructured data [Calvanese et al., 1998c; 1999d]. In the mid 1990s, work in SGML gained some attention mainly because HTML5

(HyperText Markup Language) was an SGML technology, and it became clear that the same sort of “semantic” markup (as opposed to “rendering” markup) could be applied to web pages, with the same potential gains. The main syntax speciﬁcation properties of SGML were combined with the text-rendering properties of HTML to generate XML6 (Extensible Markup Language), and with it came the promise of a new sort of web, a web in which “meta-data” would become the primary consumer of bandwidth. These connections made it reasonable to consider the existing work on semi-structured data in Description Logics a web application.

3 http://www.ataclick.com/westfield/ 4 http://www.w3.org/MarkUp/SGML/ 5 http://www.w3.org/MarkUp/ 6 h // 3 /XML/

In an attempt to prevent the web community from repeating the same mistakes made in knowledge representation in the 1970s, in particular using informal “pic- ture” systems with no understood semantics and without decidable reasoning, the DL community became very active in offering languages for the new semantic web. The community was already well-positioned to inﬂuence the future of semantic web standards, due in part to (a) the strong history that Description Logics bring, with well-researched and articulated languages providing clear semantics (as well as complexity analyses), (b) the existing work on the web described here, including web applications like Untangle and FindUR, and (c) DL languages designed for web use such as OIL.

14.2 Enabling the semantic web: DAML

The web, while wildly successful in growth, may be viewed as being limited by its reliance on languages like HTML that are focused on presentation of information (i.e., text formatting). Languages such as XML do add some support for capturing the meaning of terms (instead of simply how to render a term in a browser), but it is widely perceived that more is needed. The DARPA Agent Markup Language (DAML) program7 was one of the programs initiated in order to provide the foun- dation for the next generation of the web which, it is anticipated, will increasingly utilize agents and programs rather than relying so heavily on human interpretation of web information [Hendler and McGuinness, 2000]. In order for this evolution to occur, agents and programs must understand how to interact with information and services available on the web. They must understand what the information means that they are manipulating and also must understand what services can be provided from applications. Thus, meaning of information and services must be captured. Languages and environments existing today are making a start at providing the required infrastructure. The DAML program exists in order to provide funding for research on languages, tools, and techniques for making the web machine under- standable. The groundwork for the DAML program was being laid in 1999 with the ap- proval for the broad area announcement in November and a web semantics lan- guage workshop in December. A strawman language proposal effort was begun out of that work and the major initial emphasis began with a web-centric view. A web- oriented strawman proposal was worked on but not widely announced. One of the early widely-distributed contributions of the DAML program was DAML-ONT 8 – a proposal for an ontology language for the web [Hendler and McGuinness, 2000; McGuinness et al., 2002]. This language began with the requirement to build on

7 http://www.daml.org/ 8 h // d l /2000/10/d l h l

the best practice in web languages of the time and took the strawman proposal as the motivating starting point. That meant beginning with XML, RDF9 (Resource Description Framework), and RDFS10 (RDF Schema). These languages were not expressive enough to capture the meaning required to support machine understand- ability, however, so one requirement was additional expressive power. The goal in choosing the language elements was to include the commonly used modeling primitives from object-oriented systems and frame-based systems. Finally, the com- munity recognized the importance of a strong formal foundation for the language. Description Logics as a ﬁeld has had a long history of providing a formal foundation for a family of frame languages. DL languages add constructors into a language only after researchers specify and analyze the meaning of the terms and their com- putational effect on systems built to reason with them. The DAML community wanted to include the strong formal foundations of Description Logics in order to provide a web language that could be understood and extended. The initial DAML web ontology language (DAML-ONT) was released publicly in October 2000. While the language design attempted to meet all of the design goals, beginning with the web-centric vision and later incorporating some DL aspects, the decision was made that a timely release of the initial language was more critical than a timely integration of a DL language with the web language. Thus the initial release focused more on the goals of web language compatibility and the inclusion of mainstream object-oriented and frame system constructors. Although some notions of DL languages and systems were integrated, the major integration happened in the next language release (DAML+OIL). Another important effort began at about the same time (in 1999) and produced a distributed language speciﬁcation prior11 to DAML-ONT called OIL. The aims of OIL’s developers were similar to those of the DAML group, i.e., to provide a foundation for the next generation of the web. Their initial objective was to create a web ontology language that combined the formal rigor of a Description Logic with the ontological primitives of object-oriented and frame-based systems. Like DAML-ONT, OIL had an RDFS-based syntax (as well as an XML syntax). However, the developers of OIL placed a stronger emphasis on formal foundations, and the language was explicitly designed so that its semantics could be speciﬁed via a mapping to the Description Logic SHIQ [Fensel et al., 2001; Horrocks et al., 1999]. It became obvious to both groups that their objectives could best be served by combining their efforts, the result being the merging of DAML-ONT and OIL to

9 http://www.w3.org/RDF/ 10 http://www.w3.org/TR/2000/CR-rdf-schema-20000327/ 11 Presentations of the language were made, for example, at the Dagstuhl Seminar on Semantics for the Web – htt // ti b / t /d t hl2000/

produce DAML+OIL. The merged language has a formal (model-theoretic) seman- tics that provides machine and human understandability, an axiomatization [Fikes and McGuinness, 2001] that provides machine operationalization with a speciﬁca- tion of valid inference “rules” in the form of axioms, and a reconciliation of the language constructors from the two languages.

14.3 OIL and DAML+OIL

14.3.1 OIL

The OIL language is designed to combine frame-like modeling primitives with the increased (in some respects) expressive power, formal rigor and automated reasoning services of an expressive Description Logic [Fensel et al., 2000]. OIL also comes “web enabled” by having both XML and RDFS based serializations (as well as a formally speciﬁed “human readable” form, which we will use here). The frame structure of OIL is based on XOL [Karp et al., 1999], an XML serializa- tion of the OKBC-like knowledge model (a simpliﬁed version of OKBC) [Chaudhri et al., 1998b]. In these languages classes (concepts) are described by frames, whose main components consist of a list of superclasses and a list of slot-ﬁller pairs. A slot corresponds to a role in a Description Logic, and a slot-ﬁller pair corresponds to either a value restriction (a concept of the form ∀R.C) or an existential quantiﬁca- tion (a concept of the form ∃R.C) – one of the criticisms leveled at frame languages is that they are often unclear as to exactly which of these is intended by a slot-ﬁller pair. OIL extends this basic frame syntax so that it can capture the full power of an expressive Description Logic. These extensions include:

r Arbitrary Boolean combinations of classes (called class expressions) can be formed, and used anywhere that a class name can be used. In particular, class expressions can be used as slot ﬁllers, whereas in typical frame languages slot ﬁllers are restricted to being class (or individual) names. r A slot-ﬁller pair (called a slot constraint) can itself be treated as a class: it can be used anywhere that a class name can be used, and can be combined with other classes in class expressions. r Class deﬁnitions (frames) have an (optional) additional ﬁeld that speciﬁes whether the class deﬁnition is primitive (a subsumption axiom) or non-primitive (an equivalence axiom). If omitted, this defaults to primitive. r Different types of slot constraint are provided, specifying value restriction, existential quantiﬁcation and various kinds of cardinality constraint.12

12 Some frame languages also provide this feature, referring to such slot constraints as facets [Chaudhri et al., 1998b G l 1999]

r Global slot deﬁnitions are extended to allow the speciﬁcation of superslots (subsuming slots) and of properties such as transitive and symmetrical. r Unlike many frame languages, OIL has no restriction on the ordering of class and slot deﬁnitions, so classes and slots can be used before they are “deﬁned”. This means that OIL ontologies can contain cycles. r In addition to standard class deﬁnitions (frames), which can be seen as DL axioms of the form CN ⊑C and CN ≡C where CN is a concept name, OIL also provides axioms for asserting disjointness, equivalence and coverings with respect to class expressions. This is equivalent to providing general inclusion (or equivalence) axioms, i.e., axioms of the form C ⊑D (C ≡D), where both C and D may be non-atomic concepts.

Many of these points are standard for a Description Logic (e.g., treating ∀R.C and ∃R.C as classes), but are novel for a frame language. OIL is also more restrictive than typical frame languages in some respects. In particular, it does not support collection types other than sets (e.g., lists or bags), and itdoesnotsupportthespeciﬁcationofdefaultﬁllers.Theserestrictionsarenecessary in order to maintain the formal properties of the language (e.g., monotonicity) and the correspondence with Description Logics (see Chapter 2). In order to allow users to choose the expressive power appropriate to their ap- plication, and to allow for future extensions, a layered family of OIL languages has been described. The base layer, called “Core OIL” [Bechhofer et al., 2000], is a cut-down version of the language that closely corresponds with RDFS (i.e., it includes only class and slot inclusion axioms, and slot range and domain con- straints13). The standard language, as described here, is called “Standard OIL”, and when extended with ABox axioms (i.e., the ability to assert that individuals and tuples are, respectively, instances of classes and slots), is called “Instance OIL”. Finally, “Heavy OIL” is the name given to a further layer that will include as yet unspeciﬁed language extensions. We will only consider Standard OIL in this chapter: Core OIL is too weak to be of much interest, Heavy OIL has yet to be speciﬁed, and Instance OIL adds nothing but ABox axioms. Moreover, it is unclear if adding ABox axioms to OIL would be particularly useful as RDF already provides the means to assert relationships between(pairsof)webresourcesandtheslotsandclassesdeﬁnedinOILontologies. Figure 14.1 illustrates an OIL ontology (using the human readable serialization) corresponding to an example terminology from Chapter 2. The structure of the language will be described in detail in Subsection 14.3.1.1. A full speciﬁcation of OIL, including DTDs for the XML and RDFS serializations, can be found in [Horrocks et al., 2000a] and on the OIL web site.14

13 Constraining the range (resp. domain) of a slot SN to class C is equivalent to a DL axiom of the form ⊤⊑∀SN .C (resp. ∃SN .⊤⊑C). 14 h // k l d / il/

name “Family” documentation “Example ontology describing family relationships” definitions slot-def hasChild inverse isChildOf class-def defined Woman subclass-of Person Female class-def defined Man subclass-of Person not Woman class-def defined Mother subclass-of Woman slot-constraint hasChild has-value Person class-def defined Father subclass-of Man slot-constraint hasChild has-value Person class-def defined Parent subclass-of or Father Mother class-def defined Grandmother subclass-of Mother slot-constraint hasChild has-value Parent class-def defined MotherWithManyChildren subclass-of Mother slot-constraint hasChild min-cardinality 3 class-def defined MotherWithoutDaughter subclass-of Mother slot-constraint hasChild value-type not Woman

Fig. 14.1. OIL “family” ontology.

14.3.1.1 OIL syntax and semantics

OIL can be seen as a syntactic variant of the Description Logic SHIQ [Horrocks et al., 1999] extended with simple concrete datatypes [Baader and Hanschke, 1991a; Horrocks and Sattler, 2001]; we will call this DL SHIQ(D). Rather than providing the usual model-theoretic semantics, OIL deﬁnes a translation σ(·) that maps an OIL ontology into an equivalent SHIQ(D) terminology. From this mapping, OIL derives both a clear semantics and a means to exploit the reasoning services of DL systems such as Fact [Horrocks, 1998b] and Racer [Haarslev and M¨oller, 2001e] that implement (most of) SHIQ(D). The translation is quite straightforward and follows directly from the syntax and informal speciﬁcation of OIL. The single exception is in the treatment of OIL’s one-of constructor. This is not treated like the DL one-of constructor described in Chapter 2, but is mapped to a disjunction of specially introduced disjoint primitive concepts corresponding to the individual names in the one of

construct, i.e., individuals are treated as primitive concepts, and there is an implicit unique name assumption. This was a pragmatic decision based on the fact that reasoning with individuals in concept descriptions is known to be of very high complexity (for a Description Logic as expressive as OIL), and is beyond the scope of any implemented DL system – in fact a practical algorithm for such a Description Logic has yet to be described [Horrocks and Sattler, 2001]. This treatment of the one-of constructor is not without precedent in DL systems: a similar approach was taken in the Classic system [Borgida and Patel-Schneider, 1994]. An OIL ontology consists of a container followed by a list of deﬁnitions. The container consists of Dublin Core compliant documentation ﬁelds specifying, e.g., the title and subject of the ontology. It is ignored by the translation, and will not be considered here. Deﬁnitions can be either class deﬁnitions, axioms, slot deﬁnitions or import statements, the latter simply specifying (by URI) other ontologies whose deﬁnitions should be teated as being lexically included in the current one. We will, therefore, treat an OIL ontology as a list A1, . . . , An, where each Ai is either a class deﬁnition, an axiom or a slot deﬁnition. This list of deﬁnitions/axioms is translated into a SHIQ(D) terminology T (a set of axioms) as follows:



σ(A1, . . . , An) = {σ(A1), . . . , σ(An)} ∪ 

j<k≤m {Pj ⊑¬Pk}

1≤j<m

where i1, . . . , im are the individuals used in the ontology, and Pi is the SHIQ(D) primitive concept used to represent i.

Class deﬁnitions An OIL class deﬁnition (class-def) consists of an optional keyword K followed by a class name CN , an optional documentation string, and a class description D. If K = primitive, or if K is omitted, then the class deﬁnition corresponds to a DL axiom of the form CN ⊑D. If K = defined, then the class deﬁnition corresponds to a DL axiom of the form CN ≡D. A class description consists of an optional subclass-of component, with a list of one or more class expressions, followed by a list of zero or more slot-constraints. Each slot constraint can specify a list of constraints that apply to the given slot, e.g., value restrictions and existential quantiﬁcations. The set of class expressions and slot constraints is treated as an implicit conjunction. The complete mapping from OIL class deﬁnitions to SHIQ(D) axioms is given in Figure 14.2, where CN is a class or concept name and C is a class expression.

Slot constraints A slot-constraint consists of a slot name followed by a list of one or more constraints that apply to the slot. A constraint can be either:

r A has-value constraint with a list of one or more class-expressions or datatype e pressions

OIL SHIQ(D) class-def (primitive | defined) CN CN (⊑| ≡) ⊤ subclass-of C1 . . . Cn ⊓σ(C1) ⊓. . . ⊓σ(Cn) slot-constraint1 ⊓σ(slot-constraint1) ... ... slot-constraintm σ(slot-constraintm)

Fig. 14.2. OIL to SHIQ(D) mapping (class deﬁnitions).

OIL SHIQ(D) slot-constraint SN ⊤ has-value C1 . . . Cn ⊓∃SN .σ(C1) ⊓. . . ⊓∃SN .σ(Cn) value-type C1 . . . Cn ⊓∀SN .σ(C1) ⊓. . . ⊓∀SN .σ(Cn) max-cardinality n C ⊓⩽n SN .σ(C) min-cardinality n C

n C ⊓⩾n SN .σ(C) cardinality ⊓⩾n SN .σ(C) ⊓⩽n SN.σ(C) has-filler i1 . . . dn SN .σ(one-of i1) . . . SN .σ(equal dn)

Fig. 14.3. OIL to SHIQ(D) mapping (slot constraints).

r A value-type constraint with a list of one or more class-expressions or datatype expressions. r A max-cardinality, min-cardinality or cardinality constraint with a non-negative integer followed (optionally) by either a class expression or a datatype expression. r A has-filler constraint with a list of one or more individual names or data values.

OIL has-value and value-type constraints correspond to DL existential quan- tiﬁcations and value restrictions respectively. OIL cardinality constraints corre- spond to DL qualiﬁed number restrictions, where the qualifying concept is taken to be ⊤if the class expression is omitted. In order to maintain the decidability of the language, cardinality constraints can only be applied to simple slots, a simple slot being one that is neither transitive nor has any transitive subslots [Horrocks et al., 1999] (note that the transitivity of a slot can be inferred, e.g., from the fact that the inverse of the slot is a transitive slot). An OIL has-filler constraint is equivalent to a set of has-value constraints where each individual i is transformed into a class expression of the form one-of i and each data value d is transformed into a datatype of the form equal d. The complete mapping from OIL slot constraints to SHIQ(D) concepts is given in Figure 14.3, where SN is a slot or role name, C is a class expression or datatype, i is an individual and d is a data value (i.e., a string or an integer).

Class expressions One of the key features of OIL is that, in contrast to standard frame languages, class expressions are used instead of class names, e.g., in the list of superclasses or in slot constraints A class expression is either a class name

OIL SHIQ(D) top ⊤ thing ⊤ bottom ⊥ and C1 . . . Cn σ(C1) ⊓. . . ⊓σ(Cn) or C1 . . . Cn σ(C1) ⊔. . . ⊔σ(Cn) not C ¬σ(C) one-of i1 . . . in Pi1 . . . Pin

Fig. 14.4. OIL to SHIQ(D) mapping (class expressions).

CN , an enumerated class, a slot-constraint, a conjunction of class expressions (written and C1 . . . Cn), a disjunction of class expressions (written or C1 . . . Cn) or a negated class expression (written not C). The class names top, thing and bottom have pre-deﬁned interpretations: top and thing are interpreted as the most general class (⊤), while bottom is interpreted as the inconsistent class (⊥). Note that top and bottom can just be considered as abbreviations for the class expressions (or C (not C)) and (and (C not C)) respectively (for some arbitrary class C). An enumerated class consists of a list of individual names, written one-of i1. . . in. As already noted, this is not treated like the DL one-of con- structor described in Chapter 2, but is mapped to a disjunction of disjoint primitive concepts corresponding to the individual names. The complete mapping from OIL class expressions to SHIQ(D) concepts is given in Figure 14.4, where C is a class expression, i is an individual and Pi is the primitive concept corresponding to the individual i.

Datatypes In OIL slot constraints, datatypes and values can be used as well as or instead of class expressions and individuals. Datatypes can be either integer (i.e., the entire range of integer values), string (i.e., the entire range of string values), a subrange deﬁned by a unary predicate such as less-than 10 or a Boolean combination of datatypes [Horrocks and Sattler, 2001]. The complete mapping from OIL datatypes to SHIQ(D) concepts is given in Figure 14.5, where d is a data value (an integer or a string), C is a datatype and ⩾d (resp. ⩽d, >d, <d) is a unary predicate that returns true for all integers greater than or equal to (resp. less than or equal to, greater than, less than) d.

Axioms In addition to class deﬁnitions, OIL includes four kinds of axiom:

disjoint C1 . . . Cn asserts that the class expressions C1, . . . , Cn are pairwise dis- joint. covered C by C1 . . . Cn asserts that the class expression C is covered (subsumed) by the union of class expressions C C

OIL SHIQ(D) min d ⩾d max d ⩽d greater-than d >d less-than d <d equal d ⩾d ⊓⩽d range d1 d2 ⩾d1 ⊓⩽d2 and C1 . . . Cn σ(C1) ⊓. . . ⊓σ(Cn) or C1 . . . Cn σ(C1) ⊔. . . ⊔σ(Cn) not C σ(C)

Fig. 14.5. OIL to SHIQ(D) mapping (datatypes).

OIL SHIQ(D) disjoint C1 . . . Cn σ(C1) ⊑¬(σ(C2) ⊔. . . ⊔σ(Cn)) ... σ(Cn−1) ⊑¬σ(Cn) covered C by C1 . . . Cn σ(C) ⊑σ(C1) ⊔. . . ⊔σ(Cn) disjoint-covered C by C1 . . . Cn σ(C) ⊑σ(C1) ⊔. . . ⊔σ(Cn) σ(C1) ⊑¬(σ(C2) ⊔. . . ⊔σ(Cn)) ... σ(Cn−1) ⊑¬σ(Cn) equivalent C1 . . . Cn σ(C1) σ(C2), . . . , σ(Cn 1) σ(Cn)

Fig. 14.6. OIL to SHIQ(D) mapping (axioms).

disjoint-covered C by C1 . . . Cn asserts that the class expression C is covered (subsumed) by the union of class expressions C1, . . . , Cn, and that C1, . . . , Cn are pairwise disjoint. equivalent C1 . . . Cn assertsthattheclassexpressionsC1, . . . , Cn areequivalent.

The complete mapping from OIL axioms to SHIQ(D) axioms is given in Figure 14.6, where C is a class expression.

Slot deﬁnitions An OIL slot deﬁnition (slot-def) consists of a slot name SN followed by an optional documentation string and a slot description. A slot descrip- tion consists of an optional subslot-of component, with a list of one or more slot names, followed by a list of zero or more global slot constraints (e.g., domain and range constraints) and properties (e.g., transitive and functional). The complete mapping from OIL slot deﬁnitions to SHIQ(D) axioms is given in Figure 14.7, where SN and RN are slot or role names, C is a class expression and R+ is the set of SHIQ(D) transitive role names.

The mapping from OIL to SHIQ(D) has now been fully speciﬁed and we can illustrate, in Figure 14.8, the SHIQ(D) ontology corresponding to the OIL ontology from Figure 14 1

OIL SHIQ(D) slot-def SN subslot-of RN 1 . . . RN n SN ⊑RN 1, . . . , SN ⊑RN n domain C1 . . . Cn ∃SN .⊤⊑σ(C1) ⊓. . . ⊓σ(Cn) range C1 . . . Cn ⊤⊑∀SN .σ(C1) ⊓. . . ⊓σ(Cn) inverse RN SN −⊑RN, RN −⊑SN properties transitive SN ∈R+ properties symmetric SN ⊑SN −, SN −⊑SN properties functional 1 SN

Fig. 14.7. OIL to SHIQ(D) mapping (slot deﬁnitions).

hasChild isChildOf isChildOf− ⊑ hasChild Woman ≡ Person ⊓Female Man ≡ Person ⊓¬Woman Mother ≡ Woman ⊓∃hasChild.Person Father ≡ Man ⊓∃hasChild.Person Parent ≡ Father ⊔Mother Grandmother ≡ Mother ⊓∃hasChild.Parent MotherWithManyChildren ≡ Mother ⊓⩾3 hasChild MotherWithoutDaughter Mother hasChild. Woman

Fig. 14.8. SHIQ(D) equivalent of the “family” ontology.

14.3.1.2 XML and RDFS serializations for OIL

The above language description uses OIL’s “human readable” serialization. This aids readability, but is not suitable for publishing ontologies on the web. For this purpose OIL is also provided with both XML and RDFS serializations. OIL’s XML serialization directly corresponds with the human readable form: Figure 14.9 illustrates the XML serialization of a fragment of the “family” ontology. A full speciﬁcation and XML DTD can found in [Horrocks et al., 2000a]. The RDFS serialization is more interesting as it uses the features of RDFS both to capture as much as possible of OIL ontologies and to deﬁne a “meta-ontology” describing the structure of the OIL language itself. Figure 14.10 shows part of the RDFS description of OIL. The second and third lines contain XML namespace deﬁnitions that make the external RDF and RDFS deﬁnitions available for local use by preceding them with rdf: and rdfs: respectively. There then follows a “meta-ontology” describing (part of) the structure of OIL slot constraints. The “meta-ontology” deﬁnes hasPropertyRestriction as an instance of RDFS ConstraintProperty15 that connects an RDFS class (the prop- erty’s domain) to an OIL property restriction (the property’s range). A PropertyRestriction (slot constraint) is then deﬁned as a kind of ClassExpression, with HasValue (an existential quantiﬁcation) being a kind

15 P t i th RDF f bi l ti lik l t l

<ontology> <ontology-definitions>

<slot-def> <slot name="hasChild"/> <inverse> <slot name="isChildOf"/> </inverse> </slot-def>

<class-def type="defined"> <class name="Woman"/> <subclass-of> <class name="Person"/> <class name="Female"/> </subclass-of> </class-def>

<class-def type="defined"> <class name="Man"/> <subclass-of> <class name="Person"/> <NOT> <class name="Woman"/> </NOT> </subclass-of> </class-def>

<class-def type="defined"> <class name="Mother"/> <subclass-of> <class name="Woman"/> </subclass-of> <slot-constraint> <slot name="hasChild"/> <has-value> <class name="Person"/> </has-value> </slot-constraint> </class-def>

</ontology-definitions> </ontology>

Fig. 14.9. OIL XML serialization.

of PropertyRestriction. Properties onProperty and toClass are then de- ﬁned as “meta-slots” of PropertyRestriction whose ﬁllers will be the name of the property (slot) to be restricted and the restriction class expression. The complete description of OIL in RDFS, as well as a more detailed description of RDF and RDFS, can be found in [Horrocks et al., 2000a]. Figure 14.11 illustrates the RDFS serialization of a fragment of the “family” ontology Note that most of the ontology consists of standard RDFS For example in

<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">

<rdf:Property rdf:ID="hasPropertyRestriction"> <rdf:type rdf:resource= "http://www.w3.org/2000/01/rdf-schema#ConstraintProperty"/> <rdfs:domain rdf:resource= "http://www.w3.org/2000/01/rdf-schema#Class"/> <rdfs:range rdf:resource="#PropertyRestriction"/> </rdf:Property>

<rdfs:Class rdf:ID="PropertyRestriction"> <rdfs:subClassOf rdf:resource="#ClassExpression"/> </rdfs:Class>

<rdfs:Class rdf:ID="HasValue"> <rdfs:subClassOf rdf:resource="#PropertyRestriction"/> </rdfs:Class>

<rdf:Property rdf:ID="onProperty"> <rdfs:domain rdf:resource="#PropertyRestriction"/> <rdfs:range rdf:resource= "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property"/> </rdf:Property>

<rdf:Property rdf:ID="toClass"> <rdfs:domain rdf:resource="#PropertyRestriction"/> <rdfs:range rdf:resource="#ClassExpression"/> </rdf:Property>

</rdf:RDF>

Fig. 14.10. Part of the deﬁnition of OIL in RDFS.

thedeﬁnitionofWomanRDFSisusedtospecifythatitisasubClassOfbothPerson and Female. Additional OIL speciﬁc vocabulary is only used where necessary, e.g., to specify that Woman is a deﬁned class. The advantage of this is that much of the ontology’s meaning would still be accessible to software that was “RDFS aware” but not “OIL aware”.

14.3.2 DAML+OIL

DAML+OIL is similar to OIL in many respects, but is more tightly integrated with RDFS, which provides the only speciﬁcation of the language and its only serializa- tion. While the dependence on RDFS has some advantages in terms of the re-use of existing RDFS infrastructure and the portability of DAML+OIL ontologies, using RDFS to completely deﬁne the structure of DAML+OIL is quite difﬁcult as, unlike XML, RDFS is not designed for the precise speciﬁcation of syntactic structure. For example, there is no way in RDFS to state that a restriction (slot constraint) should consist of exactly one property (slot) and one class

<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:oil="http://www.ontoknolwedge.org/oil/rdfschema">

<rdf:Property rdf:ID="hasChild"> <oil:inverseRelationOf rdf:resource="#isChildOf"/> </rdf:Property> <rdf:Property rdf:ID="isChildOf"/>

<rdfs:Class rdf:ID="Woman"> <rdf:type rdf:resource= "http://www.ontoknowledge.org/oil/rdfs-schema/#DefinedClass"/> <rdfs:subClassOf rdf:resource="#Person"/> <rdfs:subClassOf rdf:resource="#Female"/> </rdfs:Class>

<rdfs:Class rdf:ID="Man"> <rdf:type rdf:resource= "http://www.ontoknowledge.org/oil/rdfs-schema/#DefinedClass"/> <rdfs:subClassOf rdf:resource="#Person"/> <rdfs:subClassOf> <oil:Not> <oil:hasOperand rdf:resource="#Woman"/> </oil:Not> </rdfs:subClassOf> </rdfs:Class>

<rdfs:Class rdf:ID="Mother"> <rdf:type rdf:resource= "http://www.ontoknowledge.org/oil/rdfs-schema/#DefinedClass"/> <rdfs:subClassOf rdf:resource="#Woman"/> <oil:hasPropertyRestriction> <oil:HasValue> <oil:onProperty rdf:resource="#hasChild"/> <oil:toClass rdf:resource="#Person"/> </oil:HasValue> </oil:hasPropertyRestriction> </rdfs:Class>

</rdf:RDF>

Fig. 14.11. OIL RDFS serialization.

The solution to this problem adopted by DAML+OIL is to deﬁne the semantic of the language in such a way that it gives a meaning to any (parts of) ontologies that conform to the RDFS speciﬁcation, including “strange” constructs such as slot constraints with multiple slots and classes. This is made easier by the fact that, unlike OIL, the semantics of DAML+OIL is directly deﬁned in both a model- theoretic and an axiomatic form (using KIF [Genesereth and Fikes, 1992]). The meaning given to strange constructs may, however, include strange “side effects”. For example, in the case of a slot constraint with multiple slots and classes, the semantics interprets this in the same way as a conjunction of all the constraints

that would result from taking the cross product of the speciﬁed slots and classes, but with the added (and possibly unexpected) effect that all these slot constraints must have the same interpretation (i.e., are equivalent). Although OIL’s RDFS- based syntax would seem to be susceptible to the same difﬁculties, in the case of OIL there does not seem to be an assumption that any ontology conforming to the RDFS meta-description would be a valid OIL ontology – presumably ontologies containing unexpected usages of the meta-properties would be rejected by OIL processors as the semantics does not specify how these could be translated into SHIQ(D). DAML+OIL’s dependence on RDFS also has consequences for the decidability of the language. In OIL, the language speciﬁcation states that the slots used in cardinality constraints can only be applied to simple slots (slots that are neither transitive nor have transitive subslots). There is no way to capture this constraint in RDFS (although the language speciﬁcation does include a warning about the problem), so DAML+OIL is theoretically undecidable. In practice, however, this may not be a very serious problem as it would be easy for a DAML+OIL proces- sor to detect the occurrence of such a constraint and warn the user of the conse- quences. Another effect of DAML+OIL’s tight integration with RDFS is that the frame structure of OIL’s syntax is much less evident: a DAML+OIL ontology is more DL- like in that it consists largely of a relatively unstructured collection of subsumption and equality axioms. This can make it more difﬁcult to use DAML+OIL with frame-based tools such as Prot´eg´e [Grosso et al., 1999] or OilEd [Bechhofer et al., 2001b] because the axioms may be susceptible to many different frame-like groupings [Bechhofer et al., 2001a]. From the point of view of language constructs, the differences between OIL and DAML+OIL are relatively trivial. Although there is some difference in “keyword” vocabulary, there is usually a one-to-one mapping of constructors, and in the cases where the constructors are not completely equivalent, simple translations are pos- sible. For example, DAML+OIL restrictions (slot constraints) use has-class and to-class where OIL uses ValueType and HasValue, and while DAML+OIL has no direct equivalent to OIL’s covering axioms, the same effects can be achieved using a combination of (disjoint) union and subClass. The similarities can clearly be seen in Figure 14.12, which illustrates the DAML+OIL version of the “family” ontology fragment from Figure 14.9. The treatment of individuals in DAML+OIL is, however, very different from that in OIL. In the ﬁrst place, DAML+OIL relies wholly on RDF for ABox as- sertions, i.e., axioms asserting the type (class) of an individual or a relationship between a pair of individuals. In the second place, DAML+OIL treats individu- als occurring in the ontology (in oneOf constructs or has Value restrictions) as

<daml:ObjectProperty rdf:ID="hasChild"> <daml:inverseOf rdf:resource="#isChildOf"/> </daml:ObjectProperty> <daml:Class rdf:ID="Woman"> <daml:intersectionOf rdf:parseType="daml:collection"> <daml:Class rdf:about="#Person"/> <daml:Class rdf:about="#Female"/> </daml:intersectionOf> </daml:Class> <daml:Class rdf:ID="Man"> <daml:intersectionOf rdf:parseType="daml:collection"> <daml:Class rdf:about="#Person"/> <daml:Class> <daml:complementOf rdf:resource="#Woman"/> </daml:Class> </daml:intersectionOf> </daml:Class> <daml:Class rdf:ID="Mother"> <daml:intersectionOf rdf:parseType="daml:collection"> <daml:Class rdf:about="#Woman"/> <daml:Restriction> <daml:onProperty rdf:resource="#hasChild"/> <daml:hasClass rdf:resource="#Person"/> </daml:Restriction> </daml:intersectionOf> </daml:Class>

Fig. 14.12. DAML+OIL ontology serialization.

true individuals (i.e., interpreted as single elements in the domain of discourse) and not as primitive concepts as is the case in OIL (see Chapter 2). Moreover, there is no unique name assumption: in DAML+OIL it is possible to explicitly assert that two individuals are the same or different, or to leave their relationship unspeciﬁed. This treatment of individuals is very powerful, and justiﬁes intuitive inferences that would not be valid for OIL, e.g., that persons all of whose countries of residence are Italy are kinds of person that have at most one country of residence:

Person ⊓∀residence.{Italy} ⊑⩽1 residence.

Unfortunately, the combination of individuals with inverse roles is so powerful that no “practical” decision procedure (for satisﬁability/subsumption) is currently known, and there is no implemented system that can provide sound and complete reasoning for the whole DAML+OIL language. In the absence of inverse roles, however, a tableau algorithm has been devised [Horrocks and Sattler, 2001], and in the absence of individuals DAML+OIL ontologies can exploit implemented DL systems via a translation into SHIQ similar to the one described for OIL. It would, of course, also be possible to translate DAML+OIL ontologies into SHIQ using the disjoint primitive concept interpretation of individuals adopted by OIL but in

this case reasoning with individuals would not be sound and complete with respect to the semantics of the language.

14.3.2.1 DAML+OIL datatypes

The initial release of DAML+OIL did not include any speciﬁcation of datatypes. However, in the March 2001 release,16 the language was extended with arbitrary datatypes from the XML Schema type system,17 which can be used in restrictions (slot constraints) and range constraints. As in SHOQ(D) [Horrocks and Sattler, 2001], a clean separation is maintained between instances of “object” classes (de- ﬁned using the ontology language) and instances of datatypes (deﬁned using the XML Schema type system). In particular, it is assumed that the domain of interpre- tation of object classes is disjoint from the domain of interpretation of datatypes, so that an instance of an object class (e.g., the individual Italy) can never have the same interpretation as a value of a datatype (e.g., the integer 5), and that the set of object properties (which map individuals to individuals) is disjoint from the set of datatype properties (which map individuals to datatype values). The disjointness of object and datatype domains was motivated by both philo- sophical and pragmatic considerations:

r Datatypes are considered to be already sufﬁciently structured by the built-in predicates, and it is, therefore, not appropriate to form new classes of datatype values using the ontology language [Hollunder and Baader, 1991b]. r The simplicity and compactness of the ontology language are not compromised – even enumerating all the XML Schema datatypes would add greatly to its complexity, while adding a theory for each datatype, even if it were possible, would lead to a language of monumental proportions. r The semantic integrity of the language is not compromised – deﬁning theories for all the XML Schema datatypes would be difﬁcult or impossible without extending the language in directions whose semantics may be difﬁcult to capture in the existing framework. r The “implementability” of the language is not compromised – a hybrid reasoner can easily be implemented by combining a reasoner for the “object” language with one capable of deciding satisﬁability questions with respect to conjunctions of (possibly negated) datatypes [Horrocks and Sattler, 2001].

From a theoretical point of view, this design means that the ontology language can specify constraints on data values, but as data values can never be instances of object classes they cannot apply additional constraints to elements of the object domain. This allows the type system to be extended without having any impact on the object class (ontology) language, and vice versa. Similarly, reasoning components can be independently developed and trivially combined to give a hybrid reasoner

16 http://www.daml.org/2001/03/daml+oil-index.html 17 h // 3 /TR/ l h 2/#

whose properties are determined by those of the two components; in particular, the combined reasoner will be sound and complete if both components are sound and complete. From a practical point of view, DAML+OIL implementations can choose to support some or all of the XML Schema datatypes. For supported datatypes, they can either implement their own type checker/validater or rely on some external component (non-supported datatypes could be either trapped as an error or ignored). The job of a type checker/validater is simply to take zero or more data values and one or more datatypes, and determine if there exists any data value that is equal to every one of the speciﬁed data values and is an instance of every one of the speciﬁed datatypes.

14.4 Summary

It has long been realized that the web would beneﬁt from more structure, and it is widely agreed that ontologies will play a key role in providing this structure. De- scription Logics have made important contributions to research in this area, ranging from formal foundations and early web applications through to the development of DL-based languages designed to facilitate the development and deployment of web ontologies. OIL and its successor DAML+OIL are two such ontology languages, speciﬁcally designed for use on the web; they exploit existing web standards (XML, RDF and RDFS), adding the formal rigor of a Description Logic and the ontological primitives of object-oriented and frame-based systems. This combination of features has proved very attractive, and DAML+OIL has already been widely adopted. At the time of writing, the DAML ontology li- brary contains over 175 ontologies, and DAML crawlers have found millions of DAML+OIL markup statements in documents. Possibly more important, however, is that some major projects have committed themselves to encoding their ontolo- gies in DAML+OIL. This has been particularly evident in the bio-ontology domain, where the Bio-Ontology Consortium has speciﬁed DAML+OIL as their ontology exchangelanguage,andtheGeneOntology[TheGeneOntologyConsortium,2000] is being migrated to DAML+OIL in a project partially funded by GlaxoSmithKline Pharmaceuticals in cooperation with the Gene Ontology Consortium. There has also been signiﬁcant progress in the development of tools support- ing DAML+OIL. Several DAML+OIL ontology editors are now available includ- ing Manchester University’s OilEd (which incorporates reasoning support from the Fact system) [Bechhofer et al., 2001b], Prot´eg´e [Grosso et al., 1999] and OntoEdit [Staab and Maedche, 2000]. At Stanford University, a combination of Ontolingua, Chimaera and JTP (Java Theorem Prover) is being used to provide editing evolution maintenance and reasoning services for DAML+OIL

ontologies [McGuinness et al., 2000b; 2000a]. Commercial endeavors are also sup- porting DAML+OIL. Network Inference Limited, for example, have developed a DAML+OIL reasoning engine based on their own implementation of a DL reasoner. What of the future? The development of the semantic web, and of web on- tology languages, presents many opportunities and challenges for DL research. A “practical” (satisﬁability/subsumption) algorithm for the full DAML+OIL lan- guage has yet to be developed, and even for OIL, it is not yet clear that sound and complete DL reasoners can provide adequate performance for typical web ap- plications. It is also unclear how a DL system would cope with the very large ABoxes that could result from the use of ontologies to add semantic markup to (large numbers of) web pages. DL researchers are also beginning to address new inference problems that may be important in providing reasoning services for the semantic web, e.g., querying [Rousset, 1999a; Calvanese et al., 1999a; Horrocks and Tessaris, 2000], matching [Baader et al., 1999a] and computing least common subsumers and most speciﬁc concepts [Cohen et al., 1992; Baader and K¨usters, 1998; Baader et al., 1999b]. Finally, the developers of both OIL and DAML+OIL always understood that a single language would not be adequate for all semantic web applications – OIL even gave a name (Heavy OIL) to an as yet undeﬁned extension of the language – and extensions up to (at least) full ﬁrst-order logic are already being discussed. Clearly, most of these extended languages will be undecidable. DL research can, however, still make important contributions, e.g., by investigating the boundaries of decidability, identifying decidable subsets of extended languages and developing decision procedures. DL implementations can also play a key role, both as reasoning engines for the core language and as efﬁcient components of hybrid reasoners dealing with a variety of language extensions.

Acknowledgements

We would like to thank J´erˆome Euzenat and Frank van Harmelen for their insightful comments on a previous version of the chapter. All remaining errors are, of course, our own.

15

Natural Language Processing

ENRICO FRANCONI

Abstract

In most natural language processing applications, Description Logics have been used to encode in a knowledge base some syntactic, semantic, and pragmatic ele- ments needed to drive the semantic interpretation and the natural language genera- tion processes. More recently, Description Logics have been used to fully charac- terize the semantic issues involved in the interpretation phase. In this chapter the various proposals that have appeared in the literature about the use of Description Logics for natural language processing will be analyzed.

15.1 Introduction

Since the early days of the Kl-One system, one of the main applications of De- scription Logics has been for semantic interpretation in natural language processing [Brachman et al., 1979]. Semantic interpretation is the derivation process from the syntactic analysis of an utterance to its logical form—intended here as the repre- sentation of its literal deep and context-dependent meaning. Typically, Description Logics have been used to encode in a knowledge base both syntactic and seman- tic elements needed to drive the semantic interpretation process. One part of the knowledge base constitutes the lexical semantics knowledge, relating words and their syntactic properties to concept structures, while the other part describes the contextual and domain knowledge, giving a deep meaning to concepts. By devel- oping this idea further, a considerable part of the research effort has been devoted to the development of linguistically motivated ontologies, i.e., large knowledge bases where both concepts closely related to lexemes and domain concepts coexist. Logical forms and various kinds of internal semantics representations based on Description Logics may also provide the basis for further computational process- ing such as representing common meanings in machine translation applications

generating coherent text starting from its semantic content, answering database queries, and dialog management. After a big success in the 1980s and the beginning of the 1990s (see, e.g., the collection of papers in [Sowa, 1991]), the interest of the applied computational linguistic community in Description Logics began to drop, as did its interest in well-founded theories on syntax or semantics. At the time of writing this chapter, there is no major applied project in natural language processing making use of Description Logics. This is due to the positive achievements in real applications of the systems based on shallow analysis and statistical approaches to semantics, initiated by the applications in the message understanding area. In this chapter the basic uses of Description Logics for natural language process- ing will be analyzed, together with a little bit of history, and the role of Description Logics in the current state of the art in computational linguistics will be pointed out. Obviously, space constraints will lead to several omissions and over-simpliﬁcations.

15.2 Semantic interpretation

In order to understand the role of Description Logics in semantic interpretation, let us ﬁrst introduce a general setting for the process of deriving a logical form of an utterance. A basic property of a logical form as a semantic representation of a natural language constituent—such as a noun phrase (NP) or a verb phrase (VP)—is com- positionality, i.e., the semantic representation of a constituent is a function of the semantic interpretation of its subconstituents. Thus, a close correspondence be- tween syntactic structure and logical form is allowed. In this way, a parser working according to some grammar rules can incrementally build up the semantic inter- pretation of an utterance using the corresponding lexical semantic rules of logical composition—specifying how the logical terms associated to the subconstituents are to be combined in order to give the formula for the constituent. Thus, each lex- eme has an associated (possibly complex) logical term, which forms its contribution to the meaning of the utterance it is part of. In the context of such a formalism, an effective semantic lexical discrimination process could be carried out during parsing, by cutting out the exponential factor due to the explicit treatment all the possible derivations. Semantically implausible interpretations can be discarded, by checking—whenever the parser tries to build a constituent—the inconsistency of the logical form compositionally obtained at that stage. This leaves out many syntactically plausible but semantically implausible interpretations. Such a discrimination step is highly effective in restricted domain applications, where knowledge of the world considerably reduces the number of possible models Clearly the more the contextual and domain knowledge is taken

into consideration when evaluating a logical form, the more effective is the dis- crimination process. Thus, consistency checking of logical forms plays the role of a generalized selectional restrictions mechanism. But what is the relationship between a syntactic constituent and its range of pos- sible lexical semantic contributions? The conceptual content of a lexeme should convey both the lexical relations—such as, for example, synonymy, hyponymy, incompatibility—and the subcategorization information about the expected argu- ments (aka complements) of the lexical entry. For example the verb paint may be conceptualized as an event having an agent thematic role corresponding to the subject syntactic argument, with a speciﬁed selectional restriction being the con- cept animate. It is important to distinguish the syntactic information—such as the lexical relations and the subcategorization frame constraining the complements to have speciﬁc syntactic structures—from the semantic information—such as the thematic roles and their selectional restrictions. A semantic lexical entry will spec- ify the appropriate mappings between the syntactic structure of the lexeme and the conceptual information. The situation is, of course, a bit more complex, since, for example, there is no direct obvious conceptual content to lexemes belonging to particular syntac- tic categories like adjectives or adverbs. Moreover there is a distinction between complements (which are considered as internal arguments) and adjuncts (which are considered as modiﬁers). It is outside the scope of this chapter to analyze the correspondence between syntax and semantics and its compositional nature (see, e.g., [Jackendoff, 1990; Pustejovsky, 1988]). For example, the sentence “A painter paints a fresco” involves the concepts Painter, Fresco, and Paint, where the concept Paint has two thematic roles as- sociated to it, an agent and a goal, with the concepts Animate and Inanimate as respective selectional restrictions. Moreover, the conceptualizations should include the facts that a Painter is a subconcept of Animate, a Fresco is a subconcept of Inanimate, and the concepts Animate and Inanimate are disjoint. This information is enough, for example, to validate the above sentence, while it would discard as semantically implausible the sentence “A fresco paints a painter”. This conceptu- alization and its relationship with the lexical knowledge can be encoded in a DL knowledge base. Many studies have been done about building a good DL knowledge base for nat- ural language processing (also called ontology) [Bateman, 1990; Hovy and Knight, 1993; Knight and Luk, 1994; Bateman et al., 1995]—see also Chapter 14. A good linguistically motivated ontology ought to be partitioned into a language-dependent but domain-independent part (the upper model) and a language-independent but domain-dependent part (the domain model)—but this result is theoretically very hard to achieve [Bateman 1990; Lang 1991] A good linguistically motivated

ontology should be used both for semantic interpretation and for natural language generation (see Section 15.4). The conceptualization in the ontology should be at a level of granularity which may depend on the application: if selectional restrictions are too speciﬁc, disambiguation is achieved, but probably many correct sentences will be rejected (e.g., the sentences involving some form of metaphor, type shifting, or metonymy); if selectional restrictions are too general, the opposite problem may appear. In principle, a good linguistically motivated ontology should be abstract, large-scale, reusable. However, these goals are very hard to achieve since they con- ﬂict with the practical need to implement effective and discriminating ontologies in specialized domains. The ideas just sketched form the theoretical background of any application of Description Logics for semantic interpretation, since the early works where Kl-One was involved [Bobrow and Webber, 1980; Sondheimer et al., 1984; Brachman and Schmolze, 1985; Jacobs, 1991]. Every realized system relies on the so-called multilevel semantics architecture [Lavelli et al., 1992], where a se- quence of processing phases is distinguished:

r Lexical discrimination: whenever the parser tries to build a constituent, the consistency of the semantic part of such a constituent is checked. In parallel, a ﬁrst logical form is built up—where references and quantiﬁer scoping are still ambiguous—expressing the meaning of the sentence in the most specialized way with respect to the semantic lexicon and the background knowledge. Heuristics is applied to the minimal form in order to obtain a preferential ordering of the semantically consistent but still lexically ambiguous interpretations. r Anaphora and quantiﬁer scoping resolution: the semantically plausible referents for lin- guistic expressions such as deﬁnite NPs, pronouns and deictic references are identiﬁed, and the scope of quantiﬁers is resolved by making explicit the different unambiguous interpretations. Syntax-based heuristics are used to cut down the various derivations to a unique unambiguous one. r Contextual interpretation: decides how to react in a given dialogic situation, considering the type of request, the context, and the model of the user interest. It makes use of knowledge about the speech acts, the dialog and the user model.

It has to be emphasized that all the approaches aim at deriving a unique un- ambiguous logical form. For this purpose, the logical form is treated as a mere compositionally obtained data structure on which to operate ad hoc algorithms for solving ambiguities, with the support of the information represented in the knowl- edge base. There is no attempt to give a logic-based semantics to the “logical form” during the disambiguation phases. The role of Description Logics is thus limited to serving a lexically motivated knowledge base, which is used for building the logical form. Some approaches purport to represent the logical form itself as DL assertions, but in fact they use it just as a support for somehow computing the real logical form

Section 15.3 will discuss the few DL-based well-founded approaches, where the whole semantic interpretation process has been given a logical foundation. A number of recent important projects involving Description Logics for semantic interpretation are listed below.

r The Janus system [Weischedel, 1989], where the consistency check of the selectional restrictions was implemented as a double up-and-down subsumption check. r The Xtra system [Allgayer et al., 1989], proposing a clear distinction between the do- main independent linguistically motivated part of the knowledge base (called Functional- Semantic Structure, FSS), and the domain-dependent part (called Conceptual Knowledge Base, CKB) modeling the knowledge of an underlying expert system. r The Pracma project [Fehrer et al., 1994], in which an expressive Description Logic has been studied to support special inferences such as probabilistic reasoning, non-monotonic reasoning, and abductive reasoning. r The Lilog project [Herzog and Rollinger, 1991], funded by IBM, a very ambitious research project for studying the logical foundations of the semantics of natural language, with an emphasis on computational aspects. The project belongs to the category of projects where the whole semantic interpretation process has been given a logical foundation—by means of a sorted ﬁrst-order logic. However, the role of Description Logics is again just as a knowledge server during the various interpretation and disambiguation phases. r The AlFresco system, a multi-modal dialog prototype for the exploration of fourteenth century Italian painters and frescoes [Stock et al., 1991; 1993], and the natural language interface for the concierge of the system Maia, a mobile robot with intelligent capabilitiesin the domain of ofﬁce activities [Samek-Lodovici and Strapparava, 1990; Lavelli et al., 1992; Franconi, 1994]. These systems are characterized by the presence of natural language dialogs, so that logical form becomes central to conveying the meaning for the evolving behavior of the system. r The Verbmobil project [Wahlster, 2000], a large speech-to-speech translation project, with translations in to German, English, and Japanese. In Verbmobil, the role of Description Logics is limited to the off-line pre-computation of a taxonomy of concepts with thematic roles and selectional restrictions, which are then used by ad hoc rules during the runtime disambiguation phase. r The Ford Direct Labor Management System (DLMS) [Rychtyckyj, 1996; 1999] is one of the few industrial level examples of a DL-based application involving natural language. DLMS utilizes a DL knowledge base in a fairly standard way to build the semantic interpretation of process sheets—natural language documents containing speciﬁc information about work instructions—and to generate from them structured descriptions of the parts and the tools required for allocating labor at the car plant ﬂoor.

15.3 Reasoning with the logical form

Traditionally, the logical form has been considered in computational linguistics as only representing the literal—i.e., context independent—meaning of an utterance,

as clearly distinguished from the representation of the surface syntactic constituent structure, and from a deeper semantic representation, which is a function of dis- course context and world knowledge. Thus, the logical form plays in these cases an intermediate role between syntax and the deep semantics, and it is therefore not intended to fully contain the meaning in context of the utterance. Moreover, quite often a further distinction is introduced between quasi logical forms—i.e., literal under-speciﬁed semantic representations—and proper logical forms—i.e., literal unambiguous derivations. The reasons for separating the literal under-speciﬁed, the literal unambiguous, and the deep meaning representations are mainly pragmatic rather than theoretical. Pure linguists would say that any sentence has just one unambiguous meaning, and that any ambiguity is introduced by under-constraining the interpretation process— e.g., by not adequately considering the context knowledge. In such a case, they would speak of different possible ending paths in the derivation (i.e., interpreta- tion) process, each one of them being again unambiguous. Clearly, this approach is infeasible from a computational point of view: ﬁrst, because the number of deriva- tions might combinatorially increase; and secondly because the interdependencies among the derivations are lost. On the other hand, computational linguists consider ambiguities as part of the meaning of utterances, with the ultimate goal of being able to reason with such under-speciﬁed expressions, in order to increase compactness in the representation and efﬁciency in the processing. Allen [1993] argues that

. . . one of the crucial issues facing future natural language systems is the develop- ment of knowledge representation formalisms that can effectively handle ambiguity.

We can identify two main approaches. The classical computational approaches— like the ones described above—rely on the modularity of the semantic analysis process—the multilevel semantics architecture—starting from the under-speciﬁed representation and ending up with an unambiguous and context-dependent rep- resentation. The semantics-oriented approaches usually propose a very expressive logical language—possibly with an expressivity greater than ﬁrst-order logic—with thegoalofgivingaclearsemanticstomanynaturallanguagephenomena,andinpar- ticulartoambiguitiesandunder-speciﬁcation.Ambiguitiescanberoughlyclassiﬁed as follows: lexical ambiguities introduced by, e.g., prepositions, nouns, and verbs; structural ambiguities such as PP-attachment ambiguities—involving prepositional phrases; referential ambiguities such as quantiﬁcation scoping and anaphora. A disadvantage of the ﬁrst approach is that there are no solid formal grounds for the proper use of the logical form, and in particular for the treatment of am- biguity, so that operations on the logical form are often based on heuristics and ad hoc procedures. This can be justiﬁed by the fact that reasoning on logical forms

including—among other things—domain knowledge, incomplete and ambiguous terms, unsolved references, and under-speciﬁed quantiﬁcations, is considered a hard computational task. Computational linguists have devised structural process- ing techniques based on syntax, selectional restrictions, case grammars, and struc- tured information such as frames and type hierarchies—carefully trying to avoid or to drastically reduce the inclusion in the computational machinery of logical inference mechanisms for treating ambiguities. Of course, these techniques often need ad hoc mechanisms when such ambiguities come into play. The computational approach is an example of “knowledge representation as engineering”. On the other hand, a number of recent works in applying Description Logics to natural language processing ([Quantz, 1995; Franconi, 1996; Ludwig et al., 2000]) are getting closer to a semantics-oriented approach, but they follow a minimalist conceptualization, and they emphasize the computational aspects. Instead of trying to solve sophisticated semantic problems of natural language, they try to logically reconstruct some basic issues in a general way, which is compositional, homoge- neous, principled, and interesting from an applicative point of view. The main idea of these approaches is to take logical forms seriously: they represent not only the literal meaning of the fragment but also lexical ambiguities, represent unresolved referents via variables and equality, interpret plural entities and (generalized) quan- tiﬁers, and are linked to a rich theory of the domain. To that end, an expressive logical language should have a proper reasoning mechanism, and nonetheless be compositional. In this section an abstract overview will be given by means of examples, in such a way that, we believe, common ideas will be captured. Let us ﬁrst try to understand how a logical form can be characterized in terms of proper logical constructs. It is observed that, assuming the widely accepted Davidsonian view on eventualities, natural language phrases—such as a NP or a VP—explicitly introduce discourse referents stating the existence of individuals or events of the domain model. Introduced referents are represented as existentially quantiﬁed variables. The possibility of having variables and constants allows for the representation of referential ambiguities. This is the basis of most works on logical formalizations of the logical form. For example, the NP A fresco of Giotto might be given the logical form

∃b. Fresco(b) ∧of(b, GIOTTO)

while the NP A fresco painted by Giotto might be given the logical form

∃b, e. Fresco(b) ∧Paint(e) ∧agent(e, GIOTTO) ∧goal(e, b). (15.1)

As we have pointed out above, consistency checking of a (partial) logical form corresponding to a constituent may help in the semantic discrimination process

Thus, in a restricted application domain, we would like to discard a sentence like A fresco paints Giotto, since its logical form

∃b, e. Fresco(b) ∧Paint(e) ∧agent(e, b) ∧goal(e, GIOTTO)

would be inconsistent with respect to a general domain theory of frescoes and animate things that we could attach to the lexicon:

∀x, y. Paint(x) →(agent(x, y) →Animate(y)) ∀x. Animate(x) →¬Inanimate(x) ∀x. Fresco(x) →Inanimate(x).

Such an axiomatic theory plays the role of meaning postulates for the predicates appearing in the logical form; they can be also considered as a set of predicate level axioms. Using a DL-based formalism, this will be written as the following theory:

Paint ⊑∀agent.Animate Animate ⊑¬Inanimate Fresco ⊑Inanimate.

This is the place where Description Logics play a formal role as general domain theories representing the basic ontological properties of common-sense domain knowledge. Let us consider the deep meaning of A fresco of Giotto. The NP is ambiguous (at least) with respect to the two readings A fresco painted by Giotto and A fresco owned by Giotto. We could reformulate the ambiguous logical form, by enumer- ating the unambiguous derivations, i.e., by disjoining the logical forms of the two readings. However, it is infeasible to explicitly enumerate all the (exponentially large) number of readings; moreover, this would not add any information to the logical form. Note however that traditional computational approaches purport to always ﬁnd a unique unambiguous representation for the ﬁnal logical form, based on syntactically and contextually motivated heuristics; in this case, the enumeration will be the basis for an ad hoc preferential ordering. If the logical form is written instead as

∃b. Fresco(b) ∧(paintedBy ⊔ownedBy)(b, GIOTTO) (15.2)

then each of the two readings clearly entails this ambiguous (or, better, under- speciﬁed) representation. Of course, the use of an explicit disjunction to encode the ambiguity requires a particular treatment of the natural language negation, which cannot be represented as a classical negation in the logical form. In fact, derivations from the ambiguous content are independent traces and, for example, De Morgan’s law would not hold anymore. The treatment of natural language negation has never been considered in DL based approaches So we assume the logical form

to be always positive; of course, this is not necessary for the DL-based domain theory. In this way, the lexicon—which can be considered as an associated theory—may contain a meaning postulate for the relation of:

∀x, y. of(x, y) ↔paintedBy(x, y) ∨ownedBy(x, y)

which can be rewritten using Description Logics as

of ≡paintedBy ⊔ownedBy.

Moreover, if one writes reiﬁcation axioms (see [Franconi and Rabito, 1994]) of the kind

∀x, y. paintedBy(y, x) ↔∃z. Paint(z) ∧agent(z, x) ∧goal(z, y)

then the logical form (15.1) with the explicit event also entails the ambiguous representation (15.2). In Description Logics, this would be written as

paintedBy ≡goal−|Paint ◦agent.

The ambiguity of A fresco of Giotto can be monotonically reﬁned later on in the dialog by uttering, e.g., either Giotto painted the fresco in Siena or Giotto sold his fresco. The reﬁnement process is monotonic, since it is not necessary to revise the knowledge asserted by means of the logical form (15.2). Lexical ambiguities of nouns can also be represented, as in the example The pilot was out—where pilot can be a small ﬂame used to start a furnace, or a person who ﬂies airplanes. The sentence He was on the toilet monotonically reﬁnes the previous one, because the pronoun he may refer only to a person, thus excluding the reading with ﬂame. Of course, in order to make possible such a reasoning by cases, axioms at the predicate level having negation and, more generally, partitioning capabilities have to be added to the theory—specifying and reducing the possible models:

Pilot ≡Flame ⊔Aviator Flame ⊑Process Aviator ⊑Human Human ⊑Animate Animate ⊓Process ⊑⊥.

Verb ambiguity is also captured in the same manner. For example, it is possible to rule out the sentence The door opens the door, given the two senses of open as “cause to open”—transitive, with an animate agent—and “become open”— intransitive. According to these two senses, both the constituents “The door opens” and “opens the door” are consistent but the whole sentence is inconsistent

Talking brieﬂy about structural ambiguities, a general theory of common-sense knowledge will allow only for one interpretation of Giotto paints the fresco with a brush where the PP attaches to the painting event—“paints with a brush”— ruling out the interpretation “the fresco representing a brush”. An early detection of the semantic inconsistency solving the PP-attachment problem is very important in practical applications, since the non-deterministic choice among the different interpretations is usually left to the parser. Thus, the parser does not need to compute a combinatorial number of derivations. Clearly, any metaphoric aspect of language is excluded in these approaches. Following a semantics-oriented approach as sketched in this section, Quantz [1993; 1995] proposes a preferential DL-based approach to disambigua- tion in natural language processing. He gives a particular emphasis to the problem of anaphora resolution, showing that an adequate disambiguation strategy has to be based on factors which take globally into account heterogeneous information (e.g., from syntax, semantics, domain knowledge) and yield preferences with vary- ing degrees of relevance. For this purpose, Quantz introduced and developed a sound and complete proof theory for a preferential Description Logic, including a non-monotonic extension with weighted defaults. In his approach, a DL theory comprises syntactic, semantic, domain, and pragmatic knowledge, which globally contributes to the preferential disambiguation process, following the proposal by [Hobbs et al., 1993]. Franconi [1996] proposes a formalism based on expressive Description Logics complemented with the ability to express logical forms as conjunctive queries [Calvanese et al., 1998a], i.e., formulae in the conjunctive existential fragment of ﬁrst-order logic. The formalism allows for both under-speciﬁed semantic repre- sentations and encapsulation of contextual and domain knowledge in the form of meaning postulates. In particular, lexical ambiguities, structural ambiguities, and quantiﬁcation scoping ambiguities [Franconi, 1993] are considered, and an ac- count of the structure of events and processes in terms of tense and aspect is given [Franconi et al., 1993; 1994]. It is shown how to apply this logic for lexical dis- crimination based on semantic knowledge. Ludwig et al. [2000] present a modiﬁed version of Discourse Representation Theory (DRT) and show that its Discourse Representation Structures (DRSs) may be expressed as assertional statements in a Description Logic. This allows lexical discrimination during the parsing process based on the domain model. In order to capture situations where the available information is insufﬁcient to characterize the meaning of an utterance, a partial logic (called ﬁrst-order ionic logic) is introduced to represent and reason with the logical form. The approach combines in an ele- gant way linguistic and contextual semantics—both represented in the DL domain model

15.4 Knowledge-based natural language generation

In the previous sections an architecture for semantic interpretation was introduced, where Description Logics were used to build a knowledge base with lexical and conceptual information. The knowledge base encodes the necessary data for build- ing the logical form from the analysis of some natural language text. In this section we mention another task which makes use of the same body of knowl- edge expressed in a DL-based ontology, but with the dual goal of generating a coherent (multi-sentential) natural language text, starting from an abstract non- linguistic speciﬁcation of its meaning. Examples are in the context of dialogs (see, e.g., [Stock et al., 1991; 1993]), of natural language instructions (see, e.g., [Moore and Paris, 1993; Di Eugenio, 1994; 1998; Paris and Vander Linden, 1996a; 1996b]), of language translation (see, e.g., [Dorr, 1992; Dorr and Voss, 1993; 1995; Knight et al., 1995; Quantz and Schmitz, 1994; Wahlster, 2000]), or of multimedia presentations (see, e.g., [Wahlster et al., 1993; Andr´e and Rist, 1995; Andr´e et al., 1996]). The lexical and conceptual knowledge base classiﬁer is the main driving compo- nent for the algorithms used to solve the problem of lexical choice, i.e., the task of choosing an appropriate target language term in generating text from an underlying logical form [Dorr et al., 1994; Stede, 1999]. The lexicalization problem is a non- trivial one, since it is possible to have alternative lexical choices covering various (overlapping) parts of the content representation—a translation divergence—or it may be necessary to change the conveyed information content in order to ﬁnd a viable lexical choice—a translation mismatch. The problem is usually solved by using ad hoc algorithms which make use of the classiﬁer for determining which lexical units can potentially be used to express parts of the logical form representing the content. The choice and the realization of the most appropriate verbalization should be made in the context of the previous utterances (in the case of a dialog), of the surrounding environment (in the case of multimedia presentation), and of the overall goal of the ongoing communicative act. For these tasks, it is not enough to have an underlying representation of the content of the text to be generated, but a pragmatic aspect has to be considered as well. The prag- matic knowledge about the rhetorical interrelationships which occur among the various parts of the broader linguistic and extra-linguistic context of the com- munication is needed to generate a coherent presentation in agreement with its communicative goals. In other words, on the one hand there is the con- tent to be presented, on the other hand there is the style of its presentation which should use the most appropriate linguistic expressions to convey the message.

In order to generate a text satisfying the communicative goals and the coherence requirements, a planning algorithm is used to generate an overall structured text (or discourse) strategy, giving the general shape of the text. Using the lexical and conceptual information in the knowledge base, the planner—by taking into account the grammar of the target language—converts the text plans into a specialized unambiguous representation of the semantic and syntactic information necessary to select the appropriate target language terms [Moore and Paris, 1993; Paris and Vander Linden, 1996b].

16

Description Logics for Databases

ALEX BORGIDA MAURIZIO LENZERINI RICCARDO ROSATI

Abstract

In contrast to the relatively complex information that can be expressed in DL ABoxes (which we might call knowledge or information), databases and other sources such as ﬁles, semistructured data, and the World Wide Web provide rather simpler data, which must however be managed effectively. This chapter surveys the major classes of application of Description Logics and their reasoning facil- ities to the issues of data management, including: (i) expressing the conceptual domain model/ontology of the data source, (ii) integrating multiple data sources, and (iii) expressing and evaluating queries. In each case we utilize the standard properties of Description Logics, such as the ability to express ontologies at a level closer to that of human conceptualization (e.g., representing conceptual schemas), determining consistency of descriptions (e.g., determining if a query or the inte- gration of some schemas is consistent), and automatically classifying descriptions that are deﬁnitions (e.g., queries are really deﬁnitions, so we can classify them and determine subsumption between them).

16.1 Introduction

According to [ElMasri and Navathe, 1994], a database is a coherent collection of related data, which have some “inherent meaning”. Databases are similar to knowledge bases because they are usually used to maintain models of some universe of discourse (UofD). Of course, the purpose of such computer mod- els is to support end-users in ﬁnding out things about the world, and therefore it is important to maintain an up-to-date and error-free model. The main differ- ence between databases and knowledge bases is that while the former concen- trate on manipulating large and persistent models of relatively simple data, the latter provide more support for inference ﬁnding answers about the model

which had not been explicitly told to it – and involve fewer but more complex data. Following the functional view of knowledge bases advocated by Levesque, we expect a number of operations that can be applied to the KB, such as define, tell, and ask. Each of these operations involves one or more languages, such as the schema/constraint language, the update language, the query language and the answer language. In an earlier paper surveying the application of Description Logics to data management [Borgida, 1995], it has been argued that Description Logics offer advantages for each of these languages, as well as the internal processing of queries. We begin by providing a review of the important notions involving databases, their development and use, in preparation for examining the application of Descrip- tion Logics in these tasks. First, one needs to describe the UofD about which the database will be knowl- edgeable. This is a form of requirements speciﬁcation, which is normally under- taken using some high-level language, because the requirements will have to be understandable both to end-users and implementors, so they can agree on the goals. In databases, the best known such language is the Entity-Relationship (ER) data model,1 but many other so-called semantic modeling languages have been pro- posed [Hull and King, 1987]. The ER data model will be described in considerable detail and precision in Section 16.2; for now, sufﬁce it to say that it views the world as populated by entities, which are related to each other by n-ary relationships, and are described by attributes having atomic values. Note that a semantic model may be concerned with the UofD as well as the data to be stored in the computer, and consists of mostly time-invariant generic information (e.g., “every department has exactly one manager”) as opposed to speciﬁc facts (e.g., “Edna manages the shipping department”). The semantic model introduces the terms to be used in talk- ing about the domain, and captures their meaning by their interrelationships and constraints on them. From this generic description of the UofD, the database designer develops a log- ical schema, describing the structure of data stored in the database, including the data types, interconnections, and constraints that must hold. Different data models are used for this purpose, but the relational data model has become the logical model of choice. While in the semantic modeling phase the emphasis was on a natural and direct mapping to the UofD, in this case the driving force is the exis- tence of large software systems called Database Management Systems (DBMSs), which support the management of the data in the model. For example, the rela- tional data model views data as being stored in the form of tables/relations, with

1 Th t “d t d l” f t l t f t f d ibi l f d t b

rows/tuples containing primitive data types (e.g., integers, strings). In this case, the schema contains, among other things, the name of each table, with its columns and their datatype. For example, table Supplies may have columns for the material, the supplier, the recipient, as well as the shipment date and the amount of material supplied. Relational DBMSs require that each table be given a subset of attributes (called a “key”) which uniquely identiﬁes each tuple. DBMSs may offer additional ways to capture integrity constraints – assertions distinguishing valid from invalid states of the data. More recently, Object-Oriented DBMSs have been developed. These support the management of persistent objects with intrinsic identity, which can be related to (collections of) other objects, not just atomic values. Such OO-DBMSs can be used, among other things, for providing persistence for object-oriented languages. Object-oriented languages and databases also support the notion of “method” or procedure attached to a class, as well as implementation encapsulation, but these aspects will not be considered in this chapter. The database is used of course to store facts about the (current) state of the world. Databases make the so-called “closed world assumption”, which states that a fact is false unless it has been explicitly stated as true. This assumption works well, with the restriction that the database represents only a very lim- ited form of partial information. In particular, databases do not allow the repre- sentation of disjunctive information, and support only a very limited form of ex- istential quantiﬁcation: if there is no information about an attribute, it is given the null value. In order to provide access to the data stored in databases, DBMSs support a variety of query languages – languages for specifying declaratively what data is to be retrieved. For relational databases, SQL is the practical query language of choice. However, from the theoretical point of view, ﬁrst-order logic formulae with free variables are a much more elegant form, based on the observation that tables can be viewed as predicates. For example,

∃m, d1, d2. supplies(′intel′,r, m, d1) ∧supplies(′intel′,r, m, d2) ∧(d2 ̸= d1)

would be asking for recipients (values of the free variable r) who had received from ′intel′ shipments of the same material (m) on different dates (d1, d2). Query languages of varying expressive power can be obtained by restrict- ing or extending the above “standard”. For example, the so-called “conjunctive” or “select–join–project” queries only allow formulas with existential quantiﬁers and conjunction, while Datalog is a query language that permits the use of intermediate tables derived using Horn rules, and thereby supports recursion [Ullman 1988] For example if we want to describe when one company depends

on another through a chain of suppliers, we could state the rules2

dependsOn(x, y) ← supplies(x, y, m, d). dependsOn(x, y) ← supplies(x, z, m, d, a) ∧dependsOn(z, y, m2, d2, a2).

In many DBMSs, the result of a query is another structure of the kind found in the schema (e.g., relational queries return tables as answers). In some situations, either because a query is asked frequently or because we want to restrict the access of some users to a subset of the database, a query can be named, in which case it is called a view. If a view is materialized, then its value is stored rather than re-computed on demand, and it is kept correct after every update to the basic database. The DBMS performs a number of hidden functions, insulating users from the considerable details of the physical level. For example, the DBMS places the incoming data physically onto storage media, and provides data structures and other information that permits efﬁcient access to certain data at some later point of time. In particular, given a query, the DBMS attempts to optimize the time in which it is answered by looking at access structures available and statistical information, and using the ability to reformulate queries into other, equivalent ones. Over time, additional, more complex kinds of databases and DBMSs have ap- peared. For example, distributed databases keep information at a variety of sites connected by networks (e.g., so that data might be closer to where it is used most frequently). Note however that the user is unaware of this detail, and perceives a single database. Heterogeneous and federated databases are collections of indepen- dent databases which choose to share information but are maintained autonomously. Users may even be interested in obtaining information from all kinds of sources, including non-databases such as ﬁles, etc. In such situations, a signiﬁcant problem is relating the logical schemas at the various sites in order to provide a schema that can be presented to the user. The rest of the chapter is devoted to showing a variety of roles that Description Logics (and reasoning with them) can play in database management. In particular, in Section 16.2 we take a detailed look at their use in semantic/conceptual modeling. We then examine the possible uses of Description Logics in querying and query processing in Section 16.3, while in Section 16.4 we will consider the utility of Description Logics in providing integrated access to multiple information sources. We summarize the material in Section 16.5.

16.2 Data models and Description Logics

Recall that a “data model” is essentially a language or set of concepts for describing a class of certain kinds of databases. This section attempts to answer

2 V i bl i l th i ht h d id f “ ” d t b i t ti ll tiﬁd

some questions about the relationship between data models and Description Logics:

What are some examples of such relationships? First, we will consider in de- tail the translation of Entity-Relationship models into knowledge bases ex- pressedintheDLRDescriptionLogic.InSubsection16.2.5,wewillconsider more cursorily several other data models, such as OODB and semistructured data. How are relationships established? The answer is by (i) formalizing the data model(ERinthiscase),(ii)choosinganappropriateDescriptionLogic(DLR in this case), (iii) deﬁning a translation function from the former to the latter, and (iv) proving that this translation is “information-preserving” (not done here, but detailed in [Calvanese et al., 1999e]). What beneﬁts can be derived from having established relationships? Most signiﬁcant is the use of automated DL reasoning services to support the development and maintenance of correct models (Subsection 16.2.4). In addition, since Description Logics are often more expressive, it is possible to suggest extensions to database data models that allow further information about the structure of the data to be captured (Subsection 16.2.3).

16.2.1 The Entity-Relationship model

In order to talk about the relationship between the Entity-Relationship (ER) model and Description Logics, it is necessary ﬁrst to introduce the reader to the ER data model (see also Subsection 4.3.1 and Chapter 10). ER is the most widespread semantic data model, and it has become a standard, extensively used in the design phase of commercial applications. The ER model was introduced in [Chen, 1976], with minor variants and extensions proposed over the years (e.g., [Teorey, 1989; Batini et al., 1992; Thalheim, 1992; 1993]). The basic elements of the ER model are entities, relationships, and attributes. An entity set (or simply entity) denotes a set of objects, called its instances, that have common properties. Elementary properties are modeled through attributes, whose values belong to one of several pre-deﬁned domains, such as Integer, String, or Boolean. Properties that are due to relations to other entities are modeled through the participation of the entity in relationships. A relationship set (or simply relation) denotes a set of tuples (also called its instances), each of which repre- sents an association among a different combination of instances of the entities that participate in the relationship. Since each entity can participate in a relationship more than once (e.g., a company can be the recipient or sender in a “supply” rela- tionship) the notion of ER role is introduced to represent such a participation

Service

3 2

1

Client

CONTRACT

LOCATION/String

1 2

REG−AT

Department

1 2

PROMOTION

PrDept

Fig. 16.1. Example of an ER schema.

and a distinguishing identiﬁer within the relationship is assigned to it. The arity of a relationship is the number of its ER-roles. We assume that, for each relationship of arity n, the identiﬁers 1, . . . , n are assigned to the roles of the relationship. An entity B is said to be a specialization or IS-A of another entity A, if all the instances of B are also instances of A. Relationships can be similarly related by IS-A. This induces an inheritance of the attributes of an entity to its subentities, and of the roles of a relationship to its subroles. The ER schema produced as a result of ER modeling is usually represented in a graphical notation, which is particularly useful for an easy visualization of the data dependencies. In the commonly accepted notation, entities are represented as boxes, whereas relationships are represented as diamonds. An attribute is shown as a circle attached to the entity for which it is deﬁned. ER-roles are graphically depicted by connecting the relationship to the participating entities, and labeling the edges with the corresponding role identiﬁer. An IS-A relation between two entities is denoted by an arrow from the more speciﬁc to the more general entity (analogously for IS-A relations between two relationships). Cardinality constraints can be attached to an ER-role in order to restrict the number of times each instance of an entity is allowed to participate via that ER-role in instances of the relationship. Such constraints can be used to specify both existence dependencies and func- tionality of relations [Cosmadakis and Kanellakis, 1986]. They are often used only in a restricted form, where the minimum cardinality is either 0 or 1 and the max- imum cardinality is either 1 or ∞. Cardinality constraints in the form considered here have already been introduced in [Abrial, 1974], and subsequently studied in [Grant and Minker, 1984; Lenzerini and Nobili, 1990; Ferg, 1991; Ye et al., 1994; Thalheim, 1992; Calvanese and Lenzerini, 1994b]. An example of an ER schema is reported in Figure 16.1. Such a schema mod- els information handled by an enterprise about contracts between customers and

departments for services, and about registration of customers at departments. Some customers may be registered at “promotion departments”. For the purpose of relating the ER model to Description Logics it is better to have a more formal description, which also abstracts out the most important common characteristics present in the different variants. An ER schema S is constructed starting from pairwise disjoint sets of entity symbols, relationship symbols, ER-role symbols, attribute symbols, and domain symbols. Each domain symbol D has an associated predeﬁned basic domain DBD, and we assume the basic domains to be pairwise disjoint. For each entity symbol, a setofattributesymbolsisdeﬁned,andtoeachsuchattributeauniquedomainsymbol is associated. A relationship symbol of arity n has n associated ER-role symbols, each with an associated entity symbol, and deﬁnes a relationship between these entities. We assume that each ER-role symbol belongs to a unique relationship, thus determining also a unique entity. The cardinality constraints are represented by two functions cminS, from ER-role symbols to nonnegative integers, and cmaxS, from ER-role symbols to positive integers union the special symbol ∞. IS-A relations between entities and between relationships are modeled by means of a binary relation ⪯S. We do not need to make any special assumption on the form of ⪯S, such as acyclicity or injectivity. The semantics of an ER schema can be given by specifying which database states are consistent with the information structure represented by the schema. Formally, a database state B corresponding to an ER schema S is constituted by a nonempty ﬁnite set B, assumed to be disjoint from all basic domains, and a function ·B that maps

r every domain symbol D to the corresponding basic domain DBD, r every entity E to a subset EB of B, r every attribute A to a set AB ⊆B ×  D∈DS DBD, and r every relationship R to a set RB of labeled tuples over B.

A labeled tuple over a domain B is a function from a set of ER-roles to B. The labeled tuple T that maps ER-role Ui to oi, for i ∈{1, . . . , n}, is denoted ⟨U1: o1, . . . , Un: on⟩. We also write T [Ui] to denote oi, and call it the Ui-component of T . The elements of EB, AB, and RB are called instances of E, A, and R respec- tively. A database state is considered acceptable if it satisﬁes all integrity constraints that are part of the schema. This is captured by the notion of legal database state. A database state B is legal for an ER schema S, if it satisﬁes the following condi- tions:

r For each pair of entities E1, E2 with E1 ⪯S E2, we have EB 1 ⊆EB 2 . r For each pair of relationships R R ith R ⪯ R e ha e RB ⊆RB

r For each entity E, if E has an attribute A with domain D, then for each instance e ∈EB

there is exactly one element a ∈AB with e as ﬁrst component, and the second component of a is an element of DBD. r For each relationship R of arity n between entities E1, . . . , En, to which R is con- nected by means of ER-roles U1, . . . , Un respectively, all instances of R are of the form ⟨U1: e1, . . . , Un: en⟩, where ei ∈EB i , i ∈{1, . . . , n}. r For each ER-role U of relationship R associated with entity E, and for each instance e of E, we have

cminS(U) ≤|{r ∈RB | r[U] = e}| ≤cmaxS(U).

16.2.2 Transforming Entity-Relationship schemas into DLR knowledge bases

In order to represent ER schemas in terms of DL knowledge bases, we make use of the Description Logic DLR, which has been formally introduced in Chapter 5. We recall here the syntax of DLR, which is a natural generalization of Description Logics to n-ary relations: in particular, atomic relations, of given arity between 2 and nmax, belong to the basic elements of DLR, and, besides concept expressions, arbitrary relation expressions can be formed, according to the following syntax:

R := ⊤n | P | ($i/n: C) | ¬R | R1 ⊓R2 C := ⊤1 | A | ¬C | C1 ⊓C2 | ∃[$i]R | ⩽k [$i]R

where P and R denote respectively atomic and arbitrary relations, i denotes com- ponents of relations, i.e., integers between 1 and nmax, n denotes the arity of a relation, i.e., an integer between 2 and nmax, and k denotes a nonnegative integer. In what follows, we abbreviate ($i/n: C) by ($i: C) when n is clear from the context. Moreover, we use the following abbreviations:

∀[$i]R for ¬∃[$i]¬R, ⩾(k + 1) [$i]R for ¬(⩽k [$i]R), = k [$i]R for (⩽(k + 1) [$i]R) ⊓(⩾k [$i]R).

In DLR, n-ary relations are interpreted as sets of tuples of arity n, and the DLR constructs generalize those of traditional Description Logics. In particular, besides the Boolean constructs on concepts and relations, the construct ($i/n: C) denotes all tuples of arity n in which the ith component is an instance of concept C, and thus represents a unary selection. The construct ∃[$i]R denotes all objects that participate as the ith component in a tuple of relation R, and thus represents a unary projection. Finally ⩽k [$i]R is a generalization of number restrictions to n-ary relations. We refer to Chapter 5, Section 5.7, for the formal semantics of the DLR constructs

We now show that the semantics of the ER model can be captured in DLR by deﬁning a translation φ from ER schemas to DLR knowledge bases, and then establishing a correspondence between legal database states and models of the derived knowledge base. In the following, for each relationship R of arity n in S, we denote by µR a mapping from the set of ER-roles associated with R to the integers 1, . . . , n. The knowledge base φ(S) derived from an ER schema S is deﬁned as follows:

r The set of atomic concepts of φ(S) consists of the set of entity and domain symbols in S.3 r The set of atomic relations of φ(S) is obtained from the set of relationship and attribute symbols in S. More speciﬁcally: – each symbol R in S, denoting a relation of arity n, is mapped into a symbol PR in φ(S), denoting a relation of arity n. – each attribute symbol A in S is mapped into a symbol PA in φ(S), denoting a relation of arity 2. Thus, each instance of the relation PA is a tuple such that its ﬁrst component corresponds to an entity, while the second component denotes an element of the concept corresponding to the attribute domain. r The set of inclusion axioms of φ(S) consists of the following elements: – for each pair of entities E1, E2 such that E1 ⪯S E2, the inclusion axiom

E1 ⊑E2

– for each pair of relationships R1, R2 such that R1 ⪯S R2, the inclusion axiom

PR1 ⊑PR2

– for each attribute A with domain D of an entity E, the inclusion axiom

E ⊑(∀[$1](PA ⊓($2: D))) ⊓= 1 [$1]PA

– for each relationship R of arity n with ER-roles U1, . . . , Un in which each Ui is asso- ciated with the entity Ei, the inclusion axiom

PR ⊑($µR(U1): E1) ⊓· · · ⊓($µR(Un): En)

– for each ER-role U of relationship R associated with entity E, with cardinality con- straints m = cminS(U) and n = cmaxS(U), ❜if m ̸= 0, the inclusion axiom

E ⊑⩾m [$µR(U)]PR ❜if n ̸= ∞, the inclusion axiom

E ⊑⩽n [$µR(U)]PR.

Based on the results presented in [Calvanese et al., 1999e], the correctness of the translation presented above can be formally proved. More speciﬁcally; let S be

3 F th k f i li it d l d i f ER h t i DLR

an ER schema. Then, there is a one-to-one correspondence between legal database states of S and models of the DLR knowledge base φ(S). For example, an entity E can be populated in a legal database state for S if and only if φ(S) admits a model in which E has a nonempty extension. This allows us to exploit reasoning techniques developed for the logic DLR in order to reason on ER schemas. For example, by applying the translation presented above to the ER schema in Figure 16.1, presented earlier, we obtain the following DLR knowledge base:

CONTRACT ⊑ ($1: Client) ⊓($2: Service) ⊓($3: Department) REG−AT ⊑ ($1: Client) ⊓($2: Department) PROMOTION ⊑ REG−AT ⊓($2: PrDept) Department ⊑ ∀[$1](LOCATION ⊓($2: String)) ⊓= 1 [$1]LOCATION PrDept ⊑ Department.

16.2.3 Additions to the Entity-Relationship model

The ER model does not provide several features which would prove useful in order to represent complex dependencies between data. On the other hand, the richness of constructs that is typical of Description Logics, and the correspondence between the two formalisms established in the previous subsection, makes it possible to add such constructs to the basic model and take them fully into account when reasoning on a schema. We provide several examples of useful additions to the basic ER Model that arise as a natural consequence of the correspondence with the Description Logic DLR. We also consider a feature of the original ER Model that appears to force DLR itself to be extended.

r Arbitrary Boolean constructs on entities. The only direct relationship between entities that can be expressed in the basic ER model is the IS-A relation. A common extension is by so-called generalization hierarchies (see e.g., [Batini et al., 1992]), which allow one to express that the extension of an entity should be the disjoint union of the extensions of other entities. Such construct can easily be translated by making use of union and negation of DLR. r Reﬁnement of properties along an IS-A hierarchy. Another important extension that should be considered is the ability to specify more complex forms of reﬁnement of properties of entities along IS-A hierarchies, than the mere addition of attributes. This is already an essential feature of the more recent object-oriented models. In particular, cardinality constraints could be reﬁned by restricting the range of values, and the participation in relationships can be restricted. One may require for speciﬁc instances of an entity that the objects they are related to via a certain relationship belong to a more speciﬁc entity than the one directly associated to the ER-role. Such forms of constraints can be naturally e pressed in DLR b making se of ni ersal q antiﬁcation o er relations

r Deﬁnitions of classes by means of complex properties. In the ER model (and more gener- ally in semantic data models) one can specify only necessary conditions that the instances of entities (or more generally classes) must satisfy. This means that in a database that conforms to the schema one cannot deduce that a certain object is an instance of an entity unless this fact is explicitly stated. When modeling a complex domain, however, in order to capture more precisely the intended semantics, one would like to be able to deﬁne classes of objects through necessary and sufﬁcient conditions, or even to state just sufﬁcient conditions for an object to be an instance of a class. The former correspond in fact to views, which are important parts of database schemas. By using the different types of axioms of DLR, necessary and sufﬁcient (and even just sufﬁcient) conditions can be easily imposed and become part of the schema. r Key constraints. Because of their utility in physical database design, even the original ER model allowed the speciﬁcation of key attributes/roles. Extending Description Logics with key constraints (roles which uniquely identify objects) has been the subject of several investigations [Borgida and Weddell, 1997]. In particular, Calvanese et al. [2000b] have shown that reasoning about DLR augmented by key constraints can be performed without increasing the worst-case computational complexity. r Temporal constraints. Recent efforts in the conceptual modeling community have been devoted to properly capturing time-varying information, and several proposals of tem- porally enhanced Entity-Relationship (ER) exist. [Artale and Franconi, 1999; 2001; Artale et al., 2001] provide a DL-based logical formalization of the various properties that characterize and extend different temporal ER models which are found in literature. In particular, [Artale et al., 2001] deﬁne the Description Logic DLRUS, an extension of DLR with temporal constructs, and study decidability and complexity of reasoning in such a logic.

16.2.4 Reasoning about Entity-Relationship schemas

Providing a formalization of the ER schema in terms of the logic DLR allows several forms of reasoning on the ER schema to be supported. Typical reasoning tasks at the conceptual level supporting the designer of an ER schema S (see [Calvanese et al., 1998e]) include:

r Entity satisﬁability, i.e., whether for every concept C, S admits a model in which it has a nonempty extension. If C must always have an empty extension then there is an inconsistency in its speciﬁcation, or at the very least the concept is inappropriately named since it is a synonym for “EmptyEntity”. r Relation satisﬁability, i.e., whether S admits a model in which a certain relation has a nonempty extension. (Similar to the above.) r Consistency of the ER schema, i.e., whether S admits a ﬁnite model. Without this, there is no database that satisﬁes the schema, which indicates that the totality of the deﬁni- tions is inconsistent or requires an inﬁnite model, which is a clear sign of incorrectness. Ideall thereasonings stemco ldpro ide pl ti s[McG innessandBorgida 1995;

Borgida et al., 2000] for the source of inconsistencies, which could focus the search for modiﬁcations. r Redundancy of the ER schema. Various forms of redundancy in the ER schema can be detected: e.g., if A, B are entities and both A ⊑B and B ⊑A hold, we can conclude that one of the entities is redundant. r Stronger constraints on relationship roles. The concept and relationship speciﬁcations may combine to yield stronger cardinality or domain constraints than those explicitly speciﬁed by the designer. (The simplest example is when we permit (multiple) inheri- tance.) r Entitysubsumption,i.e.,whethertheextensionofoneconcept B isasubsetoftheextension of another concept A in every model of S. This property suggests that the designer check for the possible omission of an explicit IS-A relationship between B and A. Alternatively, if conceptually all B’s are not supposed to be A’s, then something is wrong in the rest of the schema, since it is forcing an undesired conclusion. r Relation subsumption, i.e., whether the extension of one relation is a subset of the exten- sion of another relation in every model of S. (Similar to the above.)

Ideas such as the ones above have been been pursued, for example, within the DWQ European Project [Bouzeghoub et al., 1999], where the DL system Fact [Horrocks, 1998b] has been successfully used as reasoning tool supporting the analysis and the integration of diverse database conceptual schemas [Franconi and Ng, 2000].

16.2.5 Description Logics and other data models

Several other investigations have been carried out on the relationships between Description Logics and database models:

r [Bergamaschi and Nebel, 1994; Artale et al., 1996a; Calvanese et al., 1999e] provide formal models of object-oriented DBMSs using Description Logics. r [Borgida et al., 1989; Beck et al., 1989; Bergamaschi and Sartori, 1992] introduce se- mantic data models based directly on Description Logics, which are different from ER and previous database semantic data models. r More generally, class-based knowledge representation schemes, such as semantic net- works, conceptual structures and frames [Lehmann, 1992; Sowa, 1991] have been con- sidered as database models, or as ways to enrich the deductive capabilities of data models. These are related to Description Logics as suggested in Chapter 4.

A recent important development in the ﬁeld of data management has been the need to represent data whose structure is less rigid and strict than that held in con- ventional databases. Such semistructured data are important in many application areas, such as web information systems, biological databases, and digital libraries. Semistructured data is neither raw text nor strictly typed as in conventional database

systems [Abiteboul, 1997]. In many recent formalisms, semistructured data is mod- eled by graphs with labeled edges, where the label keeps information on both the values and the schema of the data. Many authors have noticed that this model co- incides with the ontology of Description Logics, where roles correspond to edges. In [Calvanese et al., 1998c] it is shown that expressive Description Logics can not only capture semistructured data schemas, but can also add the ability to express several new kinds of constraints. The same kind of investigation has been carried out in [Calvanese et al., 1999d] for the case of the XML language, which is cur- rently a very popular formalism for semistructured data on the web (see Chapter 4, Subsection 4.3.3 for more details).

16.3 Description Logics and database querying

We have seen that descriptions can be used to present the schema of a database. For example, to emulate object-oriented databases, classes are equated with primitive concepts, while type restrictions on attributes are presented as necessary conditions that apply to these primitive classes in the form of role restrictions. In addition, certain integrity constraints can be expressed as rules of the form “if C then D”, or axioms C ⊑D. On the other hand, since a concept description provides necessary and sufﬁcient conditions for objects to satisfy it, it is natural to treat it as a query. So, in systems like Classic [Borgida et al., 1989] and Candide [Beck et al., 1989], we have a uniﬁcation of two traditionally distinct languages: the data deﬁnition and data manipulation languages.

16.3.1 Description Logics as query languages

Once the query is viewed as a concept description, we can perform the standard operations on it. For example, the query description can be compared to the in- consistent description. If they are equivalent, this is almost surely a mistake on the part of the user – who would want to ask a query that never returns an object? The most likely reason for this is that the person asking the query is unfamiliar with the application domain. Since the query can be quite complex, and the schema quite large, a really helpful system would then assist the user in understanding the problem by isolating the speciﬁc parts of the query and of the schema that are responsible for the contradiction. Such a tool can be built on top of explanation facilities available for certain Description Logics [McGuinness and Borgida, 1995; Borgida et al., 2000]. More generally, in situations where the query returns no individuals in the cur- rent database it has been argued that the query is “not interesting” and should

be generalized until a non-empty answer set is returned. As suggested by Anwar et al. [1992], this relaxation can be performed using the semilattice of descrip- tions provided by the subsumption relationship, which can guide the systematic weakening of terms in the query. The query can be classiﬁed with respect to the concepts in the schema. This can be used to help users pose queries in an unfamiliar domain, as follows: if the answer set contains unwanted values, the immediate subsumers and subsumees of the query reveal other potentially relevant concepts (and, through subsumption assertions in the schema, roles as well) which the user may want to use for restricting the query. The result is a process of query speciﬁcation by iterative reﬁnement introduced by Tou et al. [1982]. Queries can also be classiﬁed with respect to each other into a subsumption hierarchy. In an environment where several people are asking exploratory questions about the data over a long period of time (e.g., data mining by humans), it is very useful to have the questions organized so that the results of previous related queries can be reviewed [Brachman et al., 1992]. This prevents duplication of effort and, again, helps the user to pose queries that are more precise. Unfortunately, in exchange for a more expressive description of the schema, Description Logics pay the price of a weaker query language than usual: queries can only return subsets of existing objects, rather than creating new objects (as in standard SQL databases); furthermore, the selection conditions are rather limited. In fact, it has been shown [Borgida, 1996] that even the most expressive Description Logics discussed in the literature until recently, could only express a variant of the “3-variable” subset of formulae of ﬁrst-order logic – i.e., formulae that only use 3 variables, although allowing numeric quantiﬁers, like “exists at least n”. Given the expressive limitations of DL concepts alone as queries, it is reasonable to consider extending standard queries (in Datalog) with Description Logics. Two different approaches have been pursued: In one, inspired by the work of A¨ıt-Kaci and Nasr [1986] on Login, and exempliﬁed by the AL-log language [Donini et al., 1998b], descriptions are used essentially as type constraints on variables appearing in Horn clauses. In this case, a crucial condition is that concept and role names form a disjoint set from the relations used in expressing rules. The second approach, exempliﬁed by the Carin language [Levy and Rousset, 1996; 1998], treats concepts and roles as ordinary unary and binary predicates that can also appear in query atoms. This is signiﬁcant because it allows for the ﬁrst time conjunctive queries to be expressed over DL databases/Aboxes. A second important distinction is between recursive and non-recursive Datalog queries. For the non-recursive case (which covers a large portion of practically useful queries), it seems possible to combine some expressive decidable Description Logics with Datalog while keeping query answering and even reasoning on queries

decidable (see Section 16.4). For the recursive case, undecidability arises sooner, but some studies have identiﬁed suitable restrictions on the DL language and/or on the form of Datalog rules, for preserving decidability of query answering. Consider ﬁrst AL-log. In the rule

happy(x) ←marriedTo(x, y) ∧employedBy(y, z) & Person(x) ∧Person(y) ∧StartUp(z)

the tests after the ampersand & are for concept membership, while those before it are for n-ary relations, as in relational databases. The processing of such queries is complicated by the fact that the DL “type database” may contain disjunction or be otherwise incomplete. Instead of the standard answers, one gets a “conditional result”, with a side condition c describing necessary DL constraints on the variables in the query. For example, for the above query one might get as answer

happy(ANNA) if Person(ANNA)

in a database containing

marriedTo(ANNA, JOE), employedBy(JOE, IBM), Person(JOE), StartUp(IBM).

Donini et al. [1998b] establish that answering queries in recursive AL-log is decidable in the case when the Description Logic used is ALC. The framework of AL-log is further extended in [Rosati, 1999] to the case of disjunctive Datalog, i.e., Datalog with negation as failure in rule bodies and disjunction in the head of rules. The Carin approach is more general, but this increase in expressive power comes at a price: for general Datalog rules, the query answering problem is now undecid- able as soon as one allows ∀R.C or ⩽n R as concept constructors. (These appear in most Description Logics.) However, if Datalog rules are restricted to avoid recur- sion, then query answering is decidable even for the ALCNR Description Logic. Numerous other results circumscribing the cases when query processing is decid- able may be found in [Levy and Rousset, 1998].

16.3.2 Query optimization

In the case when queries can be classiﬁed (as when they are descriptions or when the query implication problem is decidable), classiﬁcation of queries has been proposed as a technique for query processing and optimization. In [Beck et al., 1989], queries are classiﬁed with respect to schema concepts; if the query concept Q is classiﬁed below concept C, then only instances of C need to be checked whether they satisfy the full query. Of course, in this classiﬁcation process one uses the axioms describing the schema of the database

If the answers to previous queries are cached, then the query concepts can be left in the classiﬁcation hierarchy, together with the other concepts in the schema. The result is a simple form of the query optimization technique known as “query an- swering using cached views”: ﬁnd the most speciﬁc views V that subsume the query Q; check only the individual instances of V (which, recall, are locally available) to see if they satisfy the query. Potentially, this could provide con- siderable savings, especially when gathering information from multiple sites, for example. Buchheit et al. [1994b] elaborate on this by using a more powerful query lan- guage. In particular, in order to achieve the expressiveness of full ﬁrst-order logic, expressing a query is viewed as a two-phase process: as much of the query as pos- sible is written in the “query Description Logic” (yielding the so-called “structural part”), and the remainder of the query is written as a constraint in a ﬁrst-order logic notation (yielding the so-called “dirty part”). For example, the following query asks for students whose advisor is the same as their committee chair and at least 5 years older than the student:

QueryClass QueryStudent isa Student with derived I1 : advisor: Prof I2 : committee.(chair: Thing) where I1= I2 constraint forall s/QueryStudent (s.age + 5 < s.advisor.age).

In this case, assuming that cached views have only structural conditions, the query is classiﬁed using only its own structural conditions. Thereafter, only the instances of the view are tested using both the structural and dirty parts of the query. Finally, Bergamaschi et al. [1997] have investigated the use of Description Logics in optimizing query evaluation in object-oriented DBMSs by eliminating redundant terms. This is accomplished by ﬁrst expanding the query as much as possible using the information in the schema; for example, subsumption is used to test when the antecedent of a rule can be applied to the query (subsumes it) so that its consequent can be added to it. By repeatedly applying this process, an expanded query is obtained. Then, all the query subterms that subsume the rest of the query (and are therefore redundant) are eliminated one by one. The result is a semantically equivalent description/query which may be more concise than the original one; hence it may have fewer tests to evaluate. Furthermore, the new expanded query may be classiﬁed further down the pre-existing class/view hierarchy, providing more efﬁcient query evaluation, using the query classiﬁcation technique described earlier These are forms of so called “semantic query optimization”

An issue related to efﬁcient processing of large numbers of individuals is the situation where the user needs to query the conceptual model for DL instances, while the data is presented in a relational database, say. In other words, we need to obtain the proper ABox instances of the DL query (which involves concepts and roles) from the database. The main problem is that processing hundreds of thousands of individuals is not feasible with DL technology because in each case we try to perform complex inferences. However, most of the data in the database is very straightforward, and the corresponding individuals do not generate new infer- ences. The solution proposed in [Borgida and Brachman, 1993] is to associate with the primitive concepts (resp. roles) of the DL knowledge base unary (resp. binary) view tables deﬁned over the DBMS. One can then automatically translate complex descriptions into complex SQL queries over these views. The important effect is that one gets the full beneﬁt of DBMS optimization for the SQL query, and if only a few values satisfy the query, then only a few DL individuals need to be created. For example, for a primitive DL class Student, we might take the values appearing in the enrollee column of relational table Enrollment R, and use this subset of the Person R table to generate appropriate individuals in a special view Student R, which has only one column. (The generation of unique identiﬁers for these indi- viduals is in itself a research issue.) Similarly, for example, one would generate a two-column view visitor R corresponding to the role visitor. Complex descriptions over Student and visitor are then translated algorithmically into SQL queries over the corresponding views. Additional optimizations turn out to be necessary to deal properly with multiple queries and functional roles [Borgida and Brachman, 1993].

16.4 Data integration

Integrating different data sources is one of the fundamental problems faced in the last decades by the database community [Batini et al., 1986]. Generally speaking, the goal of a data integration system is to provide a uniform interface to various data sources [Levy, 2000], so as to enable users to focus on specifying what they want. As a result, the data integration system frees the users from tasks such as ﬁnding the relevant data sources, interacting with each source in isolation, and selecting, cleaning, and combining data from multiple sources. The design of a data integration system is a very complex task, which comprises several different aspects. Our goal in this section is to discuss the use of Description Logics in two important aspects, namely:

r The speciﬁcation of the content of the various data sources. r The process of computing the answer to queries posed to the data integration system, based on the speciﬁcation of the sources

16.4.1 Specifying the content of data sources

The typical architecture of a data integration system allows one to explicitly model data and information needs – i.e., a speciﬁcation of the data that the system provides to the user – at various levels:

r The conceptual level contains a conceptual representation of the sources and of the rec- onciled integrated data, together with an explicit declarative account of the relationships among their components. r The logical level contains a representation of the sources in terms of a logical data model.

The conceptual level As we have seen before, the conceptual level contains a formal description of the concepts, the relationships between concepts, and the information requirements that the integration application has to deal with. The key feature of this level is that such a description is independent of any system consideration, and is oriented towards the goal of expressing the semantics of the application. In particular, we distinguish among the following elements:

r The Enterprise Conceptual Schema is a representation of the global concepts and rela- tionships that are of interest to the application. It corresponds roughly to the notion of global conceptual schema in the traditional approaches to schema integration and to the notion of world view, as introduced in [Levy et al., 1995; Kirk et al., 1995]. r For an information source S, the Source Conceptual Schema of S is a conceptual repre- sentation of the data residing in S. r The term Domain Conceptual Schema is used to denote the union of both the Enterprise Conceptual Schema and the various Source Conceptual Schemas, plus possible inter- schema relationships [Catarci and Lenzerini, 1993].

We have seen in Section 16.2 that Description Logics are very well suited for data modeling at the conceptual level, so it comes as no surprise that Description Logics have also been used in data integration projects to represent Source and Enterprise Conceptual Schemas [Catarci and Lenzerini, 1993; Arens et al., 1993; 1996;Levyetal.,1995;Goasdoueetal.,2000].Inthissection,following[Calvanese et al., 1998e], we will continue to use the DLR DL for specifying these conceptual schemas. As stated above, the Domain Conceptual Schema contains inter-schema rela- tionships. In particular, since the sources are of interest in the system, integration does not simply mean producing the Enterprise Conceptual Schema, but rather being able to establish the correct interdependencies both between the Source Con- ceptual Schemas and the Enterprise Conceptual Schema, and between the various Source Conceptual Schemas. To specify inter-schema relationships, we make use of the special kinds of assertionsavailableinDLreasoning Inparticular following[CatarciandLenzerini

1993], one can use assertions of the following forms:

Li ⊑ext L j Li ⊑int L j

where Li and L j are expressions of different schemas. In particular, Li and L j are either two relation expressions of the same arity, or two concept expressions. Intuitively, the ﬁrst assertion states that Li is extensionally included in L j, which means that every object that satisﬁes the expression Li in source i also satisﬁes the expression L j in source j. For example, if the designer knows that the set of students stored in source 1 is a subset of those stored in source 2, then this knowledge is captured by the inter-schema assertion

Student1 ⊑ext Student2.

The second assertion states that the concept denoted by the expression Li in source i is a subconcept of the one denoted by the expression L j in source j, which means that every object in source i satisfying Li also satisﬁes L j in source j, provided that it does appear in source j. For example, if the designer knows that the concept of student in source 1 is a subconcept of person in source 2, then s/he can use the inter-schema assertion

Student1 ⊑int Person2.

It is worth noting that the possibility of reasoning about DLR schemas allows sophisticated forms of reasoning on inter-schema assertions, e.g., for inferring those extensional relationships between concepts that are implied by the knowledge on the intensional interdependencies. More details about these forms of reasoning can be found in [Catarci and Lenzerini, 1993; Calvanese et al., 1998e].

The logical level The logical level provides a description of the logical content of each source, called the Source Schema. Typically, a Source Schema is provided in terms of a set of relations using the relational logical model of data. So-called wrappers can be used to hide how the source actually stores its data, the data model it adopts, etc., and present the source as a set of relations. The link between the logical representation of a source and the Domain Concep- tual Schema can be speciﬁed in two different ways.

r According to the so-called global-as-view approach, a query over the source relations is associated to each concept in the Domain Conceptual Schema. Every such concept is thus seen as a view over the sources. r In the alternative local-as-view approach, one associates with each source relation a query that describes its content in terms of the Domain Concept al Schema In other ords

the logical content of a source relation is described in terms of a view over the Domain Conceptual Schema.

In [Levy, 2000], it is argued that the local-as-view approach has several advantages, and we will follow this approach in the rest of the chapter. To describe the content of the sources through views, one needs a notion of query such as the union of conjunctive queries over the Domain Conceptual Schema. Speciﬁcally, a source relation is described in terms of a query of the form

q(⃗x) ←conj1(⃗x, ⃗y1) ∨· · · ∨conjm(⃗x, ⃗ym)

where:

r The head q(⃗x) deﬁnes the schema of the relation in terms of a name, and the number of columns. r The body describes the content of the relation in terms of the Domain Conceptual Schema.

In [Calvanese et al., 2001c], conji(⃗x, ⃗yi) is a conjunction of atoms, and ⃗x, ⃗yi are all the variables appearing in the conjunct (we use ⃗x to denote a tuple of variables x1, . . . , xn, for some n). Each atom is of the form E(t), R(⃗t), or A(t, t′), where ⃗t, t, and t′ are variables in ⃗x, ⃗yi or constants, and E, R, and A are respectively entities, relationships, and attributes appearing in the Domain Conceptual Schema. The semantics of queries is as follows. Given a database that satisﬁes the Do- main Conceptual Schema, a query q of arity n is interpreted as the set of n-tuples (d1, . . . , dn), with each di an object of the database, such that, when substituting each di for xi, the formula

∃⃗y1.conj1(⃗x, ⃗y1) ∨· · · ∨∃⃗ym.conjm(⃗x, ⃗ym)

evaluates to true. Analogously to the case of the conceptual level, it is interesting to perform several reasoning tasks on the DL representation of the sources, for example for inferring redundancies and/or inconsistencies among data stored in different sources. Since queries that include atoms from the Conceptual Schema are more expressive, new algorithms are required to answer the following problems:

r Query containment. Given two queries q1 and q2 (of the same arity n), check whether q1 is contained in q2, i.e., check whether the set of tuples denoted by q1 is contained in the set of tuples denoted by q2 in every database satisfying the Conceptual Schema. Papers that contain results relating to this question include [Levy and Rousset, 1998; Calvanese et al., 1998a; Goasdoue and Rousset, 2000]. r Query consistency. Check whether a query q over the Conceptual Schema is consistent, i.e., check whether there exists a database satisfying the Conceptual Schema in which the set of t ples denoted b q is not empt

r Query disjointness. Check whether two queries q1 and q2 (of the same arity) over the Conceptual Schema are disjoint, i.e., check whether the intersection of the set of tuples denoted by q1 and the set of tuples denoted by q2 is empty, in every database satisfying the Conceptual Schema.

16.4.2 Query answering

Theultimategoalofadataintegrationsystemistoallowtheusertoposequeriesover the global view, and to answer the queries by accessing the sources in a transparent way. The mechanism for answering queries differs depending on the approach adopted for specifying the sources. The possibility of reasoning about queries can provide useful support in both the global-as-view and the local-as-view approaches. As in the previous subsection, here we focus on the local-as-view approach, that is the one in which query answering is most complex. In the local-as-view approach, relations at the sources are modeled as views over the virtual database represented by the Domain Conceptual Schema. Since the database is virtual, in order to answer a query Q formulated over the Domain Con- ceptual Schema, we can only use the source views. In other words, query processing cannot simply be done by looking at a set of relations, as in traditional databases, but requires reasoning on both the form of the query, and the content of the source views. This motivates the idea that query answering in data integration becomes the problem of view-based query processing. There are two approaches to view-based query processing, called query rewriting and query answering, respectively. In the former approach, we are given a query Q and a set of view deﬁnitions, and the goal is to reformulate the query into an equivalent expression that refers only to the views available, and provides the answer to Q. In the latter approach, besides Q and the view deﬁnitions, we also take into account the extensions of the views, and the goal is to compute the set of tuples that are implied by these extensions, i.e., the set of tuples t such that t satisﬁes Q in all the databases that are consistent with the views. Notice the difference between the two approaches. In query rewriting, query processing is divided in two steps, where the ﬁrst re-expresses the query in terms of a given query language over the alphabet of the view names, and the second step evaluates the rewriting over the view extensions. In query answering, we do not pose any limit on query processing, and the only goal is to exploit all possible information, including view extensions, to compute the answer to the query. View-based query processing has been extensively investigated by the database community [Levy, 2000]. Only recently has the problem been studied for the case where the Domain Conceptual Schema is expressed in Description Logics. For example [Baader et al 2000] addresses the problem of rewriting queries that

are concepts in terms of concepts in the conceptual schema. Query rewriting for more general queries (e.g., ones involving conjunctions of atoms) has been studied in [Beeri et al., 1997; Levy and Rousset, 1998; Goasdoue et al., 2000; Calvanese etal.,2001c],insomecasestakingintoconsiderationcomplexconstraintsexpressed in Description Logic as part of the Conceptual Schema. One issue that must be addressed here is that the original query Q may not be rewritable as an expression over the views because of limitations of the language for combining views. In this case, one must ﬁnd heuristic best-effort approximations. Another issue is ﬁnding a minimum-cost rewriting (e.g., by eliminating unnecessary lookups in some of the views). Finally, we mention that Goasdoue et al. [2000] describe an implemented infor- mation integration system, which uses a combination of global-as-view and limited local-as-view approaches applied to the ALN DL and non-recursive Horn rules. Among the pioneering attempts at solving the query answering problem is the In- formation Manifold system [Levy et al., 1996; 1995], which has detailed algorithms for query rewriting. In the context of heterogeneous databases, Mena et al. [2000] propose that each source has its own conceptual schema/ontology expressed in a Description Logic, and these are interrelated by adding “hyponym” (subsumption) relationships between concepts in each. (This is reminiscent of the approach in [Catarci and Lenzerini, 1993].) One of the interesting features of this system is that it takes seriously the approximations resulting from the fact that some queries may not be expressible in terms of the combined ontologies. Among others, they study the notions of “precision” and “accuracy” of recall to quantify this approximation. A solution to the query answering approach is presented in [Calvanese et al., 2000a], which, among other things, illustrates the relationship between view-based query answering and ABox reasoning in Description Logics.

16.5 Conclusions

We have reviewed a number of ways in which Description Logics can be useful in the development and utilization of databases. Probably the most successful applications are in areas where the conceptual model of the UofD is required. This includes the initial development stage, as well as access to heterogeneous data sources. Concerning the initial conceptual modeling: First, Description Logics are pow- erful enough to capture the domain semantics represented by various entity– relationship data models, as well as other data models introduced in the database literature. In fact, with most Description Logics, one can represent additional con- straints. Second, because Description Logics have a clear semantics, the meaning of the DL model is unambiguous and precise Third not only can information be

represented, but it can also be reasoned with: one can look for inconsistent class/entity deﬁnitions (ones that cannot have any individual instances) and more generally, one can check for the consistency of the entire model. Both of these are signs to the developer that there are modeling errors. Arguably, it is this third aspect, concerning reasoning with the model, that is the greatest advantage of DL models. DL descriptions can be viewed as necessary and sufﬁcient conditions, and hence as queries (or views!) for a database. Description Logics are somewhat less success- ful in this regard (at least in their pure form), because they have limited expressive power compared to the standard calculi known from relational databases, and be- cause they cannot generate new objects – only select subsets of existing objects. However, if one accepts a Description Logic as a data model, then DL queries can be classiﬁed with respect to schema concepts and previous queries, supporting query by reﬁnement and data exploration. The subsumption relationship can also be used for semantic query optimization. Combining Description Logics with Datalog rules, or at least supporting con- junctive queries from concepts, is a promising way to obtain a more expressive query language. The evaluation of the resulting queries appears to be decidable with a wide range of Description Logics if the rules are not recursive. The addi- tion of recursion appears to lead to undecidability relatively quickly. However, full recursion is not an necessity for practical applications, such as information inte- gration, so further research in the possible combinations of Description Logics and Datalog restrictions is warranted. The ability to represent the semantics of a UofD is also the reason why De- scription Logics are useful in situations where information is to be integrated from various sources, such as heterogeneous or federated databases. It is widely agreed that the integration needs to be achieved at the conceptual level. The Description Logic can be used to deﬁne the ontology of each site, and then these ontologies are inter-related; alternatively, a global ontology is speciﬁed, and then the sites are described as views over it.

Appendix

Description Logic Terminology

FRANZ BAADER

Abstract

The purpose of this appendix is to introduce (in a compact manner) the syntax and semantics of the most prominent DLs occurring in this handbook. More information and explanations as well as some less familiar Description Logics can be found in the respective chapters. For DL constructors whose semantics cannot be described in a compact manner, we will only introduce the syntax and refer the reader to the respective chapter for the semantics. Following Chapter 2 on basic Description Logics, we will ﬁrst introduce the basic Description Logic AL, and then describe several of its extensions. Thereby, we will also ﬁx the notation employed in this handbook. Finally, we will comment on the naming schemes for Description Logics that are employed in the literature and in this handbook.

A.1 Notational conventions

Before starting with the deﬁnitions, let us introduce some notational conventions. The letters A, B will often be used for atomic concepts, and C, D for concept de- scriptions. For roles, we often use the letters R, S, and for functional roles (features, attributes) the letters f, g. Nonnegative integers (in number restrictions) are often denoted by n, m, and individuals by a, b. In all cases, we may also use subscripts. This convention is followed when deﬁning syntax and semantics and in abstract examples. In concrete examples, the following conventions are used: concept names start with an uppercase letter followed by lowercase letters (e.g., Human, Male), role names (also functional ones) start with a lowercase letter (e.g., hasChild, marriedTo), and individual names are all uppercase (e.g., CHARLES, MARY).

A.2 Syntax and semantics of common Description Logics

In this section, we introduce the standard concept and role constructors as well as knowledge bases For more information see Chapter 2

A.2.1 Concept and role descriptions

Elementary descriptions are atomic concepts and atomic roles (also called concept names and role names). Complex descriptions can be built from them inductively with concept constructors and role constructors. Concept descriptions in AL are formed according to the following syntax rule:

C, D −→ A | (atomic concept) ⊤| (universal concept, top concept) ⊥| (bottom concept) ¬A | (atomic negation) C ⊓D | (intersection) ∀R.C | (value restriction) ∃R.⊤ (limited existential quantiﬁcation).

Following our convention, A denotes an atomic concept and C, D denote concept descriptions. The role R is atomic since AL does not provide role constructors. An interpretation I consists of a non-empty set I (the domain of the inter- pretation) and an interpretation function, which assigns to every atomic concept A a set AI ⊆I and to every atomic role R a binary relation RI ⊆I × I. The interpretation function is extended to concept descriptions by the following inductive deﬁnitions:

⊤I = I

⊥I = ∅ ¬AI = I \ AI

(C ⊓D)I = CI ∩DI

(∀R.C)I = {a ∈I | ∀b. (a, b) ∈RI →b ∈CI} (∃R.⊤)I = {a ∈I | ∃b. (a, b) ∈RI}.

There are several possibilities for extending AL in order to obtain a more expres- sive Description Logic. The three most prominent are adding additional concept constructors, adding role constructors, and formulating restrictions on role inter- pretations. Below, we start with the third possibility, since we need to refer to restrictions on roles when deﬁning certain concept constructors. For these exten- sions, we also introduce a naming scheme. Basically, each extension is assigned a letter or symbol. For concept constructors, the letters/symbols are written after the starting AL, for role constructors, we write the letters/symbols as superscripts, and for restrictions on the interpretation of roles as subscripts. As an example, the Description Logic ALCQ−1 R+ extends AL with the concept constructors negation (C) and qualiﬁed number restrictions (Q), the role constructor inverse (−1), and the restriction that some roles are transitive ( )

Restrictions on role interpretations

These restrictions force the interpretations of roles to satisfy certain properties, such as functionality and transitivity. We consider these two prominent examples in more detail. Others would be symmetry or connections between different roles.1

(i) Functional roles. Here one considers a subset NF of the set of role names NR; its elements are called features. An interpretation must map features f to functional bi- nary relations f I ⊆I × I, i.e., relations satisfying ∀a, b, c. f I(a, b) ∧f I(a, c) → b = c. Sometimes functional relations are viewed as partial functions, and thus one writes f I(a) = b rather than f I(a, b). AL extended with features is denoted by AL f . (ii) Transitive roles. Here one considers a subset NR+ of NR. Role names R ∈NR+ are called transitive roles. An interpretation must map transitive roles R ∈NR+ to transitive binary relations RI ⊆I × I. AL extended with transitive roles is denoted by ALR+.

Concept constructors

Concept constructors take concept and/or role descriptions and transform them into more complex concept descriptions. Table A.1 shows the syntax and semantics of common concept constructors. In order to have them all in one place, we also repeat the ones from AL, minus atomic negation and limited existential quantiﬁcation since they are special cases of negation and existential quantiﬁcation. Some explanatory remarks are in order. The symbols u1, u2 in the agreement con- structor stand for chains of functional roles, i.e., u1 = f1 . . . fm and u2 = g1 . . . gn where n, m ≥0 and the fi, g j are features. The semantics of such a chain is given by the composition of the partial functions interpreting its components, i.e., uI 1(a) = f I m(. . . f I 1 (a) . . .). Nominals (or individuals) in concept expressions are interpreted as singleton sets, consisting of one element of the domain. We assume that names for individuals come from a name space disjoint from the set of concept and role names. Since role-value-maps cause undecidability and thus are no longer used in DL systems, there is no special symbol for them in the last column of Table A.1. Many DL systems employ a Lisp-like concrete syntax. Table A.2 introduces this syntax and gives a translation into the abstract syntax introduced in Table A.1.

Role constructors

Role constructors take role and/or concept descriptions and transform them into more complex role descriptions. Table A.3 shows the syntax and semantics of common role constructors.

1 One could also count role hierarchies as imposing such restrictions. Here we will, however, treat role hierarchies i th t t f k l d b

Table A.1. Some Description Logic concept constructors.

Name Syntax Semantics Symbol

Top ⊤ I AL Bottom ⊥ ∅ AL Intersection C ⊓D CI ∩DI AL Union R ⊔S CI ∪DI U Negation ¬C I \ CI C Value restriction ∀R.C {a ∈I | ∀b. (a, b) ∈RI →b ∈CI} AL Existential quant. ∃R.C {a ∈I | ∃b. (a, b) ∈RI ∧b ∈CI} E Unqualiﬁed ⩾n R {a ∈I | |{b ∈I | (a, b) ∈RI}| ≥n} number ⩽n R {a ∈I | |{b ∈I | (a, b) ∈RI}| ≤n} N restriction = n R {a ∈I | |{b ∈I | (a, b) ∈RI}| = n} Qualiﬁed ⩾n R.C {a ∈I | |{b ∈I | (a, b) ∈RI ∧b ∈CI}| ≥n} number ⩽n R.C {a ∈I | |{b ∈I | (a, b) ∈RI ∧b ∈CI}| ≤n} Q restriction = n R.C {a ∈I | |{b ∈I | (a, b) ∈RI ∧b ∈CI}| = n} Role-value- R ⊆S {a ∈I | ∀b.(a, b) ∈RI →(a, b) ∈SI} map R = S {a ∈I | ∀b.(a, b) ∈RI ↔(a, b) ∈SI} Agreement and u1 .= u2 {a ∈I | ∃b ∈I. uI 1(a) = b = uI 2(a)} F disagreement u1 ̸ .= u2 {a ∈I | ∃b1, b2 ∈I. uI 1(a) = b1 ̸= b2 = uI 2(a)} Nominal I I I ⊆I with |I I| = 1 O

The symbol ◦denotes the usual composition of binary relations, i.e.,

RI ◦SI = {(a, c) | ∃b. (a, b) ∈RI ∧(b, c) ∈SI}.

Iterated composition is denoted in the form (RI)n. To be more precise,

(RI)0 = {(d, d) | d ∈I} and (RI)n+1 = (RI)n ◦RI.

Transitive and reﬂexive-transitive closure are the only constructors among the ones introduced so far that cannot be expressed in ﬁrst-order predicate logic. The Lisp-like concrete syntax for role constructors can be found in Table A.4.

A.2.2 Knowledge bases

A DL knowledge base usually consists of a set of terminological axioms (often called a TBox) and a set of assertional axioms or assertions (often called an ABox) The syntax and semantics of these axioms can be found in Table A 5 An

Table A.2. Concrete syntax of concept constructors.

Name Concrete syntax Abstract syntax

Top TOP ⊤ Bottom BOTTOM ⊥ Intersection (and C1 . . . Cn) C1 ⊓· · · ⊓Cn Union (or C1 . . . Cn) C1 ⊔· · · ⊔Cn Negation (not C) ¬C Value restriction (all R C) ∀R.C Limited existential quantiﬁcation (some R) ∃R.⊤ Existential quantiﬁcation (some R C) ∃R.C At-least number restriction (at-least n R) ⩾n R At-most number restriction (at-most n R) ⩽n R Exact number restriction (exactly n R) = n R Qualiﬁed at-least restriction (at-least n R C) ⩾n R.C Qualiﬁed at-most restriction (at-most n R C) ⩽n R.C Qualiﬁed exact restriction (exactly n R C) = n R.C Same-as, agreement (same-as u1 u2) u1 .= u2 Role-value-map (subset R1 R2) R1 ⊆R2 Role ﬁllers (fillers R I1 . . . In) ∃R.I1 ⊓· · · ⊓∃R.In One-of (one-of I1 . . . In) I1 ⊔· · · ⊔In

Table A.3. Some Description Logic role constructors.

Name Syntax Semantics Symbol

Universal role U I × I U Intersection R ⊓S RI ∩SI ⊓ Union R ⊔S RI ∪SI ⊔ Complement ¬R I × I \ RI ¬ Inverse R− {(b, a) ∈I × I | (a, b) ∈RI} −1 Composition R ◦S RI ◦SI ◦ Transitive closure R+  n≥1(RI)n + Reﬂexive-transitive closure R∗  n≥0(RI)n ∗ Role restriction R|C RI ∩(I × CI) r Identity id (C) {(d, d) | d ∈CI} id

Table A.4. Concrete syntax of role constructors.

Name Concrete syntax Abstract syntax

Universal role top U Intersection (and R1 · · · Rn) R1 ⊓· · · ⊓Rn Union (or R1 · · · Rn) R1 ⊔· · · ⊔Rn Complement (not R) ¬R Inverse (inverse R) R−

Composition (compose R1 · · · Rn) R1 ◦· · · ◦Rn Transitive closure (transitive-closure R) R+

Reﬂexive–transitive closure (reflexive-transitive-closure R) R∗

Role restriction (restrict R C) R|C Identity (identity C) id (C)

Table A.5. Terminological and assertional axioms.

Name Syntax Semantics

Concept inclusion C ⊑D CI ⊆DI

Role inclusion R ⊑S RI ⊆SI

Concept equality C ≡D CI = DI

Role equality R ≡S RI = SI

Concept assertion C(a) aI ∈CI

Role assertion R(a, b) (aI, bI) ∈RI

interpretation I is called a model of an axiom if it satisﬁes the statement in the last column of the table. An equality whose left-hand side is an atomic concept (role) is called a concept (role) deﬁnition. A ﬁnite set of deﬁnitions is called a terminology or TBox if the deﬁnitions are unambiguous, i.e., no atomic concept occurs more than once as left- hand side. Axioms of the form C ⊑D for a complex description C are often called general inclusion axioms. A set of axioms of the form R ⊑S where both R and S are atomic is called a role hierarchy. Such a hierarchy obviously imposes restrictions on the interpretation of roles. Thus, the fact that the knowledge base may contain a role hierarchy is sometimes indicated by appending a subscript H to the name of the Description Logic (see “Restrictions on role interpretations” above). The concrete Lisp-like syntax in Table A.6 distinguishes between terminolog- ical axioms with atomic concepts as left hand sides and the more general ones

Table A.6. Concrete syntax of axioms.

Name Concrete syntax Abstract syntax

Concept deﬁnition (define-concept A C) A ≡C Primitive concept introduction (define-primitive-concept A C) A ⊑C General inclusion axiom (implies C D) C ⊑D Role deﬁnition (define-role R S) R ≡S Primitive role introduction (define-primitive-role R S) R ⊑S Concept assertion (instance a C) C(a) Role assertion (related a b R) R(a, b)

Following the convention mentioned at the beginning of this appendix, A denotes an atomic concept, and R denotes an atomic role.

A.3 Additional constructors

Here we mention some of the additional constructors that occur somewhere in the handbook. For most of them, the semantics cannot be described in a compact manner, and thus we refer to the respective chapter for details.

A.3.1 Concept and role constructors

Many additional constructors are introduced in Chapter 6. In Description Logics with concrete domains one can use concrete predicates to constrain ﬁllers of feature chains, similarly to the use of the equality predicate in feature agreements. For example, if hasAge is a feature and ≥18 the unary concrete predicate consisting of all nonnegative integers greater than or equal to 18, then ∃hasAge.≥18 describes the individuals whose age is greater than or equal to 18. In general, an existential predicate restriction is of the form

∃(u1, . . . , un).P,

where P is an n-ary predicate of the underlying concrete domain and u1, . . . , un are feature chains. One can also use concrete domain predicates to deﬁne new roles. For example, ∃(hasAge)(hasAge).> consists of all pairs of individuals having an age such that the ﬁrst individual is older than the second one. The general form of such a complex role is

∃(u u )(v v ) P

where P is an (n + m)-ary predicate of the underlying concrete domain and u1, . . . , un, and v1, . . . , vm are feature chains. In modal extensions of Description Logics, one can apply modal operators to concepts and/or roles, i.e., if ✷is such a modal operator, C is a concept, and R is a role, then

✷C and ✷R

are a concept and a role, respectively. Similarly, one can also use diamond operators ✸to obtain new concepts and roles. A special such modal operator is the epistemic operator K, which can be used to talk about things that are known to the knowledge base. Chapter 5 introduces several additional constructors. Least and greatest ﬁxpoint semanticsforcyclicterminologies(seeChapter2)canbegeneralizedbyintroducing ﬁxpoint constructors directly into the description language. Let X be a concept name and C a concept description containing the name X. Then

µX.C and νX.C

are new concept descriptions respectively obtained by applying the least and the greatest ﬁxpoint constructor to C. To ensure that the least and the greatest ﬁxpoint exist, one must restrict C to be syntactically monotonic, i.e., every occurrence of X in C must be in the scope of an even number of complement operators. For example, given an interpretation ManI of Man and hasChildI of hasChild, the concept νMomo.(Man ⊓∀hasChild.Momo) looks for the greatest interpretation MomoI of Momo such that MomoI = (Man ⊓∀hasChild.Momo)I. It is easy to see that this is the set of all men having only male offspring (see Chapter 2 for the corresponding example with a cyclic TBox). Chapter 5 also considers the Description Logic DLR, in which the restriction to at most binary predicates is no longer enforced. If R is an n-ary predicate, i ∈{1, . . . , n}, and k is a nonnegative integer, then

∃[$i]R

denotes the concept collecting those individuals that occur as the ith component in some tuple of R, and

⩽k [$i]R

denotestheconceptcollectingthoseindividualsd forwhichthepredicateRcontains at most k tuples whose ith component is d. Conversely, if C is a concept, n a nonnegative integer, and i ∈{1, . . . , n}, then

($i/n : C)

denotes the n-ary predicate consisting of the tuples whose ith component belongs to C. The Description Logic DLR also allows Boolean operators on both concepts and predicates.2

A.3.2 Axioms

In addition to the semantics for terminological axioms introduced above, Chapter 2 also considers ﬁxpoint semantics for cyclic TBoxes. Chapter 6 introduces several ways of extending the terminological and the as- sertional component of a DL system. In Description Logics with concrete domains one can use concrete predicates also in the ABox in assertions of the form

P(x1, . . . , xn),

where P is an n-ary predicate of the underlying concrete domain and x1, . . . , xn are names for concrete individuals. In some modal extensions of Description Logics, one can apply modal and Boolean operators also to terminological and assertional axioms: if ϕ, ψ are axioms, then so are

ϕ ∧ψ, ¬ϕ, ✷ϕ.

In probabilistic extensions of Description Logics, one can use probabilistic ter- minological axioms of the form

P(C|D) = p,

which state that the conditional probability for an object known to be in D to belong to C is p. The integration of Reiter’s default logic into Description Logics yields termino- logical defaults of the form

C(x) : D(x)

E(x) ,

where C, D, E are concept descriptions (viewed as ﬁrst-order formulae with one free variable x). Intuitively, such a default rule can be applied to an ABox individual a, i.e., E(a) is added to the current set of beliefs, if its prerequisite C(a) is already believed for this individual and its justiﬁcation D(a) is consistent with the set of beliefs. Rules of the form

C ⇒E

2 N t h th t ti di t h t d d ti ( Ch t 5 f d t il )

(as introduced in Chapter 2) can be seen as a special case of terminological defaults where the justiﬁcation is empty. Their intuitive meaning is: “if an individual is known to be an instance of C, then add the information that it is also an instance of E.”

A.4 A note on the naming scheme for Description Logics

In Section A.2 we have introduced a naming scheme for Description Logics, which extends the naming scheme for the AL-family introduced in Chapter 2 by writing letters/symbols for role constructors as superscripts, and for restrictions on the interpretation of roles as subscripts. The reason was that this yields a consistent naming scheme, which distinguishes typographically between the three different possibilities for extending the expressive power of AL. In the literature, and also in this handbook, other naming schemes are employed as well. One reason for this, in addition to the fact that such schemes have evolved over time, is that it is very hard to pronounce a name like ALCQ−1 R+. We will here point out the most prominent such naming schemes. The historically ﬁrst scheme is the one for the AL-family introduced in Chapter 2, and extended in this appendix. However, in the literature the typograph- ical distinction between role constructors, concept constructors, and restrictions on the interpretation of roles is usually not made. For example, many papers use I to denote inverse of roles, R to denote intersection of roles, and H to denote role hier- archies. Thus, ALCRI denotes the extension of ALC by intersection and inverse of roles, and ALCH denotes the extension of ALC by role hierarchies. In some cases, the letter F, which we have employed to express the presence of feature agreements and disagreements, is used with a different meaning. Its presence states that number restrictions of the form ⩽1 R can be used to express functionality of roles.3 The subscript “trans” (or “reg”) is often employed to express the presence of union, composition, and transitive closure of roles (sometimes also including the identity role). The Greek letter µ in front of a language name, as in µALC, usually indicates the extension of this Description Logic by ﬁxpoint operators. All members of the AL-family include AL as a sublanguage. In some cases one does not want all the constructors of AL to be present in the language. The Descrip- tion Logic FL−is obtained from AL by disallowing atomic negation, and FL0 is obtained from FL−by, additionally, disallowing limited existential quantiﬁcation. If these languages are extended by other constructors, one can indicate this in a way analogous to extensions of AL. For example, FL−U denotes the extension of FL−by union of concepts.

3 Unlike the restriction of R to be functional, which we express with a subscript f , this allows local functionality t t t i R i f ti l t t i l b t b f ti l t th l

All the Description Logics mentioned so far contain the concept constructors intersection and value restriction as a common core. Description Logics that allow intersection of concepts and existential quantiﬁcation (but not value restriction) are collected in the EL-family. The only constructors available in EL are intersection of concepts and existential quantiﬁcation. Extensions of EL are again obtained by adding appropriate letters/symbols. In order to avoid very long names for expressive Description Logics, the abbre- viation S has been introduced for ALC R+, i.e., the Description Logic that extends ALC by transitive roles. Prominent members of the S-family are SIN (which ex- tends ALC R+ with number restrictions and inverse roles), SHIF (which extends ALC R+ with role hierarchies, inverse roles, and number restrictions of the form ⩽1 R), and SHIQ (which extends ALC R+ with role hierarchies, inverse roles, and qualiﬁed number restrictions). Actually, the Description Logics SIN, SHIF, and SHIQ are somewhat less expressive than indicated by their name since the use of roles in number restrictions is restricted: roles that have a transitive subrole must not occur in number restrictions. The Description Logic DLR mentioned in the previous section also gives rise to a family of Description Logics, with members like DLRreg, which extends DLR with union, composition, and transitive closure of binary relations obtained as projections of n-ary predicates onto two of their components.

Bibliography

[Abiteboul, 1997] Serge Abiteboul. Querying semi-structured data. In Proc. of the 6th Int. Conf. on Database Theory (ICDT’97), pages 1–18, 1997. [Abiteboul and Kanellakis, 1989] Serge Abiteboul and Paris Kanellakis. Object identity as a query language primitive. In Proc. of the ACM SIGMOD Int. Conf. on Management of Data, pages 159–173, 1989. [Abiteboul et al., 1995] Serge Abiteboul, Richard Hull, and Victor Vianu. Foundations of Databases. Addison Wesley Publ. Co., Reading, Massachussetts, 1995. [Abiteboul et al., 1997] Serge Abiteboul, Dallan Quass, Jason McHugh, Jennifer Widom, and Janet L. Wiener. The Lorel query language for semistructured data. Int. J. on Digital Libraries, 1(1):68–88, 1997. [Abiteboul et al., 2000] Serge Abiteboul, Peter Buneman, and Dan Suciu. Data on the Web: from Relations to Semistructured Data and XML. Morgan Kaufmann, Los Altos, 2000. [Abrahams et al., 1996] Merryll K. Abrahams, Deborah L. McGuinness, Rich Thomason, Lori Alperin Resnick, Peter F. Patel-Schneider, Violetta Cavalli-Sforza, and Cristina Conati. NeoClassic tutorial: Version 1.0. Technical report, Artiﬁcial Intelligence Principles Research Department, AT&T Labs Research and University of Pittsburgh, 1996. Available as http://www.bell-labs.com/project/classic/papers/ NeoTut/NeoTut.html. [Abrett and Burstein, 1987] Glen Abrett and Mark H. Burstein. The KREME knowledge editing environment. Int. J. of Man-Machine Studies, 27(2):103–126, 1987. [Abrial, 1974] J. R. Abrial. Data semantics. In J. W. Klimbie and K. L. Koffeman, editors, Data Base Management, pages 1–59. North-Holland Publ. Co., Amsterdam, 1974. [Achilles et al., 1991] E. Achilles, B. Hollunder, A. Laux, and J. P. Mohren. KRIS: Knowledge Representation and Inference System – User guide. Technical Report D91-14, Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI), 1991. [Agoncillo et al., 1999] A. V. Agoncillo, J. L. Mejin. Jr, and C. Rosse. Inﬂuence of the digital anatomist foundational model on traditional representations of anatomical concepts. J. of the American Medical Informatics Association, pages 2–6, 1999. Annual Symposium Issue. [A¨ıt-Kaci and Nasr, 1986] H. A¨ıt-Kaci and R. Nasr. LOGIN: A logic programming language with built-in inheritance. J. of Logic Programming, 3:185–215, 1986. [Albano et al., 1991] Antonio Albano, Giorgio Ghelli, and Renzo Orsini. A relationship mechanism for strongly typed Object-Oriented database programming languages.

In Proc. of the 17th Int. Conf. on Very Large Data Bases (VLDB’91), pages 565–575, Barcelona (Spain), 1991. [Albano et al., 1993] Antonio Albano, Roberto Bergamini, Giorgio Ghelli, and Renzo Orsini. An object data model with roles. In Proc. of the 19th Int. Conf. on Very Large Data Bases (VLDB’93), pages 39–51, 1993. [Allen, 1983] James F. Allen. Maintaining knowledge about temporal intervals. Communications of the ACM, 26(11):832–843, 1983. [Allen, 1991] James F. Allen. The RHET system. SIGART Bull., 2(3):1–7, 1991. [Allen, 1993] James F. Allen. Natural language, knowledge representation, and logical form. In M. Bates and R. Weischedel, editors, Challenges in Natural Language Processing. Cambridge University Press, 1993. [Allgayer, 1990] J¨urgen Allgayer. SB-ONE+: Dealing with sets efﬁciently. In Proc. of the 9th Eur. Conf. on Artiﬁcial Intelligence (ECAI’90), pages 13–18, 1990. [Allgayer et al., 1989] J. Allgayer, R. Jansen-Winkeln, C. Reddig, and N. Reithinger. Bidirectional use of knowledge in the multi-modal NL access system XTRA. In Proc. of the 10th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’87), 1989. [Amarger et al., 1991] S. Amarger, D. Dubois, and H. Prade. Constraint propagation with imprecise conditional probabilities. In Proc. of the 7th Annual Conf. on Uncertainty in Artiﬁcial Intelligence (UAI’91), pages 26–34. Morgan Kaufmann, Los Altos, 1991. [Andr´e and Rist, 1995] Elisabeth Andr´e and Thomas Rist. Generating coherent presentations employing textual and visual material. Artiﬁcial Intelligence Rev., 9(2/3):147–165, 1995. [Andr´e et al., 1996] E. Andr´e, J. M¨uller, and T. Rist. WIP/PPP: Automatic generation of personalized multimedia presentations. In Proc. of the 4th ACM Int. Multimedia Conference (Multimedia’96), pages 407–408, 1996. [Andr´eka et al., 1996] Hajnal Andr´eka, Johan van Benthem, and Istva´an N´emeti. Modal languages and bounded fragments of predicate logic. Technical Report ML-96-03, ILLC, University of Amsterdam, 1996. [Anwar et al., 1992] T. W. Anwar, H. Beck, and S. Navathe. Knowledge mining by imprecise querying: A classiﬁcation-based approach. In Proc. of the 8th IEEE Int. Conf. on Data Engineering (ICDE’92), pages 622–630, 1992. [Areces, 2000] Carlos Areces. Logic Engineering. The Case of Description and Hybrid Logics. PhD thesis, ILLC, University of Amsterdam, 2000. ILLC Dissertation Series 2000–5. [Areces and de Rijke, 1998] Carlos Areces and Marteen de Rijke. Expressiveness revisited. In Proc. of the 1998 Description Logic Workshop (DL’98). CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-11/, 1998. [Areces et al., 2000] Carlos Areces, Patrick Blackburn, and Maarten Marx. The computational complexity of hybrid temporal logics. J. of the Interest Group in Pure and Applied Logic, 8(5), 2000. [Arens et al., 1993] Y. Arens, C. Y. Chee, C. Hsu, and C. A. Knoblock. Retrieving and integrating data from multiple information sources. J. of Intelligent and Cooperative Information Systems, 2(2):127–158, 1993. [Arens et al., 1996] Y. Arens, C. A. Knoblock, and W. Shen. Query reformulation for dynamic information integration. J. of Intelligent Information Systems, 6:99–130, 1996. [Artale and Franconi, 1994] Alessandro Artale and Enrico Franconi. A computational account for a Description Logic of time and action. In J. Doyle, E. Sandewall, and P. Torasso, editors, Proc. of the 4th Int. Conf. on the Principles of Knowledge

Representation and Reasoning (KR’94), pages 3–14, Bonn (Germany), 1994. Morgan Kaufmann, Los Altos. [Artale and Franconi, 1998] Alessandro Artale and Enrico Franconi. A temporal Description Logic for reasoning about actions and plans. J. of Artiﬁcial Intelligence Research, 9:463–506, 1998. [Artale and Franconi, 1999] Alessandro Artale and Enrico Franconi. Temporal ER modeling with Description Logics. In Proc. of the 18th Int. Conf. on Conceptual Modeling (ER’99), volume 1728 of Lecture Notes in Computer Science, pages 81–95. Springer, 1999. [Artale and Franconi, 2000] Alessandro Artale and Enrico Franconi. A survey of temporal extensions of Description Logics. Ann. of Mathematics and Artiﬁcial Intelligence, 1–4:171–210, 2000. [Artale and Franconi, 2001] Alessandro Artale and Enrico Franconi. Temporal Description Logics. In D. Gabbay, M. Fisher, and L. Vila, editors, Handbook of Time and Temporal Reasoning in Artiﬁcial Intelligence. The MIT Press, 2001. [Artale et al., 1996a] Alessandro Artale, Francesca Cesarini, and Giovanni Soda. Describing database objects in a concept language environment. IEEE Trans. on Knowledge and Data Engineering, 8(2):345–351, 1996. [Artale et al., 1996b] Alessandro Artale, Enrico Franconi, Nicola Guarino, and Luca Pazzi. Part-whole relations in object-centered systems: An overview. Data and Knowledge Engineering, 20:347–383, 1996. [Artale et al., 2001] Alessandro Artale, Enrico Franconi, Milenko Mosurovic, Frank Wolter, and Michael Zakharyaschev. The DLR(US) temporal Description Logic. In Proc. of the 2001 Description Logic Workshop (DL 2001). CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-49/, 2001. [Baader, 1990a] Franz Baader. Terminological cycles in KL-ONE-based knowledge representation languages. In Proc. of the 8th Nat. Conf. on Artiﬁcial Intelligence (AAAI’90), pages 621–626, Boston (MA, USA), 1990. [Baader, 1990b] Franz Baader. Terminological cycles in KL-ONE-based knowledge representation languages. Technical Report RR-90-01, Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI), Kaiserslautern (Germany), 1990. An abridged version appeared in Proc. of the 8th Nat. Conf. on Artiﬁcial Intelligence (AAAI’90), pp. 621–626. [Baader, 1991] Franz Baader. Augmenting concept languages by transitive closure of roles: An alternative to terminological cycles. In Proc. of the 12th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’91), 1991. [Baader, 1996a] Franz Baader. A formal deﬁnition for the expressive power of terminological knowledge representation languages. J. of Logic and Computation, 6:33–54, 1996. [Baader, 1996b] Franz Baader. Using automata theory for characterizing the semantics of terminological cycles. Ann. of Mathematics and Artiﬁcial Intelligence, 18:175–219, 1996. [Baader, 1998] Franz Baader. Personal communication, 1998. [Baader and Hanschke, 1991a] Franz Baader and Philipp Hanschke. A schema for integrating concrete domains into concept languages. In Proc. of the 12th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’91), pages 452–457, 1991. [Baader and Hanschke, 1991b] Franz Baader and Philipp Hanschke. A scheme for integrating concrete domains into concept languages. Technical Report RR-91-10, Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI), 1991.

[Baader and Hanschke, 1992] Franz Baader and Philipp Hanschke. Extensions of concept languages for a mechanical engineering application. In Proc. of the 16th German Workshop on Artiﬁcial Intelligence (GWAI’92), volume 671 of Lecture Notes in Computer Science, pages 132–143. Springer, 1992. [Baader and Hollunder, 1991a] Franz Baader and Bernhard Hollunder. KRIS: Knowledge Representation and Inference System. SIGART Bull., 2(3):8–14, 1991. [Baader and Hollunder, 1991b] Franz Baader and Bernhard Hollunder. A terminological knowledge representation system with complete inference algorithm. In Proc. of the Workshop on Processing Declarative Knowledge (PDK’91), volume 567 of Lecture Notes in Artiﬁcial Intelligence, pages 67–86. Springer, 1991. [Baader and Hollunder, 1992] Franz Baader and Bernhard Hollunder. Embedding defaults into terminological knowledge representation formalisms. In Proc. of the 3rd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’92), pages 306–317. Morgan Kaufmann, Los Altos, 1992. [Baader and Hollunder, 1993] Franz Baader and Bernhard Hollunder. How to prefer more speciﬁc defaults in terminological default logic. In Proc. of the 13th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’93), pages 669–674. Morgan Kaufmann, Los Altos, 1993. [Baader and Hollunder, 1995a] Franz Baader and Bernhard Hollunder. Embedding defaults into terminological knowledge representation formalisms. J. of Automated Reasoning, 14:149–180, 1995. [Baader and Hollunder, 1995b] Franz Baader and Bernhard Hollunder. Priorities on defaults with prerequisites and their application in treating speciﬁcity in terminological default logic. J. of Automated Reasoning, 14:41–68, 1995. [Baader and K¨usters, 1998] Franz Baader and Ralf K¨usters. Computing the least common subsumer and the most speciﬁc concept in the presence of cyclic ALN-concept descriptions. In Proc. of the 22nd German Annual Conf. on Artiﬁcial Intelligence (KI’98), volume 1504 of Lecture Notes in Computer Science, pages 129–140. Springer, 1998. [Baader and K¨usters, 1999] Franz Baader and Ralf K¨usters. Matching in Description Logics with existential restrictions. In Proc. of the 1999 Description Logic Workshop (DL’99). CEUR Electronic Workshop Proceedings, http://ceur-ws.org/ Vol-22/, 1999. [Baader and K¨usters, 2000] Franz Baader and Ralf K¨usters. Matching in Description Logics with existential restrictions. In Proc. of the 7th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2000), pages 261–272, 2000. [Baader and K¨usters, 2001] Franz Baader and Ralf K¨usters. Uniﬁcation in a Description Logic with transitive closure of roles. In Robert Nieuwenhuis and Andrei Voronkov, editors, Proc. of the 8th Int. Conf. on Logic for Programming, Artiﬁcial Intelligence and Reasoning (LPAR 2001), volume 2250 of Lecture Notes in Computer Science, pages 217–232. Springer, 2001. [Baader and Laux, 1995] Franz Baader and Armin Laux. Terminological logics with modal operators. In Proc. of the 14th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’95), pages 808–814, 1995. Morgan Kaufmann, Los Altos. [Baader and Molitor, 1999] Franz Baader and Ralf Molitor. Rewriting in Description Logics using terminologies. In Proc. of the 1999 Description Logic Workshop (DL’99). CEUR Electronic Workshop Proceedings, http://ceur-ws.org/ Vol-22/, 1999. [Baader and Narendran, 1998] Franz Baader and Paliath Narendran. Uniﬁcation of concept terms in Description Logics. In H. Prade, editor, Proc. of the

13th Eur. Conf. on Artiﬁcial Intelligence (ECAI’98), pages 331–335. John Wiley & Sons, 1998. [Baader and Narendran, 2001] Franz Baader and Paliath Narendran. Uniﬁcation of concept terms in Description Logics. J. of Symbolic Computation, 31(3):277–305, 2001. [Baader and Ohlbach, 1993] Franz Baader and Hans-J¨urgen Ohlbach. A multi-dimensional terminological knowledge representation language. In Proc. of the 13th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’93), pages 690–695, 1993. [Baader and Ohlbach, 1995] Franz Baader and Hans-J¨urgen Ohlbach. A multi-dimensional terminological knowledge representation language. J. of Applied Non-Classical Logics, 5:153–197, 1995. [Baader and Sattler, 1996a] Franz Baader and Ulrike Sattler. Description logics with symbolic number restrictions. In Proc. of the 12th Eur. Conf. on Artiﬁcial Intelligence (ECAI’96), pages 283–287. John Wiley & Sons, 1996. [Baader and Sattler, 1996b] Franz Baader and Ulrike Sattler. Number restrictions on complex roles in Description Logics: A preliminary report. In Proc. of the 5th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’96), pages 328–338, 1996. [Baader and Sattler, 1999] Franz Baader and Ulrike Sattler. Expressive number restrictions in Description Logics. J. of Logic and Computation, 9(3):319–350, 1999. [Baader and Schlechta, 1993] Franz Baader and Karl Schlechta. A semantics for open normal defaults via a modiﬁed preferential approach. In Proceedings of the European Conference on Symbolic and Quantitative Approaches to Reasoning und Uncertainty, (ECSQARU’93), volume 747 of Lecture Notes in Computer Science, pages 9–16. Springer, 1993. [Baader et al., 1991] Franz Baader, Hans-J¨urgen B¨urkert, Jochen Heinsohn, Bernhard Hollunder, J¨urgen M¨uller, Bernhard Nebel, Werner Nutt, and Hans-J¨urgen Proﬁtlich. Terminological knowledge representation: A proposal for a terminological logic. Technical Report TM-90-04, Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI), Kaiserslautern (Germany), 1991. [Baader et al., 1992a] Franz Baader, Enrico Franconi, Bernhard Hollunder, Bernhard Nebel, and Hans-J¨urgen Proﬁtlich. An empirical analysis of optimization techniques for terminological representation systems, or: Making KRIS get a move on. In Proc. of the 3rd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’92), pages 270–281, 1992. [Baader et al., 1992b] Franz Baader, Bernhard Hollunder, Bernhard Nebel, Hans-J¨urgen Proﬁtlich, and Enrico Franconi. An empirical analysis of optimization techniques for terminological representation systems. In Proc. of the 3rd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’92), pages 270–281. Morgan Kaufmann, Los Altos, 1992. [Baader et al., 1993] Franz Baader, Hans-J¨urgen B¨urckert, Bernhard Nebel, Werner Nutt, and Gert Smolka. On the expressivity of feature logics with negation, functional uncertainty, and sort equations. J. of Logic, Language and Information, 2:1–18, 1993. [Baader et al., 1994] Franz Baader, Enrico Franconi, Bernhard Hollunder, Bernhard Nebel, and Hans-J¨urgen Proﬁtlich. An empirical analysis of optimization techniques for terminological representation systems or: Making KRIS get a move on. Applied Artiﬁcial Intelligence. Special Issue on Knowledge Base Management, 4:109–132, 1994. [Baader et al., 1996] Franz Baader, Martin Buchheit, and Bernhard Hollunder. Cardinality restrictions on concepts. Artiﬁcial Intelligence, 88(1–2):195–213, 1996.

[Baader et al., 1998a] Franz Baader, Ralf Kusters, and Ralf Molitor. Structural subsumption considered from an automata theoretic point of view. In Proc. of the 1998 Description Logic Workshop (DL’98). CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-11/, 1998. [Baader et al., 1998b] Franz Baader, Ralf Molitor, and Stephan Tobies. On the relation between Description Logics and conceptual graphs. LTCS-Report 98-11, LuFG Theoretical Computer Science, RWTH Aachen, Germany, 1998. [Baader et al., 1999a] Franz Baader, Ralf K¨usters, Alex Borgida, and Deborah L. McGuinness. Matching in Description Logics. J. of Logic and Computation, 9(3):411–447, 1999. [Baader et al., 1999b] Franz Baader, Ralf K¨usters, and Ralf Molitor. Computing least common subsumers in Description Logics with existential restrictions. In Proc. of the 16th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’99), pages 96–101, 1999. [Baader et al., 1999c] Franz Baader, Ralf Molitor, and Stephan Tobies. Decidable and tractable fragments of conceptual graphs. In William Tepfenhart and Walling Cyre, editors, Proc. of the 7th Int. Conf. on Conceptual Structures (ICCS’99), volume 1640 of Lecture Notes in Artiﬁcial Intelligence, pages 480–493. Springer, 1999. [Baader et al., 2000] Franz Baader, Ralf K¨usters, and Ralf Molitor. Rewriting concepts using terminologies. In Proc. of the 7th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2000), pages 297–308, 2000. [Baader et al., 2001] Franz Baader, Sebastian Brandt, and Ralf K¨usters. Matching under side conditions in Description Logics. In Proc. of the 17th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI 2001), pages 213–218, 2001. [Baker, 1995] A. B. Baker. Intelligent Backtracking on Constraint Satisfaction Problems: Experimental and Theoretical Results. PhD thesis, University of Oregon, 1995. [Baker et al., 1998] P. Baker, A. Brass, S. Bechhofer, C. Goble, N. Paton, and R. Stevens. TAMBIS: Transparent access to multiple bioinformatics information sources. In Proc. of the 6th Int. Conf. on Intelligent Systems for Molecular Biology (ISMB’98), pages 25–34, 1998. [Balcazar, 1996] Jos´e L. Balcazar. The complexity of searching implicit graphs. Artiﬁcial Intelligence, 86:171–188, 1996. [Balsiger and Heuerding, 1998] P. Balsiger and A. Heuerding. Comparison of theorem provers for modal logics—introduction and summary. In H. de Swart, editor, Proc. of the 2nd Int. Conf. on Analytic Tableaux and Related Methods (TABLEAUX’98), volume 1397 of Lecture Notes in Artiﬁcial Intelligence, pages 25–26. Springer, 1998. [Balsiger et al., 1996] P. Balsiger, G. J¨ager, S. Schwendimann, and M. Seyfried. A logics workbench. AI Communications—The Eur. J. on Artiﬁcial Intelligence, 9(2):53–58, 1996. [Bancilhon and Khoshaﬁan, 1989] Fran¸cois Bancilhon and Setrag Khoshaﬁan. A calculus for complex objects. J. of Computer and System Sciences, 38(2):326–340, 1989. [Bateman, 1990] John A. Bateman. Upper modeling: Organizing knowledge for natural language processing. In Proc. of the 5th Int. Workshop on Natural Language Generation, pages 54–61, Dawson, PA, 1990. [Bateman et al., 1995] John A. Bateman, Bernardo Magnini, and Giovanni Fabris. The generalized upper model knowledge base: Organization and use. In Proc. of the 2nd Int. Conf. on Building and Sharing of Very Large-Scale Knowledge Bases, Twente (The Netherlands), April 1995.

[Batini et al., 1986] Carlo Batini, Maurizio Lenzerini, and Shamkant B. Navathe. A comparative analysis of methodologies for database schema integration. ACM Computing Surveys, 18(4):323–364, 1986. [Batini et al., 1992] Carlo Batini, Stefano Ceri, and Shamkant B. Navathe. Conceptual Database Design, an Entity-Relationship Approach. Benjamin and Cummings Publ. Co., Menlo Park, California, 1992. [Baud et al., 1993] R. Baud, C. Lovis, L. Alpay, A.-M. Rassinoux, J.-R. Scherrer, A. Nowlan, and A. Rector. Modelling for natural language understanding. In Proc. of the 17th Annual Symposium on Computer Applications in Medical Care (SCAMC’93), pages 289–293, 1993. [Baud et al., 1997] R. H. Baud, J.-M. Rodrigues, J. C. Wagner, A.-M. Rassinoux, C. Lovis, P. Rush, B. Trombert-Paviot, and J.-R. Scherrer. Validation of concept representation using natural language generation. J. of the American Medical Informatics Association, 1997. Fall Symposium Supplement. [Bechhofer et al., 1999] Sean Bechhofer, Ian Horrocks, Peter F. Patel-Schneider, and Sergio Tessaris. A proposal for a Description Logic interface. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 33–36. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Bechhofer et al., 2000] Sean Bechhofer, Jeen Broekstra, Stefan Decker, Michael Erdmann, Dieter Fensel, Carole Goble, Frank van Harmelen, Ian Horrocks, Michel Klein, Deborah L. McGuinness, Enrico Motta, Peter F. Patel-Schneider, Steffen Staab, and Rudi Studer. An informal description of OIL-Core and Standard OIL: a layered proposal for DAML-O. Technical Report KSL-00-19, Stanford University KSL, November 2000. Available at http://www.ontoknowledge.org/oil/ downl/dialects.pdf. [Bechhofer et al., 2001a] Sean Bechhofer, Carole Goble, and Ian Horrocks. DAML+OIL is not enough. In Proc. of the 2001 Int. Semantic Web Working Symposium (SWWS 2001), pages 151–159, 2001. Available at http://www.semanticweb. org/SWWS/program/full/SWWSProceedings.pdf. [Bechhofer et al., 2001b] Sean Bechhofer, Ian Horrocks, Carole Goble, and Robert Stevens. OilEd: A Reason-able ontology editor for the semantic web. In Proc. of the Joint German/Austrian Conf. on Artiﬁcial Intelligence (KI 2001), number 2174 in Lecture Notes in Artiﬁcial Intelligence, pages 396–408. Springer, 2001. Appeared also in Proc. of the 2001 Description Logic Workshop (DL 2001). [Beck et al., 1989] Howard W. Beck, Sunit K. Gala, and Shamkant B. Navathe. Classiﬁcation as a query processing technique in the CANDIDE semantic data model. In Proc. of the 5th IEEE Int. Conf. on Data Engineering (ICDE’89), pages 572–581, 1989. [Beeri et al., 1997] Catriel Beeri, Alon Y. Levy, and Marie-Christine Rousset. Rewriting queries using views in Description Logics. In Proc. of the 16th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS’97), pages 99–108, 1997. [Bell et al., 1994] D. S. Bell, E. Pattison-Gordon, and R. A. Greenes. Experiments in concept modeling for radiographic image reports. J. of the American Medical Informatics Association, 1(3), 1994. [Ben-Ari et al., 1982] Mordechai Ben-Ari, Joseph Y. Halpern, and Amir Pnueli. Deterministic propositional dynamic logic: Finite models, complexity, and completeness. J. of Computer and System Sciences, 25:402–417, 1982. [Bennett, 1997] Brandon Bennett. Modal logics for qualitative spatial reasoning. J. of the Interest Group in Pure and Applied Logic, 4(1), 1997.

[Bergamaschi and Nebel, 1994] Sonia Bergamaschi and Bernhard Nebel. Acquisition and validation of complex object database schemata supporting multiple inheritance. Applied Intelligence, 4(2):185–203, 1994. [Bergamaschi and Sartori, 1992] Sonia Bergamaschi and Claudio Sartori. On taxonomic reasoning in conceptual design. ACM Trans. on Database Systems, 17(3):385–422, 1992. [Bergamaschi et al., 1997] Sonia Bergamaschi, Domenico Beneventano, Claudio Sartori, and Maurizio Vincini. ODB-QOPTIMIZER: A tool for semantic query optimization in oodb. In Proc. of the 13th IEEE Int. Conf. on Data Engineering (ICDE’97), 1997. [Berger, 1966] R. Berger. The undecidability of the dominoe problem. Mem. Amer. Math. Soc., 66:1–72, 1966. [Bernholtz et al., 1994] Orna Bernholtz, Moshe Y. Vardi, and Pierre Wolper. An automata-theoretic approach to branching-time model checking. In Proc. of the 6th Int. Conf. on Computer Aided Veriﬁcation (CAV’94), volume 818 of Lecture Notes in Computer Science, pages 142–155. Springer, 1994. [Bettini, 1997] Claudio Bettini. Time-dependent concepts: Representation and reasoning using temporal Description Logics. Data and Knowledge Engineering, 22:1–38, 1997. [Blackburn, 1993] Patrick Blackburn. Nominal tense logic. Notre Dame J. of Formal Logic, 34(1):56–83, 1993. [Blackburn and Seligman, 1995] Patrick Blackburn and Jerry Seligman. Hybrid languages. J. of Logic, Language and Information, 4:251–272, 1995. [Blackburn and Spaan, 1993] Patrick Blackburn and Edith Spaan. A modal perspective on computational complexity of attribute value grammars. J. of Logic, Language and Information, 2:129–169, 1993. [Blackburn et al., 2001] Patrick Blackburn, Maarten de Rijke, and Yde Venema. Modal Logic, volume 53 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 2001. [Bobrow and Webber, 1980] R. Bobrow and B. Webber. Knowledge representation for syntactic/semantic processing. In Proc. of the 1st Nat. Conf. on Artiﬁcial Intelligence (AAAI’80), 1980. [Borgida, 1992a] Alexander Borgida. Description logics are not just for the ﬂightless-birds: A new look at the utility and foundations of Description Logics. Technical Report DCS-TR-295, New Brunswick Department of Computer Science, Rutgers University, 1992. [Borgida, 1992b] Alexander Borgida. From type systems to knowledge representation: Natural semantics speciﬁcations for Description Logics. J. of Intelligent and Cooperative Information Systems, 1(1):93–126, 1992. [Borgida, 1995] Alexander Borgida. Description logics in data management. IEEE Trans. on Knowledge and Data Engineering, 7(5):671–682, 1995. [Borgida, 1996] Alexander Borgida. On the relative expressiveness of Description Logics and predicate logics. Artiﬁcial Intelligence, 82(1–2):353–367, 1996. [Borgida, 1999] Alexander Borgida. Extensible knowledge representation: the case of description reasoners. J. of Artiﬁcial Intelligence Research, 10:399–434, 1999. [Borgida and Brachman, 1993] Alexander Borgida and Ronald J. Brachman. Loading data into description reasoners. In Proc. of the ACM SIGMOD Int. Conf. on Management of Data, pages 217–226, 1993. [Borgida and Etherington, 1989] Alexander Borgida and David W. Etherington. Hierarchical knowledge bases and efﬁcient disjunctive reasoning. In Ron J. Brachman, Hector J. Levesque, and Ray Reiter, editors, Proc. of the 1st Int. Conf. on

the Principles of Knowledge Representation and Reasoning (KR’89), pages 33–43, 1989. [Borgida and K¨usters, 2000] Alexander Borgida and Ralf K¨usters. What’s not in a name: Some properties of a purely structural approach to integrating large DL knowledge bases. In Proc. of the 2000 Description Logic Workshop (DL 2000), pages 65–78. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-33/, 2000. [Borgida and McGuinness, 1996] Alexander Borgida and Deborah L. McGuinness. Asking queries about frames. In Proc. of the 5th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’96), pages 340–349, 1996. [Borgida and Patel-Schneider, 1994] Alexander Borgida and Peter F. Patel-Schneider. A semantics and complete algorithm for subsumption in the CLASSIC Description Logic. J. of Artiﬁcial Intelligence Research, 1:277–308, 1994. [Borgida and Weddell, 1997] Alexander Borgida and Grant E. Weddell. Adding uniqueness constraints to Description Logics (preliminary report). In Proc. of the 5th Int. Conf. on Deductive and Object-Oriented Databases (DOOD’97), pages 85–102, 1997. [Borgida et al., 1989] Alexander Borgida, Ronald J. Brachman, Deborah L. McGuinness, and Lori Alperin Resnick. CLASSIC: A structural data model for objects. In Proc. of the ACM SIGMOD Int. Conf. on Management of Data, pages 59–67, 1989. [Borgida et al., 1996] Alex Borgida, Charles Isbell, and Deborah L. McGuinness. Reasoning with black boxes: Handling test concepts in CLASSIC. In Proc. of the 1996 Description Logic Workshop (DL’96), number WS-96-05 in AAAI Technical Report. AAAI Press/The MIT Press, 1996. [Borgida et al., 1999] Alex Borgida, Enrico Franconi, Ian Horrocks, Deborah L. McGuinness, and Peter F. Patel-Schneider. Explaining ALC subsumption. In Proc. of the 1999 Description Logic Workshop (DL’99). CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Borgida et al., 2000] Alex Borgida, Enrico Franconi, and Ian Horrocks. Explaining ALC subsumption. In Proc. of the 14th Eur. Conf. on Artiﬁcial Intelligence (ECAI 2000), 2000. [Bouzeghoub et al., 1999] Mokrane Bouzeghoub, Francoise Fabret, Helena Galhardas, Maja Matulovic-Broqu´e, Joao Pereira, and Eric Simon. Data warehouse refreshment. In Matthias Jarke, Maurizio Lenzerini, Yannis Vassiliou, and Panos Vassiliadis, editors, Fundamentals of Data Warehouses, pages 47–86. Springer, 1999. [Brachman, 1977a] Ronald J. Brachman. A Structural Paradigm for Representing Knowledge. PhD thesis, Harvard University, Cambridge, MA, 1977. Revised version published as BBN Report No. 3605, Bolt Beranek and Newman, Inc., Cambridge, MA, July, 1978. [Brachman, 1977b] Ronald J. Brachman. What’s in a concept: Structural foundations for semantic networks. Int. Journal of Man-Machine Studies, 9(2):127–152, 1977. [Brachman, 1978] Ronald J. Brachman. Structured inheritance networks. In W. A. Woods and R. J. Brachman, editors, Research in Natural Language Understanding, Quarterly Progress Report No. 1, BBN Report No. 3742, pages 36–78. Bolt, Beranek and Newman Inc., Cambridge, MA, 1978. [Brachman, 1979] Ronald J. Brachman. On the epistemological status of semantic networks. In Nicholas V. Findler, editor, Associative Networks, pages 3–50. Academic Press, 1979. Republished in [Brachman and Levesque, 1985]. [Brachman, 1983] Ronald J. Brachman. What IS-A is and isn’t. IEEE Computer, 16(10):30–36, 1983.

[Brachman, 1985] Ronald J. Brachman. “I lied about the trees”: or, defaults and deﬁnitions in knowledge representation. AI Magazine, 6(3):80–93, 1985. [Brachman, 1992] Ronald J. Brachman. “Reducing” CLASSIC to practice: Knowledge representation meets reality. In Proc. of the 3rd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’92), pages 247–258. Morgan Kaufmann, Los Altos, 1992. [Brachman, 1994] Ronald J. Brachman. Viewing databases through a knowledge representation lens. In K. Fuchi and T. Yokoi, editors, Proc. of Knowledge Building and Knowledge Sharing Conference (KB&KS’93), pages 121–124, Tokyo, 1994. Ohmsha, Ltd. [Brachman and Levesque, 1984] Ronald J. Brachman and Hector J. Levesque. The tractability of subsumption in frame-based description languages. In Proc. of the 4th Nat. Conf. on Artiﬁcial Intelligence (AAAI’84), pages 34–37, 1984. [Brachman and Levesque, 1985] Ronald J. Brachman and Hector J. Levesque, editors. Readings in Knowledge Representation. Morgan Kaufmann, Los Altos, 1985. [Brachman and Schmolze, 1985] Ronald J. Brachman and James G. Schmolze. An overview of the KL-ONE knowledge representation system. Cognitive Science, 9(2):171–216, 1985. [Brachman et al., 1979] R. Brachman, R. Bobrow, P. Cohen, J. Klovstad, B. Webber, and W. Woods. Research in natural language understanding, annual report. Technical Report 4274, Bolt Beranek and Newman, Cambridge, MA (USA), 1979. [Brachman et al., 1983a] Ronald J. Brachman, Richard E. Fikes, and Hector J. Levesque. KRYPTON: A functional approach to knowledge representation. IEEE Computer, October:67–73, 1983. [Brachman et al., 1983b] Ronald J. Brachman, Richard E. Fikes, and Hector J. Levesque. KRYPTON: Integrating terminology and assertion. In Proc. of the 3th Nat. Conf. on Artiﬁcial Intelligence (AAAI’83), pages 31–35, 1983. [Brachman et al., 1985] Ronald J. Brachman, Victoria Pigman Gilbert, and Hector J. Levesque. An essential hybrid reasoning system: Knowledge and symbol level accounts in KRYPTON. In Proc. of the 9th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’85), pages 532–539, 1985. [Brachman et al., 1990] Ronald J. Brachman, Premkumar Devanbu, Peter G. Selfridge, David Belanger, and Yun Chen. Toward a software information system. AT&T Technical J., 69(2):22–41, 1990. [Brachman et al., 1991] Ronald J. Brachman, Deborah L. McGuinness, Peter F. Patel-Schneider, Lori Alperin Resnick, and Alexander Borgida. Living with CLASSIC: When and how to use a KL-ONE-like language. In John F. Sowa, editor, Principles of Semantic Networks, pages 401–456. Morgan Kaufmann, Los Altos, 1991. [Brachman et al., 1992] Ronald J. Brachman, Peter G. Selfridge, Loren G. Terveen, B. Altman, Alexander Borgida, F. Halper, Thomas Kirk, A. Lazar, Deborah L. McGuinness, and Lori Alperin Resnick. Knowledge representation support for data archeology. In Y. Yesha, editor, Proc. of the Int. Conf. on Information and Knowledge Management (CIKM’92), pages 457–464, 1992. [Brachman et al., 1993] Ronald J. Brachman, Peter G. Selfridge, Loren G. Terveen, B. Altman, F. Halper, Thomas Kirk, A. Lazar, Deborah L. McGuinness, and Lori Alperin Resnick. Integrated support for data archeology. Int. J. of Cooperative Information Systems, 2(2):159–185, 1993. [Brachman et al., 1999] Ronald J. Brachman, Alexander Borgida, Deborah L. McGuinness, and Peter Patel-Schneider. Reducing CLASSIC to practice: Knowledge

representation theory meets reality. Artiﬁcial Intelligence, 114(1–2):203–237, 1999. [Brandt et al., 2001] Sebastian Brandt, Ralf K¨usters, and Anni-Yasmin Turhan. Approximation in Description Logics. LTCS-Report 01-06, LuFG Theoretical Computer Science, RWTH Aachen, Germany, 2001. Available at http://www-lti.informatik.rwth-aachen.de/Forschung/Reports.html. [Bray et al., 1998] Tim Bray, Jean Paoli, and C. M. Sperberg-McQueen. Extensible Markup Language (XML) 1.0—W3C recommendation. Technical report, World Wide Web Consortium, 1998. Available at http://www.w3.org/TR/1998/REC-xml-19980210. [Bresciani et al., 1995] P. Bresciani, E. Franconi, and S. Tessaris. Implementing and testing expressive Description Logics: Preliminary report. In Proc. of the 1995 Description Logic Workshop (DL’95), pages 131–139, 1995. [Brill, 1994] David Brill. Loom Reference Manual, Version 2.0. Marina del Rey, 1994. [Brown et al., 1998] P. Brown, M. O’Neil, and C. Price. Semantic deﬁnition of disorders in version 3 of the read codes. Methods of Information in Medicine, 37:415–419, 1998. [Buchheit et al., 1993a] Martin Buchheit, Francesco M. Donini, and Andrea Schaerf. Decidable reasoning in terminological knowledge representation systems. J. of Artiﬁcial Intelligence Research, 1:109–138, 1993. [Buchheit et al., 1993b] Martin Buchheit, Francesco M. Donini, and Andrea Schaerf. Decidable reasoning in terminological knowledge representation systems. Technical Report RR-93-10, Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI), Saarbr¨ucken (Germany), 1993. An abridged version appeared in Proc. of the 13th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’93). [Buchheit et al., 1993c] Martin Buchheit, Francesco M. Donini, and Andrea Schaerf. Decidable reasoning in terminological knowledge representation systems. In Proc. of the 13th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’93), pages 704–709. Morgan Kaufmann, Los Altos, 1993. [Buchheit et al., 1994a] Martin Buchheit, Francesco M. Donini, Werner Nutt, and Andrea Schaerf. Terminological systems revisited: Terminology = schema + views. In Proc. of the 12th Nat. Conf. on Artiﬁcial Intelligence (AAAI’94), pages 199–204, Seattle (USA), 1994. [Buchheit et al., 1994b] Martin Buchheit, Manfred A. Jeusfeld, Werner Nutt, and Martin Staudt. Subsumption between queries to object-oriented databases. Information Systems, 19(1):33–54, 1994. Special issue on Extending Database Technology, EDBT’94. [Buchheit et al., 1994c] Martin Buchheit, Rudiger Klein, and Werner Nutt. Conﬁguration as model construction: the constructive problem solving approach. In Proc. of the 4th Int. Conf. on Artiﬁcial Intelligence in Design, Lausanne (Switzerland), August 1994. [Buchheit et al., 1998] Martin Buchheit, Francesco M. Donini, Werner Nutt, and Andrea Schaerf. A reﬁned architecture for terminological systems: Terminology = schema + views. Artiﬁcial Intelligence, 99(2):209–260, 1998. [Bull, 1970] R. Bull. An approach to tense logic. Theoria, 12:171–182, 1970. [Buneman et al., 1997] Peter Buneman, Susan Davidson, Mary F. Fernandez, and Dan Suciu. Adding structure to unstructured data. In Proc. of the 6th Int. Conf. on Database Theory (ICDT’97), pages 336–350, 1997. [Cadoli et al., 2000] Marco Cadoli, Marco Schaerf, Andrea Giovanardi, and Massimo Giovanardi. An algorithm to evaluate quantiﬁed boolean formulae and its experimental evaluation. In Ian Gent, Hans van Maaren, and Toby Walsh, editors,

SAT2000—Highlights of Satisﬁability Research in the Year 2000, pages 485–521. IOS Press, 2000. [Calvanese, 1990] Diego Calvanese. Integrazione tra linguaggi logici e linguaggi per la descrizione di concetti. Master’s thesis, Universit`a di Roma “La Sapienza”, 1990. [Calvanese, 1996a] Diego Calvanese. Finite model reasoning in Description Logics. In Luigia C. Aiello, John Doyle, and Stuart C. Shapiro, editors, Proc. of the 5th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’96), pages 292–303. Morgan Kaufmann, Los Altos, 1996. [Calvanese, 1996b] Diego Calvanese. Reasoning with inclusion axioms in Description Logics: Algorithms and complexity. In Proc. of the 12th Eur. Conf. on Artiﬁcial Intelligence (ECAI’96), pages 303–307. John Wiley & Sons, 1996. [Calvanese, 1996c] Diego Calvanese. Unrestricted and Finite Model Reasoning in Class-Based Representation Formalisms. PhD thesis, Dipartimento di Informatica e Sistemistica, Universit`a di Roma “La Sapienza”, 1996. Available at http://www.dis.uniroma1.it/pub/calvanes/thesis.ps.gz. [Calvanese and Lenzerini, 1994a] Diego Calvanese and Maurizio Lenzerini. Making object-oriented schemas more expressive. In Proc. of the 13th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS’94), pages 243–254, Minneapolis (Minnesota, USA), 1994. ACM Press and Addison Wesley. [Calvanese and Lenzerini, 1994b] Diego Calvanese and Maurizio Lenzerini. On the interaction between ISA and cardinality constraints. In Proc. of the 10th IEEE Int. Conf. on Data Engineering (ICDE’94), pages 204–213, Houston (Texas, USA), 1994. IEEE Computer Society Press. [Calvanese et al., 1994] Diego Calvanese, Maurizio Lenzerini, and Daniele Nardi. A uniﬁed framework for class based representation formalisms. In J. Doyle, E. Sandewall, and P. Torasso, editors, Proc. of the 4th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’94), pages 109–120, Bonn (Germany), 1994. Morgan Kaufmann, Los Altos. [Calvanese et al., 1995] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Structured objects: Modeling and reasoning. In Proc. of the 4th Int. Conf. on Deductive and Object-Oriented Databases (DOOD’95), volume 1013 of Lecture Notes in Computer Science, pages 229–246. Springer, 1995. [Calvanese et al., 1997] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Conjunctive query containment in Description Logics with n-ary relations. In Proc. of the 1997 Description Logic Workshop (DL’97), pages 5–9, 1997. [Calvanese et al., 1998a] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. On the decidability of query containment under constraints. In Proc. of the 17th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS’98), pages 149–158, 1998. [Calvanese et al., 1998b] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Semi-structured data with constraints and incomplete information. In Proc. of the 1998 Description Logic Workshop (DL’98), pages 11–20. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-11/, 1998. [Calvanese et al., 1998c] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. What can knowledge representation do for semi-structured data? In Proc. of the 15th Nat. Conf. on Artiﬁcial Intelligence (AAAI’98), pages 205–210, 1998. [Calvanese et al., 1998d] Diego Calvanese, Giuseppe De Giacomo, Maurizio Lenzerini, Daniele Nardi, and Riccardo Rosati. Description logic framework for information

integration. In Proc. of the 6th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR’98), pages 2–13, 1998. [Calvanese et al., 1998e] Diego Calvanese, Giuseppe De Giacomo, Maurizio Lenzerini, Daniele Nardi, and Riccardo Rosati. Information integration: Conceptual modeling and reasoning support. In Proc. of the 6th Int. Conf. on Cooperative Information Systems (CoopIS’98), pages 280–291, 1998. [Calvanese et al., 1998f] Diego Calvanese, Giuseppe De Giacomo, Maurizio Lenzerini, Daniele Nardi, and Riccardo Rosati. Source integration in data warehousing. In Proc. of the 9th Int. Workshop on Database and Expert Systems Applications (DEXA’98), pages 192–197. IEEE Computer Society Press, 1998. [Calvanese et al., 1998g] Diego Calvanese, Maurizio Lenzerini, and Daniele Nardi. Description logics for conceptual data modeling. In Jan Chomicki and G¨unter Saake, editors, Logics for Databases and Information Systems, pages 229–264. Kluwer Academic Publishers, 1998. [Calvanese et al., 1999a] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Answering queries using views in Description Logics. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 9–13. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Calvanese et al., 1999b] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Modeling and querying semi-structured data. Network and Information Systems, 2(2), 1999. [Calvanese et al., 1999c] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Reasoning in expressive Description Logics with ﬁxpoints based on automata on inﬁnite trees. In Proc. of the 16th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’99), pages 84–89, 1999. [Calvanese et al., 1999d] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Representing and reasoning on XML documents: A Description Logic approach. J. of Logic and Computation, 9(3):295–318, 1999. [Calvanese et al., 1999e] Diego Calvanese, Maurizio Lenzerini, and Daniele Nardi. Unifying class-based representation formalisms. J. of Artiﬁcial Intelligence Research, 11:199–240, 1999. [Calvanese et al., 2000a] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Answering queries using views over Description Logics knowledge bases. In Proc. of the 17th Nat. Conf. on Artiﬁcial Intelligence (AAAI 2000), pages 386–391, 2000. [Calvanese et al., 2000b] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Keys for free in Description Logics. In Proc. of the 2000 Description Logic Workshop (DL 2000), pages 79–88. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-33/, 2000. [Calvanese et al., 2001a] Diego Calvanese, Giuseppe De Giacomo, and Maurizio Lenzerini. Identiﬁcation constraints and functional dependencies in Description Logics. In Proc. of the 17th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI 2001), pages 155–160, 2001. [Calvanese et al., 2001b] Diego Calvanese, Giuseppe De Giacomo, Maurizio Lenzerini, and Daniele Nardi. Reasoning in expressive Description Logics. In Alan Robinson and Andrei Voronkov, editors, Handbook of Automated Reasoning, pages 1581–1634. Elsevier Science Publishers (North-Holland), Amsterdam, 2001. [Calvanese et al., 2001c] Diego Calvanese, Giuseppe De Giacomo, Maurizio Lenzerini, Daniele Nardi, and Riccardo Rosati. Data integration in data warehousing. Int. J. of Cooperative Information Systems, 10(3):237–271, 2001.

[Campbell, 1998] K. Campbell. Scalable methodologies for distributed development of logic-based convergent medical terminology. Methods of Information in Medicine, 37:426–439, 1998. [Campbell et al., 1994] K. E. Campbell, A. K. Das, and M. A. Musen. A logical foundation for representation of clinical data. J. of the American Medical Informatics Association, 1(3):218–232, 1994. [Campbell et al., 1996] K. Campbell, S. Cohn, C. Chute, G. Rennels, and E. Shortliffe. G´alapagos: Computer-based support for evolution of a convergent medical terminology. In Proc. of AMIA Fall Symposium, pages 269–273, 1996. [Campbell et al., 1998] K. E. Campbell, M. S. Tuttle, and K. A. Spackman. A “lexically-suggested logical closure” metric for medical terminology maturity. J. of the American Medical Informatics Association, pages 785–789, 1998. Fall Symposium Special Issue. [Catarci and Lenzerini, 1993] Tiziana Catarci and Maurizio Lenzerini. Representing and using interschema knowledge in cooperative information systems. J. of Intelligent and Cooperative Information Systems, 2(4):375–398, 1993. [Cattell and Barry, 1997] Roderick G. G. Cattell and Douglas K. Barry, editors. The Object Database Standard: ODMG 2.0. Morgan Kaufmann, Los Altos, 1997. [Ceusters, 1998] W. Ceusters. The distinction between linguistic and conceptual semantics in medical terminology and its implications for NLP-based knowledge acquisition. Methods of Information in Medicine, 37:327–333, 1998. [Ceusters and Spyns, 1997] W. Ceusters and P. Spyns. From natural language to formal language: when MultiTALE meets GALEN. In Proc. of Medical Informatics Europe (MIE’97), pages 396–400, 1997. [Ceusters et al., 1999] W. Ceusters, J. Rogers, F. Consorti, and A. Rossi Mori. Syntactic-semantic tagging as a mediator between linguistic representations and formal models: an exercise in linking SNOMED to GALEN. A.I.M., 15(1):5–23, 1999. [Chagrov and Zakharyaschev, 1997] Alexander Chagrov and Michael Zakharyaschev. Modal Logic, volume 35 of Oxford Logic Guides. Clarendon Press, 1997. [Chandra and Merlin, 1977] Ashok K. Chandra and Philip M. Merlin. Optimal implementation of conjunctive queries in relational data bases. In Proc. of the 9th ACM Symp. on Theory of Computing (STOC’77), pages 77–90, 1977. [Chaudhri et al., 1997] Vinay K. Chaudhri, Adam Farquhar, Richard Fikes, Peter D. Karp, and James Rice. The Generic Frame Protocol 2.0. Technical report, Artiﬁcial Intelligence Center, SRI International, Menlo Park, CA (USA), July 1997. [Chaudhri et al., 1998a] Vinay K. Chaudhri, Adam Farquhar, Richard Fikes, and Peter D. Karp. Open Knowledge Base Connectivity 2.0. Technical Report KSL-09-06, Stanford University KSL, 1998. [Chaudhri et al., 1998b] Vinay K. Chaudhri, Adam Farquhar, Richard Fikes, Peter D. Karp, and James Rice. OKBC: A programmatic foundation for knowledge base interoperability. In Proc. of the 15th Nat. Conf. on Artiﬁcial Intelligence (AAAI’98), pages 600–607, 1998. [Chein and Mugnier, 1992] Michel Chein and Marie-Laure Mugnier. Conceptual graphs: Fundamental notions. Revue d’Intelligence Artiﬁcielle, 6(4):365–406, 1992. [Chen, 1976] P. P. Chen. The Entity-Relationship model: Toward a uniﬁed view of data. ACM Trans. on Database Systems, 1(1):9–36, March 1976. [Christaller et al., 1992] Thomas Christaller, Franco di Primio, Uwe Schnepf, and Angi Voß. The AI-Workbench BABYLON—an Open and Portable Development Environment for Expert Systems. Academic Press, 1992.

[Cimino, 1994] J. Cimino. Controlled medical vocabulary construction: Methods from the CANON group. J. of the American Medical Informatics Association, 1(3), 1994. [Cimino, 1996] J. Cimino. Formal descriptions and adaptive mechanisms for changes in controlled medical vocabularies. Methods of Information in Medicine, 35:202–210, 1996. [Cimino et al., 1989] J. Cimino, G. Hripcsak, S. Johnson, and P. Clayton. Designing an introspective controlled medical vocabulary. In Proc. of the 13th Annual Symposium on Computer Applications in Medical Care (SCAMC’89), pages 202–210, 1989. [Cimino et al., 1998] J. Cimino, S. Huff, C. T. M. Broverman, and S. Nelson. Development of a standard terminology to support medication messages. J. of the American Medical Informatics Association, 1998. Fall Symposium Special Issue. [Cohen and Hirsh, 1994a] William W. Cohen and Haym Hirsh. Learnability of Description Logics with equality constraints. Machine Learning, 17(2/3):169–200, 1994. [Cohen and Hirsh, 1994b] William W. Cohen and Haym Hirsh. Learning the CLASSIC Description Logics: Theoretical and experimental results. In J. Doyle, E. Sandewall, and P. Torasso, editors, Proc. of the 4th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’94), pages 121–133, 1994. [Cohen et al., 1992] William W. Cohen, Alex Borgida, and Haym Hirsh. Computing least common subsumers in Description Logics. In William Swartout, editor, Proc. of the 10th Nat. Conf. on Artiﬁcial Intelligence (AAAI’92), pages 754–760. AAAI Press/The MIT Press, 1992. [Collins, 1975] G. E. Collins. Quantiﬁer elimination for real closed ﬁelds by cylindric algebraic decomposition. In H. Brakhage, editor, Proc. of the 2nd GI Conference on Automata Theory and Formal Languages, volume 33 of Lecture Notes in Computer Science, pages 134–183, 1975. Springer. [Collins and Quillian, 1970] A. M. Collins and M. R. Quillian. Facilitating retrieval from semantic memory: The effect of repeating part of an inference. Acta Psychologica, 33:304–314, 1970. [Cosmadakis and Kanellakis, 1986] Stavros S. Cosmadakis and Paris C. Kanellakis. Functional and inclusion dependencies—A graph theoretical approach. In P. C. Kanellakis and F. P. Preparata, editors, Advances in Computing Research, Vol. 3, pages 163–184. JAI Press, 1986. [Cosmadakis et al., 1990] S. S. Cosmadakis, P. C. Kanellakis, and M. Vardi. Polynomial-time implication problems for unary inclusion dependencies. J. of the ACM, 37(1):15–46, January 1990. [Coupey and Faron, 1998] Pascal Coupey and Catherine Faron. Towards correspondences between conceptual graphs and Description Logics. In Marie-Laure Mugnier and Michel Chein, editors, Proc. of the 6th Int. Conf. on Conceptual Structures (ICCS’98), volume 1453 of Lecture Notes in Artiﬁcial Intelligence. Springer, 1998. [Curtis et al., 1988] B. Curtis, N. Iscoe, and H. Krasner. A ﬁeld study of the software design process for large systems. Communications of the ACM, 31(11):1268–1287, November 1988. [Danecki, 1984] Ryszard Danecki. Nondeterministic Propositional Dynamic Logic with intersection is decidable. In Proc. of the 5th Symp. on Computation Theory, volume 208 of Lecture Notes in Computer Science, pages 34–53. Springer, 1984. [Darr et al., 1998] Tim Darr, Mark Fox, and Deborah McGuinness (editors). Special issue on conﬁguration. Artiﬁcial Intelligence for Engineering Design, Analysis, and Manufacturing, 1998.

[Das et al., 2001] Aseem Das, Wei Wu, and Deborah L. McGuinness. An industrial strength distributed ontology environment. In Proc. of the 2001 Int. Semantic Web Working Symposium (SWWS 2001), 2001. Available at http://www.semanticweb.org/SWWS/program/full/SWWSProceedings.pdf. [Davis, 1973] Martin Davis. Hilbert’s tenth problem is unsolvable. American Mathematical Monthly, 80:233–269, 1973. [Davis and Putnam, 1960] Martin Davis and Hilary Putnam. A computing procedure for quantiﬁcation theory. J. of the ACM, 7(3):201–215, 1960. [Davis et al., 1962] M. Davis, G. Logemann, and D. Loveland. A machine program for theorem proving. Communications of the ACM, 5:394–397, 1962. [de Bakker, 1980] Jaco de Bakker. Mathematical Theory of Program Correctness. Prentice-Hall, Englewood Cliffs, New Jersey, 1980. [De Giacomo, 1995] Giuseppe De Giacomo. Decidability of Class-Based Knowledge Representation Formalisms. PhD thesis, Dipartimento di Informatica e Sistemistica, Universit`a di Roma “La Sapienza”, 1995. [De Giacomo, 1996] Giuseppe De Giacomo. Eliminating “converse” from Converse PDL. J. of Logic, Language and Information, 5:193–208, 1996. [De Giacomo and Lenzerini, 1994a] Giuseppe De Giacomo and Maurizio Lenzerini. Boosting the correspondence between Description Logics and propositional dynamic logics. In Proc. of the 12th Nat. Conf. on Artiﬁcial Intelligence (AAAI’94), pages 205–212. AAAI Press/The MIT Press, 1994. [De Giacomo and Lenzerini, 1994b] Giuseppe De Giacomo and Maurizio Lenzerini. Concept language with number restrictions and ﬁxpoints, and its relationship with µ-calculus. In Proc. of the 11th Eur. Conf. on Artiﬁcial Intelligence (ECAI’94), pages 411–415, 1994. [De Giacomo and Lenzerini, 1994c] Giuseppe De Giacomo and Maurizio Lenzerini. Description logics with inverse roles, functional restrictions, and n-ary relations. In Proc. of the 4th Eur. Workshop on Logics in Artiﬁcial Intelligence (JELIA’94), volume 838 of Lecture Notes in Artiﬁcial Intelligence, pages 332–346. Springer, 1994. [De Giacomo and Lenzerini, 1994d] Giuseppe De Giacomo and Maurizio Lenzerini. On the correspondence between Description Logics and logics of programs (position paper). In Proc. of the Description Logics Workshop, pages 1–4, 1994. [De Giacomo and Lenzerini, 1995] Giuseppe De Giacomo and Maurizio Lenzerini. What’s in an aggregate: Foundations for Description Logics with tuples and sets. In Proc. of the 14th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’95), pages 801–807, 1995. [De Giacomo and Lenzerini, 1996] Giuseppe De Giacomo and Maurizio Lenzerini. TBox and ABox reasoning in expressive Description Logics. In Luigia C. Aiello, John Doyle, and Stuart C. Shapiro, editors, Proc. of the 5th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’96), pages 316–327. Morgan Kaufmann, Los Altos, 1996. [De Giacomo and Lenzerini, 1997] Giuseppe De Giacomo and Maurizio Lenzerini. A uniform framework for concept deﬁnitions in Description Logics. J. of Artiﬁcial Intelligence Research, 6:87–110, 1997. [De Giacomo and Massacci, 1996] Giuseppe De Giacomo and Fabio Massacci. Tableaux and algorithms for propositional dynamic logic with converse. In Michael A. McRobbie and John K. Slaney, editors, Proc. of the 13th Int. Conf. on Automated Deduction (CADE’96), volume 1104 of Lecture Notes in Artiﬁcial Intelligence, pages 613–628. Springer, 1996.

[De Giacomo et al., 1999] Giuseppe De Giacomo, Luca Iocchi, Daniele Nardi, and Riccardo Rosati. A theory and implementation of cognitive mobile robots. J. of Logic and Computation, 9(5):759–785, 1999. [De Rosa et al., 1998] Mattia De Rosa, Tiziana Catarci, Luca Iocchi, Daniele Nardi, and Giuseppe Santucci. Materializing the Web. In Proc. of the 6th Int. Conf. on Cooperative Information Systems (CoopIS’98), pages 24–31, 1998. [Decker et al., 2000] Stefan Decker, Dieter Fensel, Frank van Harmelen, Ian Horrocks, Sergey Melnik, Michel Klein, and Jeen Broekstra. Knowledge representation on the web. In Proc. of the 2000 Description Logic Workshop (DL 2000), pages 89–97. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-33/, 2000. [Dershowitz and Jouannaud, 1990] N. Dershowitz and J. Jouannaud. Rewrite systems. In J. van Leeuven, editor, Handbook of Theoretical Computer Science, volume B, chapter 6, pages 243–320. Elsevier Science Publishers (North-Holland), Amsterdam, 1990. [Devanbu et al., 1991] Premkumar Devanbu, Ronald J. Brachman, Peter J. Selfridge, and Bruce W. Ballard. LASSIE: A knowledge-based software information system. Communications of the ACM, 34(5):36–49, 1991. [Di Battista and Lenzerini, 1993] Giuseppe Di Battista and Maurizio Lenzerini. Deductive entity-relationship modeling. IEEE Trans. on Knowledge and Data Engineering, 5(3):439–450, 1993. [Di Eugenio, 1994] Barbara Di Eugenio. Action representation for interpreting purpose clauses in natural language instructions. In Proc. of the 4th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’94), pages 158–169, 1994. [Di Eugenio, 1998] Barbara Di Eugenio. An action representation formalism to interpret natural language instructions. Computational Intelligence, 14(1):89–133, 1998. [Dick and Steen, 1991] R. S. Dick and E. B. Steen, editors. The Computer-Based Patient Record: An Essential Technology for Health Care. National Academy Press, 1991. [Dionne et al., 1992] Robert Dionne, Eric Mays, and Frank J. Oles. A non-well-founded approach to terminological cycles. In Proc. of the 10th Nat. Conf. on Artiﬁcial Intelligence (AAAI’92), pages 761–766. AAAI Press/The MIT Press, 1992. [Donini and Massacci, 2000] Francesco M. Donini and Fabio Massacci. EXPTIME tableaux for ALC. Artiﬁcial Intelligence, 124(1):87–138, 2000. [Donini et al., 1990] Francesco M. Donini, Maurizio Lenzerini, and Daniele Nardi. Using terminological reasoning in hybrid systems. AI Communications—The Eur. J. on Artiﬁcial Intelligence, 3(3):128–138, 1990. [Donini et al., 1991a] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Werner Nutt. The complexity of concept languages. In James Allen, Richard Fikes, and Erik Sandewall, editors, Proc. of the 2nd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’91), pages 151–162. Morgan Kaufmann, Los Altos, 1991. [Donini et al., 1991b] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Werner Nutt. Tractable concept languages. In Proc. of the 12th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’91), pages 458–463, Sydney (Australia), 1991. [Donini et al., 1992a] Francesco M. Donini, Bernhard Hollunder, Maurizio Lenzerini, Alberto Marchetti Spaccamela, Daniele Nardi, and Werner Nutt. The complexity of existential quantiﬁcation in concept languages. Artiﬁcial Intelligence, 2–3:309–327, 1992. [Donini et al., 1992b] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, Werner Nutt, and Andrea Schaerf. Adding epistemic operators to concept languages. In Proc.

of the 3rd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’92), pages 342–353. Morgan Kaufmann, Los Altos, 1992. [Donini et al., 1994a] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, Werner Nutt, and Andrea Schaerf. Queries, rules and deﬁnitions as epistemic sentences in concept languages. In Proc. of the ECAI Workshop on Knowledge Representation and Reasoning, volume 810 of Lecture Notes in Artiﬁcial Intelligence, pages 113–132. Springer, 1994. [Donini et al., 1994b] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Andrea Schaerf. Deduction in concept languages: From subsumption to instance checking. J. of Logic and Computation, 4(4):423–452, 1994. [Donini et al., 1995] Francesco M. Donini, Daniele Nardi, and Riccardo Rosati. Non-ﬁrst-order features in concept languages. In M. Gori and G. Soda, editors, Proc. of the 4th Conf. of the Ital. Assoc. for Artiﬁcial Intelligence (AI*IA’95), volume 992 of Lecture Notes in Artiﬁcial Intelligence, pages 91–102. Springer, 1995. [Donini et al., 1996a] Francesco M. Donini, Giuseppe De Giacomo, and Fabio Massacci. EXPTIME tableaux for ALC. In Proc. of the 1996 Description Logic Workshop (DL’96), number WS-96-05 in AAAI Technical Report, pages 107–110. AAAI Press/The MIT Press, 1996. [Donini et al., 1996b] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Andrea Schaerf. Reasoning in Description Logics. In Gerhard Brewka, editor, Principles of Knowledge Representation, Studies in Logic, Language and Information, pages 193–238. CSLI Publications, 1996. [Donini et al., 1997a] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Werner Nutt. The complexity of concept languages. Information and Computation, 134:1–58, 1997. [Donini et al., 1997b] Francesco M. Donini, Daniele Nardi, and Riccardo Rosati. Autoepistemic Description Logics. In Proc. of the 15th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’97), pages 136–141, 1997. [Donini et al., 1997c] Francesco M. Donini, Daniele Nardi, and Riccardo Rosati. Ground nonmonotonic modal logics. J. of Logic and Computation, 7(4):523–548, August 1997. [Donini et al., 1998a] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, Werner Nutt, and Andrea Schaerf. An epistemic operator for Description Logics. Artiﬁcial Intelligence, 100(1–2):225–274, 1998. [Donini et al., 1998b] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Andrea Schaerf. AL-log: Integrating Datalog and Description Logics. J. of Intelligent Information Systems, 10(3):227–252, 1998. [Donini et al., 1999] Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Werner Nutt. Tractability and intractability in Description Logics. Available at ftp://ftp.dis.uniroma1.it/pub/ai/papers/dlnn99d.ps.gz, 1999. [Donini et al., 2002] Francesco M. Donini, Daniele Nardi, and Riccardo Rosati. Description Logics of minimal knowledge and negation as failure. TOCL, 3(2):177–225, 2002. [Dorr, 1992] Bonnie J. Dorr. The use of lexical semantics in interlingual machine translation. J. of Machine Translation, 7:135–193, 1992. [Dorr and Voss, 1993] Bonnie J. Dorr and Clare R. Voss. Machine Translation of spatial expressions: Deﬁning the relation between an interlingua and a knowledge representation system. In Proc. of the 11th Nat. Conf. on Artiﬁcial Intelligence (AAAI’93), 1993.

[Dorr and Voss, 1995] Bonnie J. Dorr and Clare R. Voss. Toward a lexicalized grammar for interlinguas. J. of Machine Translation, 10(1):139–180, 1995. [Dorr et al., 1994] B. Dorr, C. Voss, E. Peterson, and M. Kiker. Concept-based lexical selection. In Working notes of the AAAI Fall Symposium on “Knowledge Representation for Natural Language Processing in Implemented Systems”, 1994. [Doyle and Patil, 1991] Jon Doyle and Ramesh S. Patil. Two theses of knowledge representation: Language restrictions, taxonomic classiﬁcation, and the utility of representation services. Artiﬁcial Intelligence, 48:261–297, 1991. [ECAI, 2002] Proc. of the 15th Eur. Conf. on Artiﬁcal Intelligence (ECAI-2002). [Edelmann and Owsnicki, 1986] J. Edelmann and B. Owsnicki. Data models in knowledge representation systems: A case study. In C. R. Rollinger and W. Horn, editors, GWAI-86 and 2. ¨Osterreichische Artiﬁcial-Intelligence-Tagung, volume 124 of Informatik-Fachberichte, pages 69–74. Springer, 1986. [Ellis, 1992] Gerard Ellis. Compiled hierarchical retrieval. In T. Nagle, J. Nagle, L. Gerholz, and P. Eklund, editors, Conceptual Structures: Current Research and Practice, pages 285–310. Ellis Horwood, 1992. [ElMasri and Navathe, 1994] Ramez A. ElMasri and Shamkant B. Navathe. Fundamentals of Database Systems. Benjamin and Cummings Publ. Co., Menlo Park, California, 2nd edition, 1994. [Emerson, 1996] E. Allen Emerson. Automated temporal reasoning about reactive systems. In Faron Moller and Graham Birtwistle, editors, Logics for Concurrency: Structure versus Automata, volume 1043 of Lecture Notes in Computer Science, pages 41–101. Springer, 1996. [Emerson and Jutla, 1991] E. Allen Emerson and Charanjit S. Jutla. Tree automata, mu-calculus and determinacy. In Proc. of the 32nd Annual Symp. on the Foundations of Computer Science (FOCS’91), pages 368–377, 1991. [Etherington, 1987] David W. Etherington. Reasoning with Incomplete Information. Morgan Kaufmann, Los Altos, 1987. [Euzenat, 2001] J´erˆome Euzenat. Preserving modularity in XML encoding of Description Logics. In Proc. of the 2001 Description Logic Workshop (DL 2001), pages 20–29. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-49/, 2001. [Evans, 1987] D. Evans. Final report on the MedSORT-II project: Developing and managing medical thesauri. Technical report, Carnegie Mellon University, 1987. [Evans et al., 1994] D. A. Evans, J. Cimino, W. R. Hersh, S. M. Huff, D. S. Bell, and The CANON Group. Position statement: Towards a medical concept representation language. J. of the American Medical Informatics Association, 1(3):207–217, 1994. [Fagin et al., 1995] Ronald Fagin, Joseph Y. Halpern, Yoram Moses, and Moshe Y. Vardi. Reasoning about Knowledge. The MIT Press, 1995. [Falasconi et al., 1997] S. Falasconi, G. Lanzola, and M. Stefanelli. An ontology-based multi-agent architecture for distributed health-care information systems. Methods of Information in Medicine, 36:20–29, 1997. [Faltings and Freuder, 1996] Boi Faltings and Eugene Freuder, editors. Working Notes of the AAAI Fall Symposium on Conﬁguration, November 1996. Technical Report FS-96-03. [Faltings and Freuder, 1998] Boi Faltings and Eugene Freuder. Conﬁguration: Getting it right. IEEE Intelligent Systems, 13(4), 1998. [Faltings et al., 1999] Boi Faltings, Eugene Freuder, Gerhard Friedrich, and Alexander Felfernig, editors. Proc. of AAAI Worshop on Conﬁguration, July 1999. Technical Report WS-99-05. [Fattorosi-Barnaba and De Caro, 1985] M. Fattorosi-Barnaba and F. De Caro. Graded modalities I Studia Logica 44:197 221 1985

[Fehrer et al., 1994] D. Fehrer, U. Hustadt, M. Jaeger, A. Nonnengart, H.-J. Ohlbach, R. Schmidt, C. Weidenbach, and E. Weydert. Description logics for natural language processing. In Proc. of the 1994 Description Logic Workshop (DL’94), 1994. Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI) Technical Report D-94-10. [Fensel et al., 2000] Dieter Fensel, Ian Horrocks, Frank van Harmelen, Stefan Decker, Michael Erdmann, and Michel Klein. OIL in a nutshell. In R. Dieng, editor, Proc. of the 12th European Workshop on Knowledge Acquisition, Modeling, and Management (EKAW 2000), number 1937 in Lecture Notes in Artiﬁcial Intelligence, pages 1–16. Springer, 2000. [Fensel et al., 2001] Dieter Fensel, Frank van Harmelen, Ian Horrocks, Deborah L. McGuinness, and Peter F. Patel-Schneider. OIL: An ontology infrastructure for the semantic web. IEEE Intelligent Systems, 16(2):38–45, 2001. [Ferg, 1991] S. Ferg. Cardinality concepts in entity-relationship modeling. In Proc. of the 10th Int. Conf. on the Entity-Relationship Approach (ER’91), pages 1–30, 1991. [Fikes, 1982] Richard E. Fikes. Klonetalk. In Schmolze and Brachman [1982]. Published as BBN Research Report 4842, Bolt Beranek and Newman Inc., June 1982. [Fikes and Kehler, 1985] Richard Fikes and Tom Kehler. The role of frame-based representation in reasoning. Communications of the ACM, 28(9):904–920, 1985. [Fikes and McGuinness, 2001] Richard E. Fikes and Deborah L. McGuinness. An axiomatic semantics for RDF, RDF Schema, and DAML+OIL. Technical Report KSL-01-01, Stanford University KSL, 2001. Available at http://www.ksl.stanford.edu/people/dlm/daml-semantics/ abstract-axiomatic-semantics.html. [Fine, 1972] K. Fine. In so many possible worlds. Notre Dame J. of Formal Logic, 13(4):516–520, 1972. [Finger and Gabbay, 1992] Michael Finger and Dov Gabbay. Adding a temporal dimension to a logic system. J. of Logic, Language and Information, 2:203–233, 1992. [Fischer, 1992] Michael J. Fischer. The integration of temporal operators into a terminological representation system. KIT-Report 92, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1992. [Fischer and Ladner, 1979] Michael J. Fischer and Richard E. Ladner. Propositional dynamic logic of regular programs. J. of Computer and System Sciences, 18:194–211, 1979. [Fitting, 1993] Melvin Fitting. Basic modal logic. In Handbook of Logic in Artiﬁcial Intelligence and Logic Programming, volume 1, pages 365–448. Oxford Science Publications, 1993. [Fleischanderl et al., 1998] Gerhard Fleischanderl, Gerhard E. Friedrich, Alis Haselboeck, Herwig Schreiner, and Markus Stumptner. Conﬁguring large systems using generative constraint satisfaction. IEEE Intelligent Systems, pages 59–68, 1998. [Flex, 1999] Lpa-ﬂex. http://www.lpa.co.uk/, 1999. [Franconi, 1993] Enrico Franconi. A treatment of plurals and plural quantiﬁcations based on a theory of collections. Minds and Machines, 3(4):453–474, 1993. [Franconi, 1994] Enrico Franconi. Description logics for natural language processing. In Working Notes of the AAAI Fall Symposium on “Knowledge Representation for Natural Language Processing in Implemented Systems”, pages 37–44, 1994. [Franconi, 1996] Enrico Franconi. Logical form and knowledge representation: Towards a reconciliation. In Working Notes of the AAAI Fall Symposium on “Knowledge Representation Systems based on Natural Language”, pages 20–24, 1996

[Franconi and Ng, 2000] Enrico Franconi and Gary Ng. The i.com tool for intelligent conceptual modeling. In Proc. of the 7th Int. Workshop on Knowledge Representation meets Databases (KRDB 2000), pages 45–53. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-29/, 2000. [Franconi and Rabito, 1994] Enrico Franconi and Vania Rabito. A relation-based Description Logic. In Proc. of the 1994 Description Logic Workshop (DL’94), pages 62–66. Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI), 1994. Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI) Technical Report D-94-10. [Franconi et al., 1993] Enrico Franconi, Alessandra Giorgi, and Fabio Pianesi. Tense and aspect: a mereological approach. In Proc. of the 13th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’93), pages 1222–1228, 1993. [Franconi et al., 1994] Enrico Franconi, Alessandra Giorgi, and Fabio Pianesi. A mereological characterization of temporal and aspectual phenomena. In Carlos Martin-Vide, editor, Current Issues in Mathematical Linguistics, North-Holland Linguistic Series, pages 269–278. Elsevier Science Publishers (North-Holland), Amsterdam, 1994. [Frazier and Pitt, 1994] Michael Frazier and Leonard Pitt. Classic learning. In Proc. of the 7th Annual ACM Conference on Computational Learning Theory, pages 23–34, New Brunswick, New Jersey, 1994. ACM Press and Addison Wesley. [Freeman, 1995] J. W. Freeman. Improvements to Propositional Satisﬁability Search Algorithms. PhD thesis, Department of Computer and Information Science, University of Pennsylvania, 1995. [Freeman, 1996] J. W. Freeman. Hard random 3-SAT problems and the Davis–Putnam procedure. Artiﬁcial Intelligence, 81:183–198, 1996. [Freuder et al., 2001] Eugene C. Freuder, Chavalit Likitvivatanavong, and Richard J. Wallace. Explanation and implication for conﬁguration problems. In Proc. of the 17th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI 2001) Workshop on Conﬁguration, 2001. [Friedman et al., 1994] C. Friedman, J. J. Cimino, and S. B. Johnson. A schema for representing medical language applied to clinical radiology. J. of the American Medical Informatics Association, 1(3):233–248, 1994. [Gabbay, 1972] Dov M. Gabbay. Craig’s interpolation theorem for modal logics. In Proceedings of the Logic Conference, volume 255 of Lecture Notes in Mathematics, pages 111–127. Springer, 1972. [Gabbay et al., 1994] Dov M. Gabbay, Ian Hodkinson, and Mark Reynolds. Temporal Logic: Mathematical Foundations and Computational Aspects, volume 28 of Oxford Logic Guides. Oxford University Press, 1994. [Gabbay et al., 2002] Dov Gabbay, Agnes Kurusz, Frank Wolter, and Michael Zakharyaschev. Many-dimensional Modal Logics: Theory and Applications. Elsevier, 2002. To appear. [Gangemi et al., 1996] A. Gangemi, G. Steve, and F. Giacomelli. ONIONS: An ontological methodology for taxonomic integration. In Proc. of ECAI’96 Workshop on Ontological Engineering, 1996. [Garey and Johnson, 1979] M. R. Garey and D. S. Johnson. Computers and Intractability—A guide to NP-completeness. W. H. Freeman and Company, San Francisco (CA, USA), 1979. [Gargov and Goranko, 1993] George Gargov and Valentin Goranko. Modal logic with names. J. of Philosophical Logic, 22:607–636, 1993.

[Gargov and Passy, 1988] George Gargov and Solomon Passy. Determinism and looping in combinatory PDL. Theoretical Computer Science, 61:259–277, 1988. [Gehrke et al., 1991] Manfred Gehrke, Gerrit Burkert, Peter Forster, and Enrico Franconi. Natural language processing and Description Logics. In Christof Peltason, Kai von Luck, and Carsten Kindermann, editors, Proc. of the Terminological Logic Users Workshop, pages 162–164. Department of Computer Science, Technische Universit¨at Berlin (Germany), 1991. [Gen, 1995] Gensym Corporation, 125 Cambridge Park Drive, Cambridge (MA), USA. G2 Reference Manual for G2 version 4.0., 1995. [Genesereth and Fikes, 1992] Michael R. Genesereth and Richard E. Fikes. Knowledge Interchange Format, version 3.0 reference manual. Technical Report Logic-92-1, Stanford University, 1992. [Gent and Walsh, 1999] I. P. Gent and T. Walsh. Beyond NP: the QSAT phase transition. In Proc. of the 16th Nat. Conf. on Artiﬁcial Intelligence (AAAI’99). AAAI Press/The MIT Press, 1999. [Gil and Melz, 1996] Yolanda Gil and Eric Melz. Explicit representations of problem-solving strategies to support knowledge acquisition. In Proc. of the 13th Nat. Conf. on Artiﬁcial Intelligence (AAAI’96), pages 469–476, 1996. [Ginsberg, 1987] Matthew L. Ginsberg, editor. Readings in Nonmonotonic Reasoning. Morgan Kaufmann, Los Altos, 1987. [Ginsberg, 1993] Matthew L. Ginsberg. Dynamic backtracking. J. of Artiﬁcial Intelligence Research, 1:25–46, 1993. [Giunchiglia and Sebastiani, 1996a] Fausto Giunchiglia and Roberto Sebastiani. Building decision procedures for modal logics from propositional decision procedures—the case study of modal K. In Michael A. McRobbie and John K. Slaney, editors, Proc. of the 13th Int. Conf. on Automated Deduction (CADE’96), volume 1104 of Lecture Notes in Artiﬁcial Intelligence, pages 583–597. Springer, 1996. [Giunchiglia and Sebastiani, 1996b] Fausto Giunchiglia and Roberto Sebastiani. A SAT-based decision procedure for ALC. In Proc. of the 5th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’96), pages 304–314, 1996. [Giunchiglia and Tacchella, 2000] Enrico Giunchiglia and Armando Tacchella. A subset-matching size-bounded cache for satisﬁability in modal logics. In Proc. of the 4th Int. Conf. on Analytic Tableaux and Related Methods (TABLEAUX 2000), number 1847 in Lecture Notes in Artiﬁcial Intelligence, pages 237–251. Springer, 2000. [Giunchiglia et al., 1999] Enrico Giunchiglia, Fausto Giunchiglia, and Armando Tacchella. *SAT, KSATC, DLP and TA: A comparative analysis. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 110–114. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Giunchiglia et al., 2001] Enrico Giunchiglia, Massimo Narizzano, and Armando Tacchella. QuBE: A system for deciding boolean formulas satisﬁability. In Proc. of the Int. Joint Conf. on Automated Reasoning (IJCAR 2001), number 2083 in Lecture Notes in Artiﬁcial Intelligence, pages 364–369. Springer, 2001. [Giunchiglia et al., 2002] Enrico Giunchiglia, Fausto Giunchiglia, and Armando Tacchella. SAT based decision procedures for classical modal logics. J. of Automated Reasoning, 2001. To appear. [Goasdoue and Rousset, 2000] Francois Goasdoue and Marie-Christine Rousset. Rewriting conjunctive queries using views in Description Logics with existential restrictions. In Proc. of the 2000 Description Logic Workshop (DL 2000), pages

113–122. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-33/, 2000. [Goasdoue et al., 2000] Francois Goasdoue, Veronique Lattes, and Marie-Christine Rousset. The use of CARIN language and algorithms for information integration: The Picsel system. Int. J. of Cooperative Information Systems, 9(4):383–401, 2000. [Gon¸calv`es and Gr¨adel, 2000] E. Gon¸calv`es and E. Gr¨adel. Decidability issues for action guarded logics. In Proc. of the 2000 Description Logic Workshop (DL 2000), pages 123–132. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-33/, 2000. [Gr¨aber et al., 1995] A. Gr¨aber, H. B¨urckert, and A. Laux. Terminological reasoning with knowledge and belief. In A. Laux and H. Wansing, editors, Knowledge and Belief in Philosophy and Artiﬁcial Intelligence, pages 29–61. Akademie Verlag, 1995. [Gr¨adel, 1998] Erich Gr¨adel. Guarded fragments of ﬁrst-order logic: A perspective for new Description Logics? In Proc. of the 1998 Description Logic Workshop (DL’98). CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-11/, 1998. [Gr¨adel, 1999] Erich Gr¨adel. On the restraining power of guards. J. of Symbolic Logic, 64:1719–1742, 1999. [Gr¨adel and Walukiewicz, 1999] Erich Gr¨adel and Igor Walukiewicz. Guarded ﬁxed point logic. In Proc. of the 14th IEEE Symp. on Logic in Computer Science (LICS’99), pages 45–54. IEEE Computer Society Press, 1999. [Gr¨adel et al., 1997a] Erich Gr¨adel, Phokion G. Kolaitis, and Moshe Y. Vardi. On the decision problem for two-variable ﬁrst-order logic. Bulletin of Symbolic Logic, 3(1):53–69, 1997. [Gr¨adel et al., 1997b] Erich Gr¨adel, Martin Otto, and Eric Rosen. Two-variable logic with counting is decidable. In Proc. of the 12th IEEE Symp. on Logic in Computer Science (LICS’97), pages 306–317. IEEE Computer Society Press, 1997. [Grant and Minker, 1984] John Grant and Jack Minker. Numerical dependencies. In H. Gallaire, J. Minker, and J.-M. Nicolas, editors, Advances in Database Theory II. Plenum Publ. Co., New York, 1984. [Grosso et al., 1999] W. E. Grosso, H. Eriksson, R. W. Fergerson, J. H. Gennari, S. W. Tu, and M. A. Musen. Knowledge modelling at the millennium (The design and evolution of Prot´eg´e-2000). In Proc. of Knowledge Acqusition Workshop (KAW’99), 1999. [Guarino and Welty, 2000] Nicola Guarino and Christopher A. Welty. Ontological analysis of taxonomic relationships. In Proc. of the 19th Int. Conf. on Conceptual Modeling (ER 2000), pages 210–224, 2000. [G¨unsel and Wittmann, 2001] Christian G¨unsel and Marco Wittmann. Towards an implementation of the temporal Description Logic T LALC. In Proc. of the 2001 Description Logic Workshop (DL 2001), pages 162–169. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-49/, 2001. [Haarslev and M¨oller, 1999] Volker Haarslev and Ralf M¨oller. RACE system description. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 130–132. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Haarslev and M¨oller, 2000] Volker Haarslev and Ralf M¨oller. Expressive ABox reasoning with number restrictions, role hierarchies, and transitively closed roles. In Proc. of the 7th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2000), pages 273–284, 2000. [Haarslev and M¨oller, 2001a] Volker Haarslev and Ralf M¨oller. Combining tableaux and algebraic methods for reasoning with qualiﬁed number restrictions. In Proc. of the 2001 Description Logic Workshop (DL 2001), pages 152–161. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-49/, 2001.

[Haarslev and Moller, 2001b] Volker Haarslev and Ralf Moller. Description of the RACER system and its applications. In Proc. of the 2001 Description Logic Workshop (DL 2001), pages 132–141. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-49/, 2001. [Haarslev and M¨oller, 2001c] Volker Haarslev and Ralf M¨oller. High performance reasoning with very large knowledge bases: A practical case study. In Proc. of the 17th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI 2001), pages 161–168, 2001. [Haarslev and M¨oller, 2001d] Volker Haarslev and Ralf M¨oller. Optimizing reasoning in Description Logics with qualiﬁed number restrictions. In Proc. of the 2001 Description Logic Workshop (DL 2001), pages 142–151. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-49/, 2001. [Haarslev and M¨oller, 2001e] Volker Haarslev and Ralf M¨oller. RACER system description. In Proc. of the Int. Joint Conf. on Automated Reasoning (IJCAR 2001), volume 2083 of Lecture Notes in Artiﬁcial Intelligence, pages 701–705. Springer, 2001. [Haarslev et al., 1998] Volker Haarslev, Carsten Lutz, and Ralf M¨oller. Foundations of spatioterminological reasoning with Description Logics. In Proc. of the 6th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR’98), pages 112–123, 1998. [Haarslev et al., 1999] Volker Haarslev, Carsten Lutz, and Ralf M¨oller. A Description Logic with concrete domains and role-forming predicates. J. of Logic and Computation, 9(3):351–384, 1999. [Haarslev et al., 2001] Volker Haarslev, Ralf M¨oller, and Michael Wessel. The Description Logic ALCNHR+ extended with concrete domains: A practically motivated approach. In Proc. of the Int. Joint Conf. on Automated Reasoning (IJCAR 2001), pages 29–44, 2001. [Hagen et al., 1999] Paul Hagen, David Weisman, Harley Manning, and Randy Souza. Guided search for eCommerce. In The Forrester Report. Cambridge, MA, January 1999. [Hahn et al., 1999a] U. Hahn, M. Romacker, and S. Schulz. How knowledge drives understanding—matching medical ontologies with the needs of medical language processing. AI Magazine, 15(1):25–52, 1999. [Hahn et al., 1999b] Udo Hahn, Stefan Schulz, and Martin Romacker. Part-whole reasoning: a case study in medical ontology engineering. IEEE Intelligent Systems, 14(5):59–67, 1999. [Hahn et al., 1999c] Udo Hahn, Stefan Schulz, and Martin Romacker. Partonomic reasoning as taxonomic reasoning in medicine. In Proc. of the 16th Nat. Conf. on Artiﬁcial Intelligence (AAAI’99), pages 271–276, 1999. [Halpern and Moses, 1992] Joseph Y. Halpern and Yoram Moses. A guide to completeness and complexity for modal logics of knowledge and belief. Artiﬁcial Intelligence, 54:319–379, 1992. [Halpern and Shoham, 1991] Joseph Y. Halpern and Yoav Shoham. A propositional modal logic of time intervals. J. of the ACM, 38:935–962, 1991. [Hammer and McLeod, 1981] Michael Hammer and Dennis McLeod. Database description with SDM: A semantic database model. ACM Trans. on Database Systems, 6(3):351–386, 1981. [Hanschke, 1992] Philipp Hanschke. Specifying role interaction in concept languages. In Proc. of the 3rd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’92), pages 318–329. Morgan Kaufmann, Los Altos, 1992.

[Harel, 1984] David Harel. Dynamic logic. In D. M. Gabbay and F. Guenthner, editors, Handbook of Philosophical Logic, volume II, pages 497–604. D. Reidel Publishing Company, 1984. [Harel, 1985] David Harel. Recurring dominoes: Making the highly undecidable highly understandable. Ann. of Discrete Mathematics, 24:51–72, 1985. [Harel, 1986] David Harel. Effective transformations of inﬁnite trees, with applications to high undecidability, dominoes, and fairness. J. of the ACM, 33(1):224–248, 1986. [Harel et al., 2000] David Harel, Dexter Kozen, and Jerzy Tiuryn. Dynamic Logic. The MIT Press, 2000. [Hayes, 1977] Patrick J. Hayes. In defense of logic. In Proc. of the 5th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’77), pages 559–565, 1977. A longer version appeared in The Psychology of Computer Vision (1975). Republished in [Brachman and Levesque, 1985]. [Hayes, 1979] Patrick J. Hayes. The logic of frames. In D. Metzing, editor, Frame Conceptions and Text Understanding, pages 46–61. Walter de Gruyter and Co., 1979. Republished in [Brachman and Levesque, 1985]. [Heﬂin and Hendler, 2001] Jeff Heﬂin and James Hendler. A portrait of the semantic web in action. IEEE Intelligent Systems, 16(2):54–59, 2001. [Heinsohn, 1994] Jochen Heinsohn. Probabilistic Description Logics. In Ramon Lopez de Mantaras and David Poole, editors, Proc. of the 10th Conf. on Uncertainty in Artiﬁcial Intelligence, pages 311–318, Seattle, Washington, 1994. Morgan Kaufmann, Los Altos. [Heinsohn et al., 1992] Jochen Heinsohn, Daniel Kudenko, Bernhard Nebel, and Hans-J¨urgen Proﬁtlich. An empirical analysis of terminological representation systems. In Proc. of the 10th Nat. Conf. on Artiﬁcial Intelligence (AAAI’92), pages 767–773. AAAI Press/The MIT Press, 1992. [Heinsohn et al., 1994] Jochen Heinsohn, Daniel Kudenko, Bernhard Nebel, and Hans-J¨urgen Proﬁtlich. An empirical analysis of terminological representation systems. Artiﬁcial Intelligence, 68:367–397, 1994. [Hemaspaandra, 1999] Edith Hemaspaandra. The complexity of poor man’s logic. In J. Gerbrandy, M. Marx, M. de Rijke, and Y. Venema, editors, Essays Dedicated to Johan van Benthem on the Occasion of his 50th Birthday. Amsterdam University Press, 1999. [Hendler and McGuinness, 2000] James Hendler and Deborah L. McGuinness. The darpa agent markup language. IEEE Intelligent Systems, 15(6):67–73, 2000. [Herzog and Rollinger, 1991] O. Herzog and C. R. Rollinger, editors. Text Understanding in LILOG. Springer, 1991. [Heuerding and Schwendimann, 1996] A. Heuerding and S. Schwendimann. A benchmark method for the propositional modal logics K, KT, and S4. Technical report IAM-96-015, University of Bern, Switzerland, 1996. [Hobbs et al., 1993] J. R. Hobbs, M. Stickel, D. Appelt, and P. Martin. Interpretation as abduction. Artiﬁcial Intelligence, 63:69–142, 1993. [Hoffmann and Koehler, 1999] J¨org Hoffmann and Jana Koehler. A new method to index and query sets. In Proc. of the 16th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’99), pages 462–467, 1999. [Hollunder, 1990] Bernhard Hollunder. Hybrid inferences in KL-ONE-based knowledge representation systems. In Proc. of the German. Workshop on Artiﬁcial Intelligence, pages 38–47. Springer, 1990. [Hollunder, 1994a] Bernhard Hollunder. Algorithmic Foundations of Terminological Knowledge Representation Systems. PhD thesis, University of Saarbr¨ucken, Department of Computer Science 1994

[Hollunder, 1994b] Bernhard Hollunder. An alternative proof method for possibilistic logic and its application to terminological logics. In Ramon Lopez de Mantaras and David Poole, editors, Proc. of the 10th Conf. on Uncertainty in Artiﬁcial Intelligence, pages 327–335, Seattle, Washington, 1994. Morgan Kaufmann, Los Altos. [Hollunder, 1996] Bernhard Hollunder. Consistency checking reduced to satisﬁability of concepts in terminological systems. Ann. of Mathematics and Artiﬁcial Intelligence, 18(2–4):133–157, 1996. [Hollunder and Baader, 1991a] Bernhard Hollunder and Franz Baader. Qualifying number restrictions in concept languages. Technical Report RR-91-03, Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI), Kaiserslautern (Germany), 1991. An abridged version appeared in Proc. of the 2nd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’91). [Hollunder and Baader, 1991b] Bernhard Hollunder and Franz Baader. Qualifying number restrictions in concept languages. In Proc. of the 2nd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’91), pages 335–346, 1991. [Hollunder and Nutt, 1990] Bernhard Hollunder and Werner Nutt. Subsumption algorithms for concept languages. Technical Report RR-90-04, Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI), Kaiserslautern (Germany), 1990. [Hollunder et al., 1990] Bernhard Hollunder, Werner Nutt, and Manfred Schmidt-Schauß. Subsumption algorithms for concept description languages. In Proc. of the 9th Eur. Conf. on Artiﬁcial Intelligence (ECAI’90), pages 348–353, London (United Kingdom), 1990. Pitman. [Hollunder et al., 1991] Berhnard Hollunder, Armin Laux, Hans-J¨urgen Proﬁtlich, and T. Trenz. KRIS-manual. Technical report, Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz (DFKI), 1991. [Hoppe et al., 1993] Thomas Hoppe, Carsten Kindermann, Joachim Quantz, Albrecht Schmiedel, and Martin Fischer. BACK V5: Tutorial and manual. KIT-Report 100, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1993. [Horrocks, 1997a] Ian Horrocks. Optimisation techniques for expressive Description Logics. Technical Report UMCS-97-2-1, University of Manchester, Department of Computer Science, 1997. [Horrocks, 1997b] Ian Horrocks. Optimising Tableaux Decision Procedures for Description Logics. PhD thesis, University of Manchester, 1997. [Horrocks, 1998a] Ian Horrocks. The FaCT system. In Harrie de Swart, editor, Proc. of the 2nd Int. Conf. on Analytic Tableaux and Related Methods (TABLEAUX’98), volume 1397 of Lecture Notes in Artiﬁcial Intelligence, pages 307–312. Springer, 1998. [Horrocks, 1998b] Ian Horrocks. Using an expressive Description Logic: FaCT or ﬁction? In Proc. of the 6th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR’98), pages 636–647, 1998. [Horrocks, 1999] Ian Horrocks. FaCT and iFaCT. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 133–135. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Horrocks and Patel-Schneider, 1998a] Ian Horrocks and Peter F. Patel-Schneider. Comparing subsumption optimizations. In Proc. of the 1998 Description Logic Workshop (DL’98), pages 90–94. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-11/, 1998. [Horrocks and Patel-Schneider, 1998b] Ian Horrocks and Peter F. Patel-Schneider. DL systems comparison In Proc of the 1998 Description Logic Workshop (DL’98)

pages 55–57. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-11/, 1998. [Horrocks and Patel-Schneider, 1998c] Ian Horrocks and Peter F. Patel-Schneider. FaCT and DLP: Automated reasoning with analytic tableaux and related methods. In Proc. of the 2nd Int. Conf. on Analytic Tableaux and Related Methods (TABLEAUX’98), pages 27–30, 1998. [Horrocks and Patel-Schneider, 1998d] Ian Horrocks and Peter F. Patel-Schneider. Optimising propositional modal satisﬁability for Description Logic subsumption. In Proc. of the 4th Int. Conf. on Artiﬁcial Intelligence and Symbolic Computation (AISC’98), 1998. [Horrocks and Patel-Schneider, 1999] Ian Horrocks and Peter F. Patel-Schneider. Optimizing Description Logic subsumption. J. of Logic and Computation, 9(3):267–293, 1999. [Horrocks and Patel-Schneider, 2001] Ian Horrocks and Peter F. Patel-Schneider. The generation of DAML+OIL. In Proc. of the 2001 Description Logic Workshop (DL 2001), pages 30–35. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-49/, 2001. [Horrocks and Rector, 1996] Ian Horrocks and Alan Rector. Using a Description Logic with concept inclusions. In Proc. of the 1996 Description Logic Workshop (DL’96), number WS-96-05 in AAAI Technical Report, pages 132–135. AAAI Press/The MIT Press, 1996. [Horrocks and Sattler, 1999] Ian Horrocks and Ulrike Sattler. A Description Logic with transitive and inverse roles and role hierarchies. J. of Logic and Computation, 9(3):385–410, 1999. [Horrocks and Sattler, 2001] Ian Horrocks and Ulrike Sattler. Ontology reasoning in the SHOQ(D) Description Logic. In Proc. of the 17th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI 2001), pages 199–204, 2001. [Horrocks and Tessaris, 2000] Ian Horrocks and Sergio Tessaris. A conjunctive query language for Description Logic ABoxes. In Proc. of the 17th Nat. Conf. on Artiﬁcial Intelligence (AAAI 2000), pages 399–404, 2000. [Horrocks and Tobies, 2000] Ian Horrocks and Stephan Tobies. Reasoning with axioms: Theory and practice. In Proc. of the 7th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2000), pages 285–296, 2000. [Horrocks et al., 1996] Ian Horrocks, Alan Rector, and Carole Goble. A description logic based schema for the classiﬁcation of medical data. In Proc. of the 3rd Int. Workshop on Knowledge Representation meets Databases (KRDB’96), pages 24–28. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-4/, 1996. [Horrocks et al., 1999] Ian Horrocks, Ulrike Sattler, and Stephan Tobies. Practical reasoning for expressive Description Logics. In Harald Ganzinger, David McAllester, and Andrei Voronkov, editors, Proc. of the 6th Int. Conf. on Logic for Programming and Automated Reasoning (LPAR’99), number 1705 in Lecture Notes in Artiﬁcial Intelligence, pages 161–180. Springer, 1999. [Horrocks et al., 2000a] I. Horrocks, D. Fensel, J. Broekstra, S. Decker, M. Erdmann, C. Goble, F. van Harmelen, M. Klein, S. Staab, R. Studer, and E. Motta. OIL: The Ontology Inference Layer. Technical Report IR-479, Vrije Universiteit Amsterdam, Faculty of Sciences, September 2000. [Horrocks et al., 2000b] Ian Horrocks, Ulrike Sattler, and Stephan Tobies. Practical reasoning for very expressive Description Logics. J. of the Interest Group in Pure and Applied Logic, 8(3):239–264, 2000.

[Horrocks et al., 2000c] Ian Horrocks, Ulrike Sattler, and Stephan Tobies. Reasoning with individuals for the Description Logic SHIQ. In David McAllester, editor, Proc. of the 17th Int. Conf. on Automated Deduction (CADE 2000), volume 1831 of Lecture Notes in Computer Science, pages 482–496. Springer, 2000. [Horty et al., 1987] J. F. Horty, R. H. Thomason, and D. S. Touretzky. A skeptical theory of inheritance in nonmonotonic semantic networks. In Proc. of the 6th Nat. Conf. on Artiﬁcial Intelligence (AAAI’87), pages 358–363, 1987. [Hovy and Knight, 1993] E. H. Hovy and K. Knight. Motivation for shared ontologies: An example from the Pangloss collaboration. In Proc. of the IJCAI’93 Workshop on Knowledge Sharing and Information Interchange, 1993. [Huitt and Wilde, 1992] R. Huitt and N. Wilde. Maintenance support for object-oriented programs. IEEE Trans. on Software Engineering, 18(12), 1992. [Hull, 1988] Richard Hull. A survey of theoretical research on typed complex database objects. In J. Paredaens, editor, Databases, pages 193–256. Academic Press, 1988. [Hull and King, 1987] R. B. Hull and R. King. Semantic database modelling: Survey, applications and research issues. ACM Computing Surveys, 19(3):201–260, September 1987. [Hustadt and Schmidt, 1997] Ulrich Hustadt and Renate A. Schmidt. On evaluating decision procedures for modal logic. In Proc. of the 15th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’97), pages 202–207, 1997. [Hustadt and Schmidt, 2000] Ulrich Hustadt and Renate A. Schmidt. Issues of decidability for Description Logics in the framework of resolution. In R. Caferra and G. Salzer, editors, Automated Deduction in Classical and Non-Classical Logics, volume 1761 of Lecture Notes in Artiﬁcial Intelligence, pages 191–205. Springer, 2000. [Israel and Brachman, 1984] David J. Israel and Ronald J. Brachman. Some remarks on the semantics of representation languages. In M. L. Brodie, J. Mylopoulos, and J. W. Schmidt, editors, On Conceptual Modeling: Perspectives from Artiﬁcial Intelligence Databases and Programming Languages. Springer, 1984. [Jackendoff, 1990] Ray Jackendoff. Semantic Structures. Current Studies in Linguistics Series. The MIT Press, 1990. [Jacobs, 1991] Paul S. Jacobs. Integrating language and meaning in structured inheritance networks. In [Sowa 1991], pages 527–542. [Jacobson et al., 1998] Ivar Jacobson, Grady Booch, and James Rumbaugh. The Uniﬁed Modeling Language User Guide. Addison Wesley Publ. Co., Reading, Massachussetts, 1998. [Jaeger, 1994] Manfred Jaeger. Probabilistic reasoning in terminological logics. In Pietro Torasso, Jon Doyle, and Erik Sandewall, editors, Proc. of the 4th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’94), pages 305–316, 1994. [Jang and Patil, 1989] Y. Jang and R. Patil. KOLA: A knowledge organisation language. In Proc. of the 13th Annual Symposium on Computer Applications in Medical Care (SCAMC’89), pages 71–75, 1989. [Jeroslow and Wang, 1990] R. Jeroslow and J. Wang. Solving propositional satisﬁability problems. Ann. of Mathematics and Artiﬁcial Intelligence, 1:167–187, 1990. [Johnson, 1990] D. S. Johnson. A catalog of complexity classes. In Handbook of Theoretical Computer Science, volume A, chapter 2. Elsevier Science Publishers (North-Holland), Amsterdam, 1990. [Johnson et al., 2000] P. D. Johnson, S. Tu, N. Booth, B. Sugden, and I. Purves. Using scenarios in chronic disease management guidelines for primary care. In Proc.

of the American Medical Informatics Society Annual Fall Symposium, pages 389–393, 2000. [Joshi, 1994] Aravind K. Joshi. Introduction to special issue on tree-adjoining grammars. Computational Intelligence, 10(4):vii–xv, 1994. [Juengst and Heinrich, 1998] Werner E. Juengst and Michael Heinrich. Using resource balancing to conﬁgure modular systems. IEEE Intelligent Systems, pages 50–58, 1998. [Kaczmarek et al., 1986] Thomas S. Kaczmarek, Raymond Bates, and Gabriel Robins. Recent developments in NIKL. In Proc. of the 5th Nat. Conf. on Artiﬁcial Intelligence (AAAI’86), pages 978–985, 1986. [Kalmes, 1988] J. Kalmes. SB-Graph user manual. Technical Report SFB 314, Memo Nr. 30, Universit¨at des Saarlandes, Fachbereich Informatik, Saarbr¨ucken (Germany), 1988. [Kalmes, 1990] J. Kalmes. SB-Graph. Technical Report SFB 314, Memo Nr. 44, Universit¨at des Saarlandes, Fachbereich Informatik, Saarbr¨ucken (Germany), 1990. In German. [Karp, 1992] Peter D. Karp. The design space of knowledge representation systems. Technical Report SRI AI Technical Note 520, SRI International, Menlo Park (CA, USA), 1992. [Karp et al., 1999] P. D. Karp, V. K. Chaudhri, and J. Thomere. XOL: An XML-based ontology exchange language. [Kent, 1979] William Kent. Limitations of record-base information models. ACM Trans. on Database Systems, 4(1):107–131, 1979. [Kerdiles and Salvat, 1997] Gwen Kerdiles and Eric Salvat. A sound and complete CG proof procedure combining projections with analytic tableaux. In D. Lukose, H. Delugach, M. Keeler, L. Searle, and J. Sowa, editors, Proc. of the 5th Int. Conf. on Conceptual Structures (ICCS’97), volume 1257 of Lecture Notes in Computer Science, pages 371–385. Springer, 1997. [Kessel et al., 1995] T. Kessel, F. Rousselot, M. Schlick, and O. Stern. Use of DL within the framework of DBMS. In Proc. of the 2nd Int. Workshop on Knowledge Representation meets Databases (KRDB’95). CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-2/, 1995. [Kim, 1990] Won Kim. Introduction to Object-Oriented Databases. The MIT Press, 1990. [Kim and Lochovsky, 1989] Won Kim and Frederick H. Lochovsky, editors. Object-Oriented Concepts, Databases, and Applications. ACM Press and Addison Wesley, New York (USA), 1989. [Kindermann, 1992] Carsten Kindermann. Retraction of object descriptions in BACK. KIT-Report 105, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1992. [Kindermann and Randi, 1990] C. Kindermann and P. Randi. Object recognition and retrieval in the BACK system. KIT-Report 86, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1990. [Kirk et al., 1995] Thomas Kirk, Alon Y. Levy, Yehoshua Sagiv, and Divesh Srivastava. The Information Manifold. In Proceedings of the AAAI 1995 Spring Symp. on Information Gathering from Heterogeneous, Distributed Enviroments, pages 85–91, 1995. [Knight and Luk, 1994] K. Knight and S. Luk. Building a large knowledge base for machine translation. In Proc. of the 12th Nat. Conf. on Artiﬁcial Intelligence (AAAI’94), 1994.

[Knight et al., 1995] K. Knight, I. Chander, M. Haines, V. Hatzivassiloglou, E. Hovy, M. Iida, S. K. Luk, R. Whitney, and K. Yamada. Filling knowledge gaps in a broad-coverage machine translation system. In Proc. of the 14th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’95), pages 1390–1396, 1995. [Kobsa, 1991a] Alfred Kobsa. First experiences with the SB-ONE knowledge representation workbench in natural-language applications. SIGART Bull., 2(3):70–76, 1991. [Kobsa, 1991b] Alfred Kobsa. Utilizing knowledge: The components of the SB-ONE knowledge representation workbench. In [Sowa 1991], pages 457–486. [Koetzle et al., 2001] Laura Koetzle, Paul Hagen, Hillary Drohan, and Moira Dorsey. Smarter sales of complex goods. In The Forrester Report. Cambridge, MA, September 2001. [Kohn et al., 2000] L. T. Kohn, J. M. Corrigan, and M. S. Donaldson, editors. To Err is Human: Building a Safer Health System. National Academy Press, 2000. [Koller et al., 1997] Daphne Koller, Alon Levy, and Avi Pfeffer. P-CLASSIC: A tractable probabilistic Description Logic. In Proc. of the 14th Nat. Conf. on Artiﬁcial Intelligence (AAAI’97), pages 390–397. AAAI Press/The MIT Press, 1997. [Kozen, 1983] Dexter Kozen. Results on the propositional µ-calculus. Theoretical Computer Science, 27:333–354, 1983. [Kozen and Tiuryn, 1990] Dexter Kozen and Jerzy Tiuryn. Logics of programs. In Jan van Leeuwen, editor, Handbook of Theoretical Computer Science—Formal Models and Semantics, pages 789–840. Elsevier Science Publishers (North-Holland), Amsterdam, 1990. [Kripke, 1980] S. Kripke. Naming and Necessity. Harvard University Press, 1980. [Kuper and Vardi, 1993] Gabriel M. Kuper and Moshe Y. Vardi. On the complexity of queries in the logical data model. Theoretical Computer Science, 116:33–58, 1993. [Kurtonina and de Rijke, 1997] Natasha Kurtonina and Maarten de Rijke. Classifying Description Logics. In Proc. of the 1997 Description Logic Workshop (DL’97), pages 49–53, 1997. [K¨usters, 1998] Ralf K¨usters. Characterizing the semantics of terminological cycles in ALN using ﬁnite automata. In Proc. of the 6th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR’98), pages 499–510, 1998. [K¨usters, 2001] Ralf K¨usters. Non-standard Inferences in Description Logics, volume 2100 of Lecture Notes in Artiﬁcial Intelligence. Springer, 2001. [K¨usters and Borgida, 2001] Ralf K¨usters and Alexander Borgida. What’s in an attribute? Consequences for the least common subsumer. J. of Artiﬁcial Intelligence Research, 14:167–203, 2001. [K¨usters and Molitor, 2001a] Ralf K¨usters and Ralf Molitor. Approximating most speciﬁc concepts in Description Logics with existential restrictions. In Franz Baader, Gerd Brewka, and Thomas Eiter, editors, Proc. of the Joint German/Austrian Conf. on Artiﬁcial Intelligence (KI 2001), volume 2174 of Lecture Notes in Artiﬁcial Intelligence, pages 33–47. Springer, 2001. [K¨usters and Molitor, 2001b] Ralf K¨usters and Ralf Molitor. Computing least common subsumers in ALEN. In Proc. of the 17th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI 2001), pages 219–224, 2001. [Ladner, 1977] Richard E. Ladner. The computational complexity of provability in systems of modal propositional logic. SIAM J. on Computing, 6(3):467–480, 1977.

[Lambrix et al., 1998] P. Lambrix, N. Shahmehri, and N. Wahlof. A default extension to Description Logics for use in an intelligent search engine. In Proc. of the 31st Hawaii Int. Conf. on System Sciences, Volume V—Modeling Technologies and Intelligent Systems Track, pages 28–35, 1998. [Lang, 1991] Ewald Lang. The LILOG ontology from a linguistic point of view. In [Herzog and Rollinger 1991], pages 464–481. [Laux, 1994] Armin Laux. Beliefs in multi-agent worlds: A terminological approach. In Proc. of the 11th Eur. Conf. on Artiﬁcial Intelligence (ECAI’94), pages 299–303, Amsterdam, The Netherlands, 1994. [Lavelli et al., 1992] Alberto Lavelli, Bernardo Magnini, and Carlo Strapparava. An approach to multilevel semantics for applied systems. In Proc. of the 3rd ACL Conference on Applied Natural Language Processing (ANLP’92), pages 17–24, 1992. [Lecluse and Richard, 1989] Christophe Lecluse and Philippe Richard. Modeling complex structures in object-oriented databases. In Proc. of the 8th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS’89), pages 362–369, 1989. [Lehmann, 1992] Fritz Lehmann, editor. Semantic Networks in Artiﬁcial Intelligence. Pergamon Press, Oxford (United Kingdom), 1992. [Lenzerini and Nobili, 1990] Maurizio Lenzerini and Paolo Nobili. On the satisﬁability of dependency constraints in entity-relationship schemata. Information Systems, 15(4):453–461, 1990. [Lenzerini and Schaerf, 1991] Maurizio Lenzerini and Andrea Schaerf. Concept languages as query languages. In Proc. of the 9th Nat. Conf. on Artiﬁcial Intelligence (AAAI’91), pages 471–476, 1991. [Lenzerini et al., 1991] Maurizio Lenzerini, Daniele Nardi, and Maria Simi, editors. Inheritance Hierarchies in Knowledge Representation and Programming Languages. John Wiley & Sons, 1991. [Levesque, 1984] Hector J. Levesque. Foundations of a functional approach to knowledge representation. Artiﬁcial Intelligence, 23:155–212, 1984. [Levesque and Brachman, 1987] Hector J. Levesque and Ron J. Brachman. Expressiveness and tractability in knowledge representation and reasoning. Computational Intelligence, 3:78–93, 1987. [Levy, 2000] Alon Y. Levy. Logic-based techniques in data integration. In Jack Minker, editor, Logic Based Artiﬁcial Intelligence. Kluwer Academic Publishers, 2000. [Levy and Rousset, 1996] Alon Y. Levy and Marie-Christine Rousset. CARIN: A representation language combining Horn rules and Description Logics. In Proc. of the 12th Eur. Conf. on Artiﬁcial Intelligence (ECAI’96), pages 323–327, 1996. [Levy and Rousset, 1997] Alon Y. Levy and Marie-Christine Rousset. CARIN: A representation language combining Horn rules and Description Logics. Technical report, AT&T, 1997. [Levy and Rousset, 1998] Alon Y. Levy and Marie-Christine Rousset. Combining Horn rules and Description Logics in CARIN. Artiﬁcial Intelligence, 104(1–2):165–209, 1998. [Levy et al., 1995] Alon Y. Levy, Divesh Srivastava, and Thomas Kirk. Data model and query evaluation in global information systems. J. of Intelligent Information Systems, 5:121–143, 1995. [Levy et al., 1996] Alon Y. Levy, Anand Rajaraman, and Joann J. Ordille. Query answering algorithms for information agents. In Proc. of the 13th Nat. Conf. on Artiﬁcial Intelligence (AAAI’96), pages 40–47, 1996.

[Libkin, 2000] Leonid Libkin. Logics with counting and local properties. ACM Trans. on Computational Logic, 1(1), 2000. [Lifschitz, 1991] Vladimir Lifschitz. Nonmonotonic databases and epistemic queries. In Proc. of the 12th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’91), pages 381–386, 1991. [Lifschitz, 1994] Vladimir Lifschitz. Minimal belief and negation as failure. Artiﬁcial Intelligence, 70:53–72, 1994. [Lindberg et al., 1993] D. Lindberg, B. Humphreys, and A. McCray. The uniﬁed medical language system. In J. van Bemmel, editor, Yearbook of Medical Informatics, pages 41–53. International Medical Informatics Association, 1993. [Lipkis, 1982] Thomas A. Lipkis. A KL-ONE classiﬁer. In [Schmolze and Brachman 1982], pages 128–145. Published as BBN Research Report 4842, Bolt Beranek and Newman Inc., June 1982. [Ludwig et al., 2000] Bernd Ludwig, G¨unther G¨orz, and Heinrich Niemann. Combining expression and content in domains for dialog managers. J. of Logic and Computation, 1(2):241–258, 2000. [Lussier et al., 1992] Y. A. Lussier, M. Maksud, B. Desruisseaux, P.-P. Yale, and R. St-Arneault. PureMD: A computerized patient record software for direct data entry by physicians using keyboard-free pen-based portable computer. In Proc. of the 16th Annual Symposium on Computer Applications in Medical Care (SCAMC’92), pages 261–263, 1992. [Lutz, 1999a] Carsten Lutz. Complexity of terminological reasoning revisited. In Proc. of the 6th Int. Conf. on Logic for Programming and Automated Reasoning (LPAR’99), volume 1705 of Lecture Notes in Artiﬁcial Intelligence, pages 181–200. Springer, 1999. [Lutz, 1999b] Carsten Lutz. Reasoning with concrete domains. In Thomas Dean, editor, Proc. of the 16th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’99), pages 90–95, Stockholm, Sweden, 1999. Morgan Kaufmann, Los Altos. [Lutz, 2001a] Carsten Lutz. Interval-based temporal reasoning with general TBoxes. In Proc. of the 17th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI 2001), pages 89–94, 2001. [Lutz, 2001b] Carsten Lutz. NEXPTIME-complete Description Logics with concrete domains. In Proc. of the Int. Joint Conf. on Automated Reasoning (IJCAR 2001), volume 2083 of Lecture Notes in Artiﬁcial Intelligence, pages 45–60. Springer, 2001. [Lutz and Sattler, 2000a] Carsten Lutz and Ulrike Sattler. The complexity of reasoning with boolean modal logic. In Proc. of Advances in Modal Logic 2000 (AiML 2000), 2000. [Lutz and Sattler, 2000b] Carsten Lutz and Ulrike Sattler. Mary likes all cats. In Proc. of the 2000 Description Logic Workshop (DL 2000), pages 213–226. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-33/, 2000. [Lutz and Sattler, 2001] Carsten Lutz and Ulrike Sattler. The complexity of reasoning with boolean modal logics. In F. Wolter, H. Wansing, M. de Rijke, and M. Zakharyaschev, editors, Advances in Modal Logics, volume 3. CSLI Publications, 2001. [Lutz et al., 1999] Carsten Lutz, Ulrike Sattler, and Stephan Tobies. A suggestion for an n-ary Description Logic. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 81–85. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Lutz et al., 2001a] Carsten Lutz, Ulrike Sattler, and Frank Wolter. Description logics and the two-variable fragment. In Proc. of the 2001 Description Logic Workshop

(DL 2001), pages 66–75. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-49/, 2001. [Lutz et al., 2001b] Carsten Lutz, Holger Sturm, Frank Wolter, and Michael Zakharyaschev. Tableaux for temporal Description Logic with constant domain. In Proc. of the Int. Joint Conf. on Automated Reasoning (IJCAR 2001), volume 2083 of Lecture Notes in Artiﬁcial Intelligence, pages 121–136. Springer, 2001. [Lutz et al., 2002] Carsten Lutz, Holger Sturm, Frank Wolter, and Michael Zakharyaschev. A tableau decision algorithm for modalized ALC with constant domains. Studia Logica, 2002. To appear. [MacGregor, 1988] Robert MacGregor. A deductive pattern matcher. In Proc. of the 7th Nat. Conf. on Artiﬁcial Intelligence (AAAI’88), pages 403–408, 1988. [MacGregor, 1991a] Robert MacGregor. The evolving technology of classiﬁcation-based knowledge representation systems. In John F. Sowa, editor, Principles of Semantic Networks, pages 385–400. Morgan Kaufmann, Los Altos, 1991. [MacGregor, 1991b] Robert MacGregor. Inside the LOOM description classiﬁer. SIGART Bull., 2(3):88–92, 1991. [MacGregor, 1994] Robert MacGregor. A description classiﬁer for the predicate calculus. In Proc. of the 12th Nat. Conf. on Artiﬁcial Intelligence (AAAI’94), pages 213–220, 1994. [MacGregor and Bates, 1987] Robert MacGregor and R. Bates. The Loom knowledge representation language. Technical Report ISI/RS-87-188, University of Southern California, Information Science Institute, Marina del Rey (CA, USA), 1987. [MacGregor and Brill, 1992] Robert MacGregor and David Brill. Recognition algorithms for the LOOM classiﬁer. In Proc. of the 10th Nat. Conf. on Artiﬁcial Intelligence (AAAI’92), pages 774–779. AAAI Press/The MIT Press, 1992. [MacGregor and Burstein, 1991] Robert MacGregor and Mark H. Burstein. Using a description classiﬁer to enhance knowledge representation. IEEE Expert, pages 41–46, July 1991. [Mallery, 1994] John Mallery. A Common LISP hypermedia server. In Proc. of the 1st Int. Conf. on The World-Wide Web. CERN, 1994. Available at http: //www.ai.mit.edu/projects/iiip/doc/cl-http/server-abstract.html. [Mameide and Montero, 1993] Margarida Mameide and Luıs Montero. Decidability of a terminological language with role negation and conjunction. In Proc. of the Compulog Net area meeting on Knowledge Representation and Reasoning, Lisbon, Portugal, 1993. Departamento de Informatica, Universidade Nova de Lisboa. [Mark, 1982] W. Mark. Realization. In [Schmolze and Brachman 1982]. Published as BBN Research Report 4842, Bolt Beranek and Newman Inc., June 1982. [Masarie et al., 1991] F. Masarie, R. Miller, O. Bouhaddou, N. Giuse, and H. Warner. An interlingua for electronic interchange of medical information: Using frames to map between clinical vocabularies. Computers in Biomedical Research, 24(4):379–400, 1991. [Massacci, 1999] Fabio Massacci. TANCS non classical system comparison. In Proc. of the 3rd Int. Conf. on Analytic Tableaux and Related Methods (TABLEAUX’99), volume 1617 of Lecture Notes in Artiﬁcial Intelligence. Springer, 1999. [Massacci, 2001] Fabio Massacci. Decision procedures for expressive Description Logics with intersection, composition, converse of roles and role identity. In Proc. of the 17th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI 2001), pages 193–198, 2001. [Matiyasevich, 1971] Y. Matiyasevich. Diophantine representation of recursively enumerable predicates. Isv. Ak. Nauk USSR, Ser. Math., 35:3–30, 1971.

[Mays et al., 1988] E. Mays, C. Apte, J. Griesmer, and J. Kastner. Experience with K-Rep: An object-centered knowledge representation language. In Proc. of the 4th IEEE Conference on Artiﬁcial Intelligence Application (CAIA’88), pages 62–67, Orlando, FL, 1988. [Mays et al., 1991a] Eric Mays, Robert Dionne, and Robert Weida. K-Rep system overview. SIGART Bull., 2(3):93–97, 1991. [Mays et al., 1991b] Eric Mays, Sitaram Lanka, Robert Dionne, and Robert Weida. A persistent store for large shared knowledge bases. IEEE Trans. on Knowledge and Data Engineering, 3(1):33–41, 1991. [Mays et al., 1996] E. Mays, R. Weida, R. Dionne, M. Laker, B. White, C. Liang, and F. J. Oles. Scalable and expressive medical terminologies. In Proc. of the American Medical Informatics Society Annual Fall Symposium, pages 259–263, 1996. [McAllester, 1982] David A. McAllester. Reasoning utility package user’s manual. Technical Report AI Memo 551, Massachusetts Institute of Technology, Artiﬁcial Intelligence Laboratory, 1982. [McAllester et al., 1996] David A. McAllester, Robert Givan, Carl Witty, and Dexter Kozen. Tarskian set constraints. In Proc. of the 11th IEEE Symp. on Logic in Computer Science (LICS’96), pages 138–147, 1996. [McDermott, 1982] John McDermott. R1: A rule-based conﬁgurer of computer systems. In Artiﬁcial Intelligence, volume 19, 1982. [McGuinness, 1996] Deborah L. McGuinness. Explaining Reasoning in Description Logics. PhD thesis, Department of Computer Science, Rutgers University, October 1996. Also available as Rutgers Technical Report Number LCSR-TR-277. [McGuinness, 1998] Deborah L. McGuinness. Ontological issues for knowledge-enhanced search. In Proceedings of Formal Ontology in Information Systems, 1998. Also published in Frontiers in Artiﬁcial Intelligence and Applications, IOS-Press, 1998. [McGuinness, 1999] Deborah L. McGuinness. Ontology-enhanced search for primary care medical literature. In Proc. of the Int. Medical Informatics Association Working Group 6 – Conference on Natural Language Processing and Medical Concept Representation (IMIA’99), 1999. Available at http://www.ksl.stanford.edu/ people/dlm/papers/imia99-abstract.html. [McGuinness and Borgida, 1995] Deborah L. McGuinness and Alex Borgida. Explaining subsumption in Description Logics. In Proc. of the 14th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’95), pages 816–821, 1995. [McGuinness and Patel-Schneider, 1998] Deborah L. McGuinness and Peter F. Patel-Schneider. Usability issues in knowledge representation systems. In Proc. of the 15th Nat. Conf. on Artiﬁcial Intelligence (AAAI’98), pages 608–614, 1998. [McGuinness and Wright, 1998a] Deborah McGuinness and Jon R. Wright. Conceptual modelling for conﬁguration: A Description Logic-based approach. Artiﬁcial Intelligence for Engineering Design, Analysis, and Manufacturing. Special Issue on Conﬁguration, 12:333–344, 1998. [McGuinness and Wright, 1998b] Deborah L. McGuinness and Jon R. Wright. An industrial strength Description Logic-based conﬁguration platform. IEEE Intelligent Systems, pages 69–77, 1998. [McGuinness et al., 1994] Deborah L. McGuinness, Merryll K. Abrahams, Lori Alperin Resnick, Peter F. Patel-Schneider, Rich Thomason, Violetta Cavalli-Sforza, and Cristina Conati. CLASSIC knowledge representation system tutorial. Technical report, Artiﬁcial Intelligence Principles Research Department, AT&T Labs Research

and University of Pittsburgh, 1994. Available as http://www.bell-labs.com/ project/classic/papers/ClassTut/ClassTut.html. [McGuinness et al., 1995] Deborah L. McGuinness, Lori Alperin Resnick, and Charles Isbell. Description Logic in practice: A CLASSIC application. In Proc. of the 14th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’95), pages 2045–2046, 1995. [McGuinness et al., 1997] Deborah L. McGuinness, Harley Manning, and Tom Beattie. Knowledge augmented intranet search. In Proc. of the 6th World Wide Web Conference CDROM version, 1997. [McGuinness et al., 1998] Deborah McGuinness, Peter F. Patel-Schneider, Lori Alperin Resnick, Charles Isbell, Matt Parker, and Chris Welty. A Description Logic based conﬁgurator for the web. SIGART Bull., 9(2):20–22, 1998. [McGuinness et al., 2000a] Deborah L. McGuinness, Richard Fikes, James Rice, and Steve Wilder. The Chimaera ontology environment. In Proc. of the 17th Nat. Conf. on Artiﬁcial Intelligence (AAAI 2000), pages 1123–1124, 2000. [McGuinness et al., 2000b] Deborah L. McGuinness, Richard Fikes, James Rice, and Steve Wilder. An environment for merging and testing large ontologies. In Proc. of the 7th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2000), pages 483–493, 2000. [McGuinness et al., 2002] Deborah L. McGuinness, Richard Fikes, Lynn A. Stein, and James Hendler. DAML-ONT: An ontology language for the semantic web. In Dieter Fensel, Hendler, Henry Lieberman, and Wolfgang Wahlster, editors, The Semantic Web: Why, What, and How. The MIT Press, 2002. [Meghini et al., 1997] Carlo Meghini, Fabrizio Sebastiani, and Umberto Straccia. Modelling the retrieval of structured documents containing texts and images. In Costantino Thanos, editor, Proc. of the 1st European Conf. on Research and Advanced Technology for Digital Libraries (ECDL’97), volume 1324 of Lecture Notes in Computer Science. Springer, 1997. [Mejino and Rosse, 1999] J. L. V. Mejino and C. Rosse. Conceptualization of anatomical spatial entities in the digital anatomist foundation model. J. of the American Medical Informatics Association, pages 112–116, 1999. Annual Symposium Special Issue. [Mena et al., 2000] E. Mena, A. Illarramendi, V. Kashyap, and A. Sheth. OBSERVER: An approach for query processing in global information systems based on interoperation across pre-existing ontologies. Distributed and Parallel Databases, 8(2):223–271, 2000. [Mendelzon et al., 1997] Alberto Mendelzon, George A. Mihaila, and Tova Milo. Querying the World Wide Web. Int. J. on Digital Libraries, 1(1):54–67, 1997. [Meyer and van der Hoek, 1995] J. J. Meyer and W. van der Hoek. Epistemic Logic for AI and Computer Science. Cambridge University Press, 1995. [Michaeli et al., 1997] David Michaeli, Werner Nutt, and Yehoshua Sagiv. Classiﬁcation rules for semistructured data. In Proc. of the 1997 Description Logic Workshop (DL’97), pages 59–64, 1997. [Miller, 1995] George A. Miller. WordNet: A lexical database for English. Communications of the ACM, 38(11):39–41, 1995. [Milne, 1928] A. A. Milne. The House at Pooh Corner. Dutton, 1928. [Minsky, 1981] Marvin Minsky. A framework for representing knowledge. In J. Haugeland, editor, Mind Design. The MIT Press, 1981. A longer version appeared in The Psychology of Computer Vision (1975). Republished in [Brachman and Levesque, 1985]. [Molitor and Tresp, 2000] Ralf Molitor and Christopher B. Tresp. Extending Description Logics to vague knowledge in medicine. In P. Szczepaniak, P. J. G. Lisboa, and

J. Kacprzyk, editors, Fuzzy Systems in Medicine, volume 41 of Studies in Fuzziness and Soft Computing, pages 617–635. Springer, 2000. [Moore, 1985] Robert C. Moore. Semantical considerations on nonmonotonic logic. Acta Informatica, 25:75–94, 1985. [Moore and Paris, 1993] Johanna D. Moore and C´ecile Paris. Planning text for advisory dialogues: Capturing intentional and rhetorical information. Computational Linguistics, 19(4):651–694, 1993. [Mortimer, 1975] Michael Mortimer. On languages with two variables. Zeitschrift f¨ur Mathematische Logik und Grundlagen der Mathematik, 21:135–140, 1975. [Mosurovic and Zakharyaschev, 1999] M. Mosurovic and M. Zakharyaschev. On the complexity of Description Logics with modal operators. In P. Kolaitos and G. Koletos, editors, Proceedings of the 2nd Panhellenic Logic Symposion, pages 166–171, Delphi, Greece, 1999. [Motschnig-Pitrik and Mylopoulous, 1992] Renate Motschnig-Pitrik and John Mylopoulous. Classes and instances. J. of Intelligent and Cooperative Information Systems, 1(1), 1992. [Mugnier and Chein, 1992] Marie-Laure Mugnier and Michel Chein. Polynomial algorithms for projection and matching. In Heather D. Pfeiffer and Timothy E. Nagle, editors, Proc. of the 7th Annual Workshop on Conceptual Structures: Theory and Implementation, volume 754 of Lecture Notes in Artiﬁcial Intelligence, pages 239–251. Springer, 1992. [Muller and Schupp, 1987] D. E. Muller and P. E. Schupp. Alternating automata on inﬁnite trees. Theoretical Computer Science, 54:267–276, 1987. [Musen, 1998] M. Musen. Modern architectures for intelligent systems: Reusable ontologies and problem-solving methods. J. of the American Medical Informatics Association, pages 46–54, 1998. Annual Symposium Special Issue. [Musen et al., 1996] M. Musen, S. Tu, A. Das, and Y. Shahar. EON: A component-based architecture for automation of protocol-directed therapy. J. of the American Medical Informatics Association, 3:367–383, 1996. [Mylonas and Renear, 1999] Elli Mylonas and Allen Renear. The text encoding initiative at 10. Computers and the Humanities, 33(1–2):1–10, 1999. [Mylopoulos, 1998] John Mylopoulos. Information modeling in the time of the revolution. Information Systems, 23(3–4):127–155, 1998. [Nado and Fikes, 1987] Robert Nado and Richard Fikes. Semantically sound inheritance for a formally deﬁned frame language with defaults. In Proc. of the 6th Nat. Conf. on Artiﬁcial Intelligence (AAAI’87), pages 443–448, 1987. [Nardi and Rosati, 1995] Daniele Nardi and Riccardo Rosati. A preference semantics for ground nonmonotonic modal logics. In Proc. of the 7th Portuguese Conf. on Artiﬁcial Intelligence (EPIA’95), volume 990 of Lecture Notes in Artiﬁcial Intelligence. Springer, 1995. [Nebel, 1988] Bernhard Nebel. Computational complexity of terminological reasoning in BACK. Artiﬁcial Intelligence, 34(3):371–383, 1988. [Nebel, 1990a] Bernhard Nebel. Reasoning and Revision in Hybrid Representation Systems, volume 422 of Lecture Notes in Artiﬁcial Intelligence. Springer, 1990. [Nebel, 1990b] Bernhard Nebel. Terminological reasoning is inherently intractable. Artiﬁcial Intelligence, 43:235–249, 1990. [Nebel, 1991] Bernhard Nebel. Terminological cycles: Semantics and computational properties. In John F. Sowa, editor, Principles of Semantic Networks, pages 331–361. Morgan Kaufmann, Los Altos, 1991.

[Nebel and Smolka, 1991] Bernhard Nebel and Gert Smolka. Attributive description formalism and the rest of the world. In O. Herzog and C.-R. Rollinger, editors, Textunderstanding in LILOG: Integrating Computational Linguistics and Artiﬁcial Intelligence. Springer, Berlin (Germany), 1991. [Nebel and von Luck, 1987] Bernhard Nebel and Kai von Luck. Issues of integration and balancing in hybrid knowledge representation systems. In K. Morik, editor, Proc. of the 11th German Workshop on Artiﬁcial Intelligence (GWAI’87), pages 114–123. Springer, 1987. [Nebel and von Luck, 1988] Bernhard Nebel and Kai von Luck. Hybrid reasoning in BACK. In Proc. of the 3rd Int. Symp. on Methodologies for Intelligent Systems (ISMIS’88), pages 260–269. North-Holland Publ. Co., Amsterdam, 1988. [Neumann, 1992] Peter G. Neumann. What’s in a name? Communications of the ACM, 35(1):186, 1992. [Neuwirth, 1993] A. Neuwirth. Inferences for temporal object descriptions in a terminological representation system. KIT-Report 107, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1993. [Newell, 1982] Allen Newell. The knowledge level. Artiﬁcial Intelligence, 18(1):87–127, 1982. [NHS National Health Service Executive, 1998] NHS National Health Service Executive. Information for health: An information strategy for the modern NHS 1998–2005, 1998. [Nowlan and Rector, 1991] W. Nowlan and A. Rector. Medical knowledge representation and predictive data entry. In Proc. of Artiﬁcial Intelligence in Medicine Europe (AIME’91), pages 105–116, 1991. [Nowlan et al., 1991a] W. Nowlan, S. Kay, A. Rector, B. Horan, and A. Wilson. PEN&PAD: A multi-lingual patient care workstation based on a uniﬁed representation of the medical record and medical terminology. In Proc. of Medical Informatics Europe (MIE’91), pages 1043–1048, 1991. [Nowlan et al., 1991b] W. Nowlan, A. Rector, S. Kay, B. Horan, and A. Wilson. A patient care workstation based on a user centred design and a formal theory of medical terminology: PEN&PAD and the SMK formalism. In Proc. of the 15th Annual Symposium on Computer Applications in Medical Care (SCAMC’91), pages 855–857, 1991. [Nowlan et al., 1994] W. Nowlan, A. Rector, T. Rush, and W. Solomon. From terminology to terminology services. In Proc. of the 18th Annual Symposium on Computer Applications in Medical Care (SCAMC’94), pages 150–154, 1994. [Noy and McGuinness, 2000] Natalya Fridman Noy and Deborah L. McGuinness. Ontology development 101: A guide to creating your ﬁrst ontology. Technical Report KSL-01-05, Stanford University KSL, 2000. Available also as Stanford Medical Informatics Technical Report no. SMI-2001-0880. Available at http://www.ksl. stanford.edu/people/dlm/papers/ontology-tutorial-noy-mcg uinness-abstract.html. [Ohlbach and Koehler, 1999] Hans J¨urgen Ohlbach and Jana Koehler. Modal logics, Description Logics and arithmetic reasoning. Artiﬁcial Intelligence, 109(1–2):1–31, 1999. [Oliver et al., 1999] D. E. Oliver, Y. Shahar, E. H. Shortliffe, and M. A. Musen. Representing change in controlled medical vocabularies. J. of the American Medical Informatics Association, 15(1):53–76, 1999. [O’Neil et al., 1995] M. O’Neil, C. Payne, and J. Read. Read codes version 3: A user led terminology. Methods of Information in Medicine, 34:187–192, 1995.

[Oppacher and Suen, 1988] F. Oppacher and E. Suen. HARP: A tableau-based theorem prover. J. of Automated Reasoning, 4:69–100, 1988. [Owsnicki-Klewe, 1988] B. Owsnicki-Klewe. Conﬁguration as a consistency maintenance task. In Proc. of the 12th German Workshop on Artiﬁcial Intelligence (GWAI’88), pages 77–87. Springer, 1988. [Pacholski et al., 1997] Leszek Pacholski, Wieslaw Szwast, and Lidia Tendera. Complexity of two-variable logic with counting. In Proc. of the 12th IEEE Symp. on Logic in Computer Science (LICS’97), pages 318–327. IEEE Computer Society Press, 1997. [Pacholski et al., 2000] Leszek Pacholski, Wieslaw Szwast, and Lidia Tendera. Complexity results for ﬁrst-order two-variable logic with counting. SIAM J. on Computing, 29(4):1083–1117, 2000. [Padgham and Lambrix, 1994] Lin Padgham and Patrick Lambrix. A framework for part-of hierarchies in terminological logics. In Proc. of the 4th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’94), pages 485–496, 1994. [Padgham and Nebel, 1993] Lin Padgham and Bernhard Nebel. Combining classiﬁcation and non-monotonic inheritance reasoning: A ﬁrst step. In J. Komorowski and Z. W. Ra´s, editors, Proc. of the 7th Int. Symp. on Methodologies for Intelligent Systems (ISMIS’93), 1993. [Padgham and Zhang, 1993] Lin Padgham and Tingting Zhang. A terminological logic with defaults: A deﬁnition and an application. In Proc. of the 13th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’93), pages 662–668, 1993. [Paley et al., 1997] Suzanne M. Paley, John D. Lawrence, and Peter D. Karp. A generic knowledge-base browser and editor. In Proc. of the 14th Nat. Conf. on Artiﬁcial Intelligence (AAAI’97), pages 1045–1051, 1997. [Papadimitriou, 1994] Christos H. Papadimitriou. Computational Complexity. Addison Wesley Publ. Co., Reading, Massachussetts, 1994. [Paramasivam and Plaisted, 1998] M. Paramasivam and David A. Plaisted. Automated deduction techniques for classiﬁcation in Description Logic systems. J. of Automated Reasoning, 20(3):337–364, 1998. [Parikh, 1981] Rohit Parikh. Propositional dynamic logic of programs: A survey. In Proc. of the 1st Workshop on Logics of Programs, volume 125 of Lecture Notes in Computer Science, pages 102–144. Springer, 1981. [Paris and Vander Linden, 1996a] C. Paris and K. Vander Linden. Building knowledge bases for the generation of software documentation. In Proc. of the 16th Int. Conf. on Computational Linguistics (COLING’96), pages 734–739, 1996. [Paris and Vander Linden, 1996b] C. Paris and K. Vander Linden. DRAFTER: An interactive support tool for writing multilingual instructions. IEEE Computer, pages 49–56, July 1996. [Park, 1970] David Park. Fixpoint induction and proofs of program properties. Machine Intelligence, 5:59–78, 1970. [Park, 1976] David Park. Finiteness is mu-ineffable. Theoretical Computer Science, 3:173–181, 1976. [Passy and Tinchev, 1985] Solomon Passy and Tinko Tinchev. PDL with data constraints. Information Processing Lett., 20:35–41, 1985. [Passy and Tinchev, 1991] Solomon Passy and Tinko Tinchev. An essay in combinatory dynamic logic. Information and Computation, 93:263–332, 1991. [Patel-Schneider, 1984] Peter F. Patel-Schneider. Small can be beautiful in knowledge representation. In Proc. of the IEEE Workshop on Knowledge-Based Systems, 1984.

An extended version appeared as Fairchild Tech. Rep. 660 and FLAIR Tech. Rep. 37, October 1984. [Patel-Schneider, 1986] Peter F. Patel-Schneider. A four-valued semantics for frame-based description languages. In Proc. of the 5th Nat. Conf. on Artiﬁcial Intelligence (AAAI’86), pages 344–348, 1986. [Patel-Schneider, 1987a] Peter F. Patel-Schneider. Decidable, Logic-Based Knowledge Representation. PhD thesis, Department of Computer Science, University of Toronto, Ontario, Canada, 1987. Available as Technical report 201/87. [Patel-Schneider, 1987b] Peter F. Patel-Schneider. A hybrid, decidable, logic-based knowledge representation system. Computational Intelligence, 3(2):64–77, 1987. [Patel-Schneider, 1989a] Peter F. Patel-Schneider. A four-valued semantics for terminological logic. Artiﬁcial Intelligence, 38(1):319–351, 1989. [Patel-Schneider, 1989b] Peter F. Patel-Schneider. Undecidability of subsumption in NIKL. Artiﬁcial Intelligence, 39:263–272, 1989. [Patel-Schneider, 1998] P. F. Patel-Schneider. DLP system description. In Proc. of the 1998 Description Logic Workshop (DL’98), pages 87–89. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-11/, 1998. [Patel-Schneider, 1999] Peter F. Patel-Schneider. DLP. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 9–13. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Patel-Schneider and Swartout, 1993] Peter F. Patel-Schneider and Bill Swartout. Description-logic knowledge representation system speciﬁcation from the KRSS group of the ARPA knowledge sharing effort. Technical report, AI Principles Research Department, AT&T Bell Laboratories, 1993. Available at http://dl.kr.org/. [Patel-Schneider et al., 1990] P. F. Patel-Schneider, B. Owsnicki-Klewe, A. Kobsa, N. Guarino, R. MacGregor, W. S. Mark, D. L. McGuinness, B. Nebel, A. Schmiedel, and J. Yen. Report on the workshop on term subsumption languages in knowledge representation. AI Magazine, 11(2):16–22, 1990. [Patel-Schneider et al., 1991] Peter F. Patel-Schneider, Deborah L. McGuiness, Ronald J. Brachman, Lori Alperin Resnick, and Alexander Borgida. The CLASSIC knowledge representation system: Guiding principles and implementation rationale. SIGART Bull., 2(3):108–113, 1991. [Peltason, 1991] Christof Peltason. The BACK system—an overview. SIGART Bull., 2(3):114–119, 1991. [Pirotte et al., 1994] Alain Pirotte, Esteban Zim´anyi, David Massart, and Tatiana Yakusheva. Materialization: A powerful and ubiquitous abstraction pattern. In Proc. of the 20th Int. Conf. on Very Large Data Bases (VLDB’94), pages 630–641, 1994. [Poon and Fagan, 1994] A. D. Poon and L. M. Fagan. PEN-Ivory: The design and evaluation of a pen-based system for structured data entry. In Proc. of the 18th Annual Symposium on Computer Applications in Medical Care (SCAMC’94), pages 447–552, 1994. [Pratt, 1979] Vaugham R. Pratt. Models of program logic. In Proc. of the 20th Annual Symp. on the Foundations of Computer Science (FOCS’79), pages 115–122, 1979. [Pratt, 1980] Vaugham R. Pratt. A near-optimal method for reasoning about action. J. of Computer and System Sciences, 20:231–255, 1980. [Pratt, 1981] Vaugham R. Pratt. A decidable µ-calculus (preliminary report). In Proc. of the 22nd Annual Symp. on the Foundations of Computer Science (FOCS’81), pages 421–428. IEEE Computer Society Press, 1981. [Prior, 1967] Arthur Prior. Past, Present, and Future. Oxford University Press, 1967.

[Pustejovsky, 1988] J. Pustejovsky. Constraints on the acquisition of semantic knowledge. Int. J. of Intelligent Systems, 3:247–268, 1988. [Quantz, 1993] Joachim Quantz. Interpretation as exception minimization. In Proc. of the 13th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’93), pages 1310–1315, 1993. [Quantz, 1995] Joachim Quantz. Preferential Disambiguation in Natural Language Processing. PhD thesis, Technische Universit¨at Berlin (Germany), 1995. [Quantz and Kindermann, 1990] Joachim Quantz and Carsten Kindermann. Implementation of the BACK system version 4. KIT-Report 78, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1990. [Quantz and Royer, 1992] Joachim Quantz and Veronique Royer. A preference semantics for defaults in terminological logics. In Proc. of the 3rd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’92), pages 294–305. Morgan Kaufmann, Los Altos, 1992. [Quantz and Schmitz, 1994] J. Quantz and B. Schmitz. Knowledge-based disambiguation for machine translation. Minds and Machines, 4:39–57, 1994. [Quantz et al., 1995] J. Quantz, G. Dunker, F. Bergmann, and I. Kellner. The FLEX system. KIT-Report 124, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1995. [Quillian, 1967] M. Ross Quillian. Word concepts: A theory and simulation of some basic capabilities. Behavioral Science, 12:410–430, 1967. Republished in [Brachman and Levesque, 1985]. [Quillian, 1968] M. Ross Quillian. Semantic memory. In M. Minsky, editor, Semantic Information Processing, pages 216–270. The MIT Press, 1968. [Randell et al., 1992] David A. Randell, Zhan Cui, and Anthony G. Cohn. A spatial logic based on regions and connection. In Proc. of the 3rd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’92), pages 165–176. Morgan Kaufmann, Los Altos, 1992. [Rassinoux, 1998] A.-M. Rassinoux. Modeling just the important and relevant concepts in medical language understanding. Methods of Information in Medicine, 37:361–372, 1998. [Rector, 1998] A. Rector. Thesauri and formal classiﬁcations: Terminologies for people and machines. Methods of Information in Medicine, 37(4–5):501–509, 1998. [Rector and Nowlan, 1994] A. L. Rector and W. Nowlan. A reusable application independent model of medical terminology: Galen’s GRAIL. In Proc. of the 4th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’94), 1994. [Rector and Rogers, 2002] A. Rector and J. Rogers. Ontological issues in using a Description Logic to represent medical concepts: Experience from Galen. Methods of Information in Medicine, 2000. To appear. [Rector et al., 1993] A. L. Rector, W. A. Nowlan, and A. Glowinski. Goals for concept representation in the galen project. In Proc. of the 17th Annual Symposium on Computer Applications in Medical Care (SCAMC’93), pages 414–418, Washington DC, USA, 1993. [Rector et al., 1995a] A. Rector, W. Solomon, W. Nowlan, and T. Rush. A terminology server for medical language and medical information systems. Methods of Information in Medicine, 34:147–157, 1995. [Rector et al., 1995b] A. Rector, P. Zanstra, W. Solomon, and The Galen Consortium. Galen: Terminology services for clinical information systems. In M. Laires, M. Ladeira, and J. Christensen, editors, Health in the New Communications Age, pages 90–100. IOS Press, 1995.

[Rector et al., 1997] A. Rector, S. Bechhofer, C. A. Goble, I. Horrocks, W. A. Nowlan, and W. D. Solomon. The grail concept modelling language for medical terminology. Artiﬁcial Intelligence in Medicine, 9:139–171, 1997. [Rector et al., 1999] A. L. Rector, P. E. Zanstra, W. D. Solomon, J. E. Rogers, R. Baud, W. Ceusters, W. Claassen, J. Kirby, J.-M. Rodrigues, A. R. Mori, E. Haring, and J. Wagner. Reconciling users’ needs and formal requirements: Issues in developing a re-usable ontology for medicine. IEEE Transactions on Information Technology in BioMedicine, 2(4):229–242, 1999. [Rector et al., 2001] A. Rector, C. Wroe, J. Rogers, and A. Roberts. Untangling taxonomies and relationships: Personal and practical problems in loosely coupled development of large ontologies. In Y. Gil, M. Musen, and J. Shavlik, editors, Proc. of the 1st Int. Conf. on Knowledge Capture (K-CAP 2001). ACM Press and Addison Wesley, 2001. [Rector et al., 2002] A. L. Rector, J. E. Rogers, and W. D. Solomon. Ontological issues in using a Description Logic to represent medical concepts: Part II: The Galen high level schemata. Methods of Information in Medicine, 2000. To appear. [Reiter, 1980] Raymond Reiter. A logic for default reasoning. Artiﬁcial Intelligence, 13:81–132, 1980. [Reiter, 1990] Raymond Reiter. On asking what a database knows. In John W. Lloyd, editor, Computational Logics, Symposium Proceedings, pages 96–113. Springer, 1990. [Reiter and Criscuolo, 1981] R. Reiter and G. Criscuolo. On interacting defaults. In Proc. of the 7th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’81), pages 270–276, 1981. [Resnick et al., 1995] Lori Alperin Resnick, Alexander Borgida, Ronald J. Brachman, Deborah L. McGuinness, Peter F. Patel-Schneider, and Kevin C. Zalondek. CLASSIC: Description and reference manual for the Common Lisp implementation, version 2.3. Technical report, AT&T Bell Labs, Murray Hill, NY, 1995. [Rich, 1991] Charles Rich, editor. Special issue on implemented knowledge representation and reasoning systems. SIGART Bulletin, 2(3), 1991. [Rintanen, 1999] Jussi T. Rintanen. Improvements to the evaluation of quantiﬁed boolean formulae. In Proc. of the 16th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’99), pages 1192–1197, 1999. [Robins, 1986] Gabriel Robins. The NIKL manual. Technical report, University of Southern California, Los Angeles, Information Sciences Institutes, The Knowledge Representation Project, 1986. [Robinson, 1971] R. Robinson. Undecidability and nonperiodicity of tilings on the plane. Inventiones Math., 12:177–209, 1971. [Rocha et al., 1993] R. Rocha, B. Rocha, and S. Huff. Automated translation between medical vocabularies using a frame-based interlingua. In Proc. of the 17th Annual Symposium on Computer Applications in Medical Care (SCAMC’93), pages 690–694, 1993. [Rocha et al., 1994] R. A. Rocha, S. M. Huff, P. J. Haug, and H. R. Warner. Designing a controlled medical vocabulary server: the VOSER project. Computers and Biomedical Research, 27:472–507, 1994. [Rodrigues et al., 1997] J. M. Rodrigues, B. Trombert-Paviot, R. Baud, J. Wagner, P. Rusch, and F. Meusnier. Galen-In-Use: An EU project applied to the development of a new national coding system for surgical procedures: NCAM. In Proc. of Medical Informatics Europe (MIE’97), pages 897–901, 1997. [Rosati, 1998] Riccardo Rosati. Autoepistemic Description Logics. AI Communications—The Eur. J. on Artiﬁcial Intelligence, 11(3–4):219–221, 1998

[Rosati, 1999] Riccardo Rosati. Towards expressive KR systems integrating Datalog and Description Logics: Preliminary report. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 160–164. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Rosse et al., 1998] C. Rosse, I. G. Shapiro, and J. F. Brinkley. The digital anatomist foundational model: Principles for deﬁning and structuring its concept domain. J. of the American Medical Informatics Association, 1998. Fall Symposium Special Issue. [Rossi Mori and Consorti, 1999] A. Rossi Mori and F. Consorti. Structuring clinical information in electronic healthcare records. In Proc. of Medical Informatics Europe (MIE’99), 1999. Tutorial. [Rossi Mori et al., 1997] A. Rossi Mori, A. Gangemi, G. Steve, F. Consorti, and E. Galeazzi. An ontological analysis of surgical deeds. In Proc. of Artiﬁcial Intelligence in Medicine Europe (AIME’97), pages 361–372, 1997. [Rousset, 1999a] Marie-Christine Rousset. Backward reasoning in ABoxes for query answering. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 18–22. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Rousset, 1999b] Marie-Christine Rousset. Query expansion in Description Logics and CARIN. In Working Notes of the AAAI Fall Symposium on “Question Answering Systems”, 1999. [Rumbaugh et al., 1998] James Rumbaugh, Ivar Jacobson, and Grady Booch. The Uniﬁed Modeling Language Reference Manual. Addison Wesley Publ. Co., Reading, Massachussetts, 1998. [Rychtyckyj, 1996] Nestor Rychtyckyj. DLMS: An evaluation of KL-ONE in the automobile industry. In Proc. of the 5th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’96), pages 588–596, 1996. [Rychtyckyj, 1999] Nestor Rychtyckyj. DLMS: Ten years of AI for vehicle assembly process planning. In Proc. of the 11th Annual Conf. on Innovative Appplications of Artiﬁcial Intelligence (IAAI’99), pages 821–828, 1999. [Sager et al., 1987] N. Sager, C. Friedman, and M. Lyman. Medical Language Processing—Computer Management of Narrative Data. Addison Wesley Publ. Co., Reading, Massachussetts, 1987. [Sager et al., 1994] N. Sager, M. S. Lyman, C. Bucknall, N. T. Nhan, and L. J. Tick. Natural language processing and the representation of clinical data. J. of the American Medical Informatics Association, 1(1):142–160, 1994. [Samek-Lodovici and Strapparava, 1990] Vieri Samek-Lodovici and Carlo Strapparava. Identifying noun phrase references: the topic module of the AlFresco system. In Proc. of the 9th Eur. Conf. on Artiﬁcial Intelligence (ECAI’90), pages 573–578, 1990. [Sattler, 1995] Ulrike Sattler. A concept language for an engineering application with part-whole relations. In Proc. of the 1995 Description Logic Workshop (DL’95), pages 119–123, 1995. [Sattler, 1996] Ulrike Sattler. A concept language extended with different kinds of transitive roles. In G¨unter G¨orz and Steffen H¨olldobler, editors, Proc. of the 20th German Annual Conf. on Artiﬁcial Intelligence (KI’96), number 1137 in Lecture Notes in Artiﬁcial Intelligence, pages 333–345. Springer, 1996. [Sattler and Vardi, 2001] Ulrike Sattler and Moshe Y. Vardi. The hybrid µ-calculus. In Proc. of the Int. Joint Conf. on Automated Reasoning (IJCAR 2001), pages 76–91, 2001. [Savitch, 1970] W. J. Savitch. Relationship between nondeterministic and deterministic tape complexities. J. of Computer and System Sciences, 4:177–192, 1970.

[Schaerf, 1993] Andrea Schaerf. On the complexity of the instance checking problem in concept languages with existential quantiﬁcation. J. of Intelligent Information Systems, 2:265–278, 1993. [Schaerf, 1994a] Andrea Schaerf. Query Answering in Concept-Based Knowledge Representation Systems: Algorithms, Complexity, and Semantic Issues. PhD thesis, Dipartimento di Informatica e Sistemistica, Universit`a di Roma “La Sapienza”, 1994. [Schaerf, 1994b] Andrea Schaerf. Reasoning with individuals in concept languages. Data and Knowledge Engineering, 13(2):141–176, 1994. [Schank, 1975] Roger C. Schank. Conceptual Information Processing. North-Holland Publ. Co., Amsterdam, 1975. [Schild, 1989] Klaus Schild. Towards a theory of frames and rules. Technical report, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1989. [Schild, 1991] Klaus Schild. A correspondence theory for terminological logics: Preliminary report. In Proc. of the 12th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’91), pages 466–471, 1991. [Schild, 1993] Klaus Schild. Combining terminological logics with tense logic. In Proc. of the 6th Portuguese Conf. on Artiﬁcial Intelligence (EPIA’93), volume 727 of Lecture Notes in Computer Science, pages 105–120. Springer, 1993. [Schild, 1994] Klaus Schild. Terminological cycles and the propositional µ-calculus. In J. Doyle, E. Sandewall, and P. Torasso, editors, Proc. of the 4th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’94), pages 509–520, Bonn (Germany), 1994. Morgan Kaufmann, Los Altos. [Schmidt, 1991] R. Schmidt. Algebraic terminological representation. Technical report, Max Planck Institute for Computer Science, MPI-Report MPI-I-91-216, 1991. [Schmidt-Schauß, 1989] Manfred Schmidt-Schauß. Subsumption in KL-ONE is undecidable. In Ron J. Brachman, Hector J. Levesque, and Ray Reiter, editors, Proc. of the 1st Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’89), pages 421–431. Morgan Kaufmann, Los Altos, 1989. [Schmidt-Schauß and Smolka, 1991] Manfred Schmidt-Schauß and Gert Smolka. Attributive concept descriptions with complements. Artiﬁcial Intelligence, 48(1):1–26, 1991. [Schmiedel, 1988] Albrecht Schmiedel. A temporal constraint handler for the BACK system. KIT-Report 70, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1988. [Schmiedel, 1990] Albrecht Schmiedel. A temporal terminological logic. In Proc. of the 8th Nat. Conf. on Artiﬁcial Intelligence (AAAI’90), pages 640–645, 1990. [Schmiedel, 1993] Albrecht Schmiedel. Persistent maintenance of object descriptions using BACK. KIT-Report 112, Fachbereich Informatik, Technische Universit¨at Berlin, Berlin (Germany), 1993. [Schmolze, 1985] James G. Schmolze. The language and semantics of NIKL. Technical report, BBN Laboratories, Cambridge, MA, 1985. [Schmolze, 1989] James G. Schmolze. Terminological knowledge representation systems supporting n-ary terms. In Proc. of the 1st Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’89), pages 432–443, 1989. [Schmolze and Brachman, 1982] James G. Schmolze and Ronald J. Brachman, editors. Proc. of the 1981 KL-ONE Workshop, 1982. Published as BBN Research Report 4842, Bolt Beranek and Newman Inc., June 1982. [Schmolze and Israel, 1983] James G. Schmolze and David J. Israel. KL-ONE: Semantics and classiﬁcation. Technical report, Research in Knowledge Representation for

Natural Language Understanding—Annual Report 1983, BBN Report No. 5421, BBN Laboratories, Cambridge, MA, 1983. [Schmolze and Lipkis, 1983] James G. Schmolze and Thomas A. Lipkis. Classiﬁcation in the KL-ONE knowledge representation system. In Proc. of the 8th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’83), pages 330–332, 1983. [Schmolze and Mark, 1991] James G. Schmolze and William S. Mark. The NIKL experience. Computational Intelligence, 7(1):48–69, 1991. [Schreiber et al., 1993] A. Schreiber, G. van Heijst, G. Lanzola, and M. Stefanelli. Knowledge organisation in medical KBS construction. In Proc. of Medical Informatics Europe (MIE’93), pages 394–405, 1993. [Selfridge and Heineman, 1994] Peter Selfridge and George Heineman. Graphical support for code-level software understanding. In Douglas Smith, editor, Proc. of the 9th Conf. on Knowledge-Based Software Engineering (KBSE’94). IEEE Computer Society Press, 1994. [Selman and Levesque, 1993] Bart Selman and Hector J. Levesque. The complexity of path-based defeasible inheritance. Artiﬁcial Intelligence, 62(2):303–339, 1993. [Shlaer and Mellor, 1988] Sally Shlaer and Stephen J. Mellor. Object Oriented Systems Analysis: Modeling the World in Data. Yourdon Press, 1988. [Shoham, 1987] Yoav Shoham. A semantical approach to nonmonotonic logics. In Proc. of the 2nd IEEE Symp. on Logic in Computer Science (LICS’87), pages 275–279, 1987. [Simmons, 1973] Robert F. Simmons. Semantic networks: Their computation and use for understanding English sentences. In Roger C. Schank and Kenneth M. Colby, editors, Computer Models of Thought and Language, pages 63–113. W. H. Freeman, San Francisco, CA, 1973. [Sittig, 1994] D. F. Sittig. Grand challenges in medical informatics. J. of the American Medical Informatics Association, 1:412–413, 1994. [Smolka, 1988] Gert Smolka. A feature logic with subsorts. Technical Report 33, IWBS, IBM Deutschland, P.O. Box 80 08 80 D-7000 Stuttgart 80, Germany, 1988. [Soininen et al., 2001] Timo Soininen, Michel Aldanondo, Gerhard Friedrich, Eugene Freuder, Deborah McGuinness, and Markus Stumptner, editors. Proc. of the 17th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI 2001) Workshop on Conﬁguration, 2001. [Solomon and Heathﬁeld, 1994] W. Solomon and H. Heathﬁeld. Conceptual modelling used to represent drug interactions. In Proc. of Medical Informatics Europe (MIE’94), pages 186–190, 1994. [Solomon et al., 1999] D. S. Solomon, C. Wroe, J. E. Rogers, and A. Rector. A reference terminology for drugs. J. of the American Medical Informatics Association, 1999. Conference Special Issue. [Soloway and Letovsky, 1986] Elliot Soloway and Stan Letovsky. Delocalized plans and program comprehension. IEEE Software, 3(3), 1986. [Soloway et al., 1986] Elliot Soloway, Stan Letovsky, Juan Pinto, and Diane Littman. Mental models and software maintenance. In Proceedings of the Conference on Empirical Studies of Programmers, pages 80–98. Ablex Publishers, 1986. [Soloway et al., 1987] E. Soloway, S. Sheppard, and G. Olson, editors. Proceedings of the Second Workshop on Empirical Studies of Programmers. Ablex Publishers, December 1987. [Sondheimer et al., 1984] N. Sondheimer, R. Weischedel, and R. Bobrow. Semantic interpretation using KL-ONE. In Proc. of the 14th Int. Conf. on Computational Linguistics (COLING’94), 1984. [Sowa, 1984] John F. Sowa. Conceptual Structures: Information Processing in Mind and Machine. Addison Wesley Publ. Co., Reading, Massachussetts, 1984.

[Sowa, 1991] John F. Sowa, editor. Principles of Semantic Networks: Explorations in the Representation of Knowledge. Morgan Kaufmann, Los Altos, 1991. [Spackman, 2000] K. A. Spackman. Managing clinical terminology hierarchies using algorithmic calculation of subsumption: Experience with SNOMED-RT. J. of the American Medical Informatics Association, 2000. Fall Symposium Special Issue. [Spackman et al., 1997] K. A. Spackman, K. E. Campbell, and R. A. Cˆot´e. SNOMED-RT: A reference terminology for health care. J. of the American Medical Informatics Association, pages 640–644, 1997. Fall Symposium Special Issue. [Speel et al., 1995] P.-H. Speel, F. van Raalte, P. E. van der Vet, and N. J. I. Mars. Runtime and memory usage performance of Description Logics. In G. Ellis, R. A. Levinson, A. Fall, and V. Dahl, editors, Knowledge Retrieval, Use and Storage for Efﬁciency: Proc. of the 1st Int. KRUSE Symposium, pages 13–27, 1995. [Staab and Maedche, 2000] S. Staab and A. Maedche. Ontology engineering beyond the modeling of concepts and relations. In Proc. of the ECAI’00 workshop on Applications of Ontologies and Problem-solving Methods, 2000. [Stede, 1999] Manfred Stede. Lexical Semantics and Knowledge Representation in Multilingual Text Generation. Kluwer Academic Publishers, 1999. [Steedman, 1996] M. Steedman. Syntactic Structure and Interpretation. Number 30 in Linguistic Inquiry Monographs. The MIT Press, 1996. [Steele, 1990] G. Steele. Common Lisp, The Language. Digital Press, second edition, 1990. [Stickel, 1982] Mark E. Stickel. A nonclausal connection-graph resolution theorem-proving program. In Proc. of the 2nd Nat. Conf. on Artiﬁcial Intelligence (AAAI’82), pages 229–233, 1982. [Stirling, 1996] Colin Stirling. Modal and temporal logics for processes. In Faron Moller and Graham Birtwistle, editors, Logics for Concurrency: Structure versus Automata, volume 1043 of Lecture Notes in Computer Science, pages 149–237. Springer, 1996. [Stock et al., 1991] O. Stock, G. Carenini, F. Cecconi, E. Franconi, A. Lavelli, B. Magnini, F. Pianesi, M. Ponzi, V. Samek-Lodovici, and C. Strapparava. Natural language and exploration of an information space: the AlFresco interactive system. In Proc. of the 12th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’91), pages 972–978, 1991. [Stock et al., 1993] O. Stock, G. Carenini, F. Cecconi, E. Franconi, A. Lavelli, B. Magnini, F. Pianesi, M. Ponzi, V. Samek-Lodovici, and C. Strapparava. AlFresco: Enjoying the combination of natural language processing and hypermedia for information exploration. In Mark T. Maybury, editor, Intelligent Multimedia Interfaces, chapter 9, pages 197–224. The MIT Press, 1993. [Straccia, 1993] Umberto Straccia. Default inheritance reasoning in hybrid KL-ONE-style logics. In Proc. of the 13th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’93), pages 676–681. Morgan Kaufmann, Los Altos, 1993. [Straccia, 1998] Umberto Straccia. A fuzzy Description Logic. In Proc. of the 15th Nat. Conf. on Artiﬁcial Intelligence (AAAI’98), pages 594–599. AAAI Press/The MIT Press, 1998. [Straccia, 2001] Umberto Straccia. Reasoning within fuzzy Description Logics. J. of Artiﬁcial Intelligence Research, 14:137–166, 2001. [Streett, 1982] Robert S. Streett. Propositional Dynamic Logic of looping and converse is elementarily decidable. Information and Control, 54:121–141, 1982. [Streett and Emerson, 1989] Robert S. Streett and E. Allen Emerson. An automata theoretic decision procedure for the propositional µ-calculus. Information and Computation, 81:249–264, 1989.

[Sturm and Wolter, 2002] Holger Sturm and Frank Wolter. A tableau calculus for temporal Description Logic: the expanding domain case. J. of Logic and Computation, 2002. To appear. [Swartout and Gil, 1996] William R. Swartout and Yolanda Gil. EXPECT: A user-centered environment for the development and adaptation of knowledge-based planning aids. In Austin Tate, editor, Advanced Planning Technology: Technological Achievements of the ARPA/Rome Laboratory Planning Initiative, Menlo Park (CA, USA), 1996. AAAI Press/The MIT Press. [Tarski, 1951] Alfred Tarski. A Decision Method for Elementary Algebra and Geometry. University of California Press, Berkeley, 1951. [Tarski, 1955] Alfred Tarski. A lattice-theoretical ﬁxpoint theorem and its applications. Paciﬁc Journal of Mathematics, 5:285–309, 1955. [Teorey, 1989] Toby J. Teorey. Database Modeling and Design: The Entity-Relationship Approach. Morgan Kaufmann, Los Altos, 1989. [Tessaris, 2001] Sergio Tessaris. Questions and Answers: Reasoning and Querying in Description Logic. PhD thesis, University of Manchester, Department of Computer Science, April 2001. [Thalheim, 1992] Bernhard Thalheim. Fundamentals of cardinality constraints. In G. Pernoul and A. M. Tjoa, editors, Proc. of the 11th Int. Conf. on the Entity-Relationship Approach (ER’92), pages 7–23. Springer, 1992. [Thalheim, 1993] Bernhard Thalheim. Fundamentals of the Entity Relationship Model. Springer, 1993. [The Gene Ontology Consortium, 2000] The Gene Ontology Consortium. Gene ontology: Tool for the uniﬁcation of biology. Nature Genetics, 25(1):25–29, 2000. [Tobies, 1999a] Stephan Tobies. A NEXPTIME-complete Description Logic strictly contained in C2. In J. Flum and M. Rodr´ıguez-Artalejo, editors, Proc. of the Annual Conf. of the Eur. Assoc. for Computer Science Logic (CSL’99), volume 1683 of Lecture Notes in Computer Science, pages 292–306. Springer, 1999. [Tobies, 1999b] Stephan Tobies. On the complexity of counting in Description Logics. In Proc. of the 1999 Description Logic Workshop (DL’99), pages 105–109. CEUR Electronic Workshop Proceedings, http://ceur-ws.org/Vol-22/, 1999. [Tobies, 1999c] Stephan Tobies. A PSPACE algorithm for graded modal logic. In H. Ganzinger, editor, Proc. of the 16th Int. Conf. on Automated Deduction (CADE’99), volume 1632 of Lecture Notes in Artiﬁcial Intelligence, pages 52–66. Springer, 1999. [Tobies, 2000] Stephan Tobies. The complexity of reasoning with cardinality restrictions and nominals in expressive Description Logics. J. of Artiﬁcial Intelligence Research, 12:199–217, 2000. [Tobies, 2001a] Stephan Tobies. Complexity Results and Practical Algorithms for Logics in Knowledge Representation. PhD thesis, LuFG Theoretical Computer Science, RWTH-Aachen, Germany, 2001. [Tobies, 2001b] Stephan Tobies. PSPACE reasoning for graded modal logics. J. of Logic and Computation, 11(1):85–106, 2001. [Tou et al., 1982] F. Tou, M. Williams, R. Fikes, A. Henderson, and T. Malone. RABBIT: An intelligent database assistant. In Proc. of the 2nd Nat. Conf. on Artiﬁcial Intelligence (AAAI’82), pages 314–318, 1982. [Touretzky et al., 1987] David S. Touretzky, John F. Horty, and Richmond H. Thomason. A clash of intuitions: the current state of nonmonotonic multiple inheritance systems. In Proc. of the 10th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’87), pages 476–482, 1987.

[Touretzky et al., 1991] David S. Touretzky, Richmond Thomason, and Jeff Horty. A skeptic’s menagerie: Conﬂictors, preemptors, reinstaters, and zombies in nonmonotonic inheritance. In Proc. of the 12th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’91), pages 478–483, 1991. [Tresp and Molitor, 1998] Christopher B. Tresp and Ralf Molitor. A Description Logic for vague knowledge. In Proc. of the 13th Eur. Conf. on Artiﬁcial Intelligence (ECAI’98), pages 361–365, 1998. [Tu et al., 1995] S. Tu, H. Eriksson, J. Gennari, Y. Shahar, and M. Musen. Ontology-based conﬁguration of problem-solving methods and generation of knowledge-acquisition tools: Application of Prot´eg´e-II to protocol-based decision-support. AI Magazine, 7:257–289, 1995. [Tuttle, 1994] M. S. Tuttle. The position of the CANON group: A reality check. J. of the American Medical Informatics Association, 1(3):298–299, 1994. [Ullman, 1988] Jeffrey D. Ullman. Principles of Database and Knowledge Base Systems, volume 1. Computer Science Press, Potomac, Maryland, 1988. [Valiant, 1984] L. G. Valiant. A theory of the learnable. Communications of the ACM, 27(11):1134–1142, 1984. [van Benthem, 1983] Johan van Benthem. Modal Logic and Classical Logic. Bibliopolis, Napoli, 1983. [van Benthem, 1984] Johan van Benthem. Correspondence theory. In D. M. Gabbay and F. Guenthner, editors, Handbook of Philosophical Logic, volume II, pages 167–247. D. Reidel Publishing Company, 1984. [van Benthem, 1996] Johan van Benthem. Temporal logic. In D. Gabbay, C. Hogger, and J. Robinson, editors, Handbook of Logic in Artiﬁcial Intelligence and Logic Programming, Volume 4, pages 241–350. Oxford Scientiﬁc Publishers, 1996. [Van der Hoek, 1992] Wiebe Van der Hoek. On the semantics of graded modalities. J. of Applied Non-Classical Logics, 2(1):81–123, 1992. [Van der Hoek and de Rijke, 1995] Wiebe Van der Hoek and Maarten de Rijke. Counting objects. J. of Logic and Computation, 5(3):325–345, 1995. [van Emde Boas, 1997] Peter van Emde Boas. The convenience of tilings. In A. Sorbi, editor, Complexity, Logic, and Recursion Theory, volume 187 of Lecture Notes in Pure and Applied Mathematics, pages 331–363. Marcel Dekker Inc., 1997. [Vanheijst et al., 1995] G. Vanheijst, S. Falasconi, A. Abuhanna, G. Schreiber, and M. Stefanelli. A case-study in ontology library construction. AI Magazine, 7(3):227–255, 1995. [Vardi, 1982] Moshe Y. Vardi. The complexity of relational query languages. In Proc. of the 14th ACM SIGACT Symp. on Theory of Computing (STOC’82), pages 137–146, 1982. [Vardi, 1985] Moshe Y. Vardi. The taming of converse: Reasoning about two-way computations. In R. Parikh, editor, Proc. of the 4th Workshop on Logics of Programs, volume 193 of Lecture Notes in Computer Science, pages 413–424. Springer, 1985. [Vardi, 1996] Moshe Y. Vardi. An automata-theoretic approach to linear temporal logic. In Faron Moller and Graham Birtwistle, editors, Logics for Concurrency: Structure versus Automata, volume 1043 of Lecture Notes in Computer Science, pages 238–266. Springer, 1996. [Vardi, 1997] Moshe Y. Vardi. Why is modal logic so robustly decidable. In DIMACS Series in Discrete Mathematics and Theoretical Computer Science, volume 31, pages 149–184. American Mathematical Society, 1997. [Vardi, 1998] Moshe Y. Vardi. Reasoning about the past with two-way automata. In Proc. of the 25th Int. Coll. on Automata, Languages and Programming (ICALP’98),

volume 1443 of Lecture Notes in Computer Science, pages 628–641. Springer, 1998. [Vardi and Wolper, 1986] Moshe Y. Vardi and Pierre Wolper. Automata-theoretic techniques for modal logics of programs. J. of Computer and System Sciences, 32:183–221, 1986. A preliminary version appeared in Proc. of the 16th ACM SIGACT Symp. on Theory of Computing (STOC’84). [Veith, 1997] Helmut Veith. Languages represented by boolean formulas. Information Processing Lett., 63:251–256, 1997. [Vilain, 1985] Marc Vilain. The restricted language architecture of a hybrid representation system. In Proc. of the 9th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’85), pages 547–551. Morgan Kaufmann, Los Altos, 1985. [Wahl¨of, 1996] N. Wahl¨of. A default extension to Description Logics and its applications. Master’s thesis, Link¨oping University, Thesis 591, Department of Computer and Information Science, 1996. [Wahlster, 2000] Wolfgang Wahlster, editor. Verbmobil: Foundations of Speech-to-Speech Translation. Springer, 2000. [Wahlster et al., 1993] Wolfgang Wahlster, Elisabeth Andr´e, Wolfgang Finkler, Hans-J¨urgen Proﬁtlich, and Thomas Rist. Plan-based integration of natural language and graphics generation. Artiﬁcial Intelligence, 63(1–2):387–428, 1993. [Weida, 1996] Robert A. Weida. Closed terminologies in Description Logics. In Proc. of the 13th Nat. Conf. on Artiﬁcial Intelligence (AAAI’96), pages 592–599, 1996. [Weida and Litman, 1992] Robert Weida and Diane Litman. Terminological reasoning with constraint networks and an application to plan recognition. In Proc. of the 3rd Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR’92), pages 282–293. Morgan Kaufmann, Los Altos, 1992. [Weischedel, 1989] R. M. Weischedel. A hybrid approach to representation in the Janus natural language processor. In Proc. of the 27th Annual Meeting of the Association for Computational Linguistics (ACL’89), pages 193–202, 1989. [Welty, 1994] Christopher Welty. A knowledge-based email distribution system. In Proc. of the 1994 Florida AI Research Symposium. AAAI Press/The MIT Press, May 1994. [Welty, 1995] Christopher Welty. An Integrated Representation for Software Development and Discovery. PhD thesis, Rensselaer Polytechnic Institute, 1995. [Welty, 1996a] Christopher Welty. An HTML interface for Classic. In Proc. of the 1996 Description Logic Workshop (DL’96), number WS-96-05 in AAAI Technical Report. AAAI Press/The MIT Press, 1996. [Welty, 1996b] Christopher Welty. Intelligent assistance for navigating the web. In Proc. of the 1996 Florida AI Research Symposium. AAAI Press/The MIT Press, May 1996. [Welty, 1997] Christopher Welty. Augmenting abstract syntax trees for program understanding. In Proc. of the 1997 Automated Software Engineering Conf. IEEE Computer Society Press, 1997. [Welty, 1998] Christopher Welty. The ontological nature of subject taxonomies. In Proc. of the Int. Conf. on Formal Ontology in Information Systems (FOIS’98), Frontiers in Artiﬁcial Intelligence. IOS Press, 1998. [Welty and Guarino, 2001] Christopher Welty and Nicola Guarino. Support for ontological analysis of taxonomic relationships. Data and Knowledge Engineering, 39(1):51–74, 2001. [Welty and Jenkins, 2000] Christopher Welty and Jessica Jenkins. Untangle: a new ontology for card catalog systems. In Proc. of the 17th Nat. Conf. on Artiﬁcial Intelligence (AAAI 2000), pages 1137–1138. AAAI Press/The MIT Press, 2000.

[Wermelinger, 1995] Michel Wermelinger. Conceptual graphs and ﬁrst-order logic. In Gerard Ellis, Robert Levinson, William Rich, and John F. Sowa, editors, Proc. of the 3rd Int. Conf. on Conceptual Structures (ICCS’95), volume 954 of Lecture Notes in Artiﬁcial Intelligence, pages 323–337. Springer, 1995. [Wielinga et al., 2001] B. J. Wielinga, A. T. Schreiber, J. Wielemaker, and J. A. C. Sandberg. From thesaurus to ontology. In Proc. of the 1st Int. Conf. on Knowledge Capture (K-CAP 2001). ACM Press and Addison Wesley, 2001. [Wolter, 2000] Frank Wolter. The product of converse PDL and polymodal K. J. of Logic and Computation, 10(2):223–251, 2000. [Wolter and Zakharyaschev, 1998] Frank Wolter and Michael Zakharyaschev. Satisﬁability problem in Description Logics with modal operators. In Proc. of the 6th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR’98), pages 512–523, 1998. [Wolter and Zakharyaschev, 1999a] Frank Wolter and Michael Zakharyaschev. Dynamic Description Logic. In K. Segerberg, M. de Rijke, H. Wansing, and M. Zakharyaschev, editors, Advances in Modal Logic, Volume 2. CSLI Publications, 1999. [Wolter and Zakharyaschev, 1999b] Frank Wolter and Michael Zakharyaschev. Modal Description Logics: Modalizing roles. Fundamenta Informaticae, 39(4):411–438, 1999. [Wolter and Zakharyaschev, 1999c] Frank Wolter and Michael Zakharyaschev. Multi-dimensional Description Logics. In Proc. of the 16th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’99), pages 104–109, 1999. [Wolter and Zakharyaschev, 1999d] Frank Wolter and Michael Zakharyaschev. Temporalizing Description Logic. In D. Gabbay and M. de Rijke, editors, Frontiers of Combining Systems, pages 379–402. Studies Press/Wiley, 1999. [Wolter and Zakharyaschev, 1999e] Frank Wolter and Michael Zakharyaschev. Temporalizing Description Logics. In M. de Rijke and D. Gabbay, editors, Proc. of the 2th Int. Workshop on Frontiers of Combining Systems (FroCoS’98), Amsterdam, 1999. Wiley. [Wood, 1995] Derick Wood. Standard Generalized Markup Language: Mathematical and philosophical issues. In Jan van Leeuwen, editor, Computer Science Today, Recent Trends and Developments, volume 1000 of Lecture Notes in Computer Science, pages 344–365. Springer, 1995. [Woods, 1975] William A. Woods. What’s in a link: Foundations for semantic networks. In D. G. Bobrow and A. M. Collins, editors, Representation and Understanding: Studies in Cognitive Science, pages 35–82. Academic Press, 1975. Republished in [Brachman and Levesque, 1985]. [Woods, 1991] William A. Woods. Understanding subsumption and taxomony: A framework for progress. In J. F. Sowa, editor, Principles of Semantic Networks, pages 45–94. Morgan Kaufmann, Los Altos, 1991. [Woods and Schmolze, 1992] William A. Woods and James G. Schmolze. The KL-ONE family. In F. W. Lehmann, editor, Semantic Networks in Artiﬁcial Intelligence, pages 133–178. Pergamon Press, 1992. Published as a special issue of Computers & Mathematics with Applications, Volume 23, Number 2–9. [Wright et al., 1993] Jon R. Wright, Elia S. Weixelbaum, Gregg T. Vesonder, Karen E. Brown, Stephen R. Palmer, Jay I. Berman, and Harry H. Moore. A knowledge-based conﬁgurator that supports sales, engineering, and manufacturing at AT&T network systems. AI Magazine, 14(3):69–80, 1993. [Wroe et al., 2000] C. Wroe, W. Solomon, A. Rector, and J. Rogers. Inheritance of drug information. J. of the American Medical Informatics Association, 2000. Annual Symposium Special Issue

[Ye et al., 1994] Xian Ye, Christine Parent, and Stefano Spaccapietra. Cardinality consistency of derived objects in DOOD systems. In P. Loucopoulos, editor, Proc. of the 13th Int. Conf. on the Entity-Relationship Approach (ER’94), volume 881 of Lecture Notes in Computer Science, pages 278–295, 1994. Springer. [Yelland, 2000] Philip Y. Yelland. An alternative combination of Bayesian networks and Description Logics. In Proc. of the 7th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2000), pages 225–234, 2000. [Yen, 1991] John Yen. Generalizing term subsumption languages to fuzzy logic. In Ray Reiter and John Myopoulos, editors, Proc. of the 12th Int. Joint Conf. on Artiﬁcial Intelligence (IJCAI’91), pages 472–477, 1991. [Yen et al., 1991a] J. Yen, H.-L. Juang, and R. MacGregor. Using polymorphism to improve expert system maintainability. IEEE Expert, 6(2):48–55, 1991. [Yen et al., 1991b] John Yen, Robert Neches, and Robert MacGregor. CLASP: Integrating term subsumption systems and production systems. IEEE Trans. on Knowledge and Data Engineering, 3(1):25–31, 1991. [Zakharyaschev, 2000] Michael Zakharyaschev. Personal communication, 2000. [Zweigenbaum et al., 1995] P. Zweigenbaum, B. Bachimont, J. Bouaud, and J. Charlet. Issues in the structuring and acquisition of an ontology for medical language understanding. Methods of Information in Medicine, 34(1/2):15–24, 1995.

Index

Symbols

⩾n R.C, ⩽n R.C see qualiﬁed number restriction ⩽n R see at-most restriction ⊥ see bottom concept ∀R.C see value restriction ¬A see atomic negation ¬C see complement of concepts ¬R see complement of roles ¬R see difference of relations ∃R.C see full existential quantiﬁcation ∃R.⊤ see limited existential quantiﬁcation ∃[$i]R see existential quantiﬁcation on relations ⊤ see top concept 2+2-sat 131 2ATA see two-way alternating tree automaton

A see atomic concept C see concept C1 ⊓C2 see intersection of concepts C1 ⇒C2 see trigger rule C1 ≡C2 see equality axiom C1 ≡T C2 see equivalent w.r.t. TBox C1 ⊑C2 see inclusion axiom C1 ⊑T C2 see subsumption C1 ⊔C2 see union of concepts C(a) see concept assertion I see interpretation domain f see feature chain f1 .= f2 see agreement f1 ̸ .= f2 see disagreement id (R) see role identity µX.C see least ﬁxpoint operator νX.C see greatest ﬁxpoint operator P see atomic role P see atomic relation R see role R see relation of arbitrary arity R∗ see reﬂexive–transitive closure of roles R+ see transitive closure of roles R− see inverse role R1 = R2 see equality role-value-map R1 ⊆R2 see containment role-value-map R1 ⊓R2 see intersection of roles R1 ⊓R2 see intersection of relations R1 ◦R2 see composition of roles R1 ≡R2 see equality axiom R1 ⊑R2 see inclusion axiom R1 ⊔R2 see union of roles R1 ⊔R2 see union of relations R|C see role restriction R(a1, a2) see role assertion T |= C1 ≡C2 see equivalent w.r.t. TBox T |= C1 ⊑C2 see subsumption ($i/n: C) see selection on relations ⩾k [$i]R, ⩽k [$i]R see number restriction on relations ⩾ R t l t t i ti

A

ABox 12, 46, 60, 197, 370 absorption 326 acceptable solution 211 accessibility relation 38, 154, 228 between intervals 240 equivalence 231 reﬂexive and transitive 154 transitive 159 transitive, serial, and euclidean 231 universal 234 access to knowledge bases advanced application 270 basic 267 concurrent access 273 data structure 271 notiﬁcation 272 remote access 272 action-guarded fragment 160 acyclic TBox 52, 54, 87, 121 admissible concrete domain 223 advanced application access 270 AE-model 237 agent 154 t 95 217 283

AL 47, 49 complexity with axioms 121 complexity with restricted axioms 122 AL(⊓) complexity 110 ALC 50 complexity 114 ALCB 237 ALC(D) 222 ALCFIreg 187, 196 complexity 193 ALCIOreg 200 ALCIreg 180, 185 complexity 186 ALCK 233 ALCN 50, 78, 85 complexity 115 of ABox consistency 85 of concept satisﬁability 84 w.r.t. general inclusion axioms 87 ALCQI 214 ALCQIreg 193 complexity 197 ALCQOreg 200 ALCreg 155, 180, 185 complexity 186 ALCtrans complexity 117 ALE 49 complexity 107 ALEN 49 complexity 115 AL family 48, 49 AlFresco 454 AL-log 475 ALN 49, 78, 89 complexity with restricted axioms 122 ALU(⊓) complexity 115 AL(⊓) complexity 110 ALNI 210 Alternating Polynomial Space 118 ALU 49 ALUNI 212 AND–OR-graph accessibility 118 approximation 253, 256, 260 arity 467 assertion 46 concept see concept assertion inequality see inequality assertion membership see membership assertion probabilistic see probabilistic assertion role see role assertion AT&T 389, 392, 399 at-least restriction 49 at-most restriction 49 atomic concept 6, 47 negation 47 relation 205 l 6 47

ATP 397 attribute 94, 161, 167, 352 in the ER model 162, 466 in XML see XML attribute partial see partial attribute total see total attribute autoepistemic logic 237 axiom schema instantiation 193

B

Back 103, 296, 300 backjumping 337 backtracking search 337 base interpretation 52 base symbol 51, 90 basic access to knowledge bases 267 basic role 187, 193, 216, 217 Bayesian network 246 BCP see Boolean constraint propagation belief operator 228 Beth’s Deﬁnability Theorem 54 blocking 86, 317, 318, 337, 343 Boolean constraint propagation 336, 340 Boolean operators on roles 91, 92, 152, 194, 207, 469 bottom concept 47 bottom search 329, 330 bottom-up approach 253 branching degree 187 breadth ﬁrst search 329 B¨uchi acceptance condition 188 automaton 89

C

C see complement of concepts C2 75, 92, 93, 151, 215 caching 318, 320, 331, 333, 343 Candide 474 canonical interpretation 82 cardinality constraint 162, 165, 467 Carin 475 CarsDirect 389 CASE tool 161, 166, 172 CCNF see concept-centered normal form CG see conceptual graph characteristic concept 173 Chimaera 274, 448 Ck 151 clash 80, 82, 84 class 161 declaration 167 class-based formalism 36 Classic 105, 221, 266, 291, 313, 395, 401, 428–430, 437, 474 classiﬁcation 14, 286, 310, 323, 328 classiﬁer 286 Clinergy 415, 422 CLIN-S 314 l d ld ti 60 68

CodeBase 379 code-based management system 381 Common Domain Assumption 72 common knowledge 231 complement of concepts 7, 49 of roles 91, 150, 314 complete 82 ABox 80, 82 completeness of algorithm 74, 78, 82 of characterization 77 composition of roles 91, 180, 216 compound concept 212 role 213 computational complexity 10 concept 46, 138 assertion 15, 59 complement see complement of concepts conjunction see intersection of concepts constructor 47 description 47 disjointness see disjointness of concepts disjunction see union of concepts intersection see intersection of concepts language 3 necessary condition 356 negation see complement of concepts partial condition 357 pattern 257 reiﬁed see reiﬁed concept type 144 union see union of concepts variable 257 concept-centered normal form 89, 254 conceptual graph 37, 143 simple see simple conceptual graph conceptual model 350 conceptual modeling 465 concrete domain 34, 222 concurrent access to knowledge bases 273 conﬁguration 24, 266, 275, 388 conformance 173 conjunction of concepts see intersection of concepts of roles see intersection of roles connected model property 184 conp-hardness in FL 101 consistency 66, 85 of knowledge base see knowledge base consistency consistent ABox see consistency set of ABoxes 80 constant domain assumption 229, 237 constraint satisﬁability 337 containment role-value-map 94, 123 converse-dpdl 183, 187 converse-pdl 182, 193 counting quantiﬁer 75, 150 C 299

Cyc 418 cycle see cyclic TBox cyclic TBox 52, 88, 121

D

DAML 408, 427, 432 DAML+OIL 408, 434, 443 DAML-ONT 432, 433 DAML ontology library 448 DARPA Agent Markup Language see DAML data complexity 128 integration 478 mining 27 model object-oriented see object-oriented data model semantic see semantic data model semistructured see semistructured data model structure access 271 inductive and coinductive 201 database 28, 462 Datalog 464, 475, 484 default logic 31, 238 default rule 32, 247 deﬁned concept 52, 286 subconcept 359 deﬁnition 13, 51, 311 necessary see specialization necessary and sufﬁcient see deﬁnition non-primitive see deﬁnition order 330 primitive see specialization deﬁnitorial 52, 53, 54 Dell 389 dependency set 338 description language 47 Description Logic courses 281 descriptive semantics 54, 88, 151, 181 deterministic-converse-pdl see converse-dpdl deterministic program 158 difference of relations 205, 205, 469 Digital Anatomist 408, 417 digital library 26 disagreement 95 discovery software 374, 376 disjoint union model property 195 disjointness of concepts 62 of subconcepts 358 disjunction of concepts see union of concepts of roles see union of roles DLMS 454 Dlp 302, 307 DLR 161, 204, 469 complexity 207 DLRµ 161, 207 DLR 207

F

Document Object Model 174 Document Type Declaration see XML DTD DOM see Document Object Model domain 162, 435, 441 of interpretation see interpretation domain domino problem see tiling problem dpdl 183 DPLL 335 DTD see XML DTD DWQ 473 dynamic backtracking 346

F see agreement, disagreement Fact 166, 301, 307, 341, 436, 448 false positive 376 feature 94, 283, 301, 352 chain 95, 283 ﬁlls 61, 200 FindUR 267, 279, 429 ﬁnite automaton 88 ﬁnite model property 76, 92, 165 reasoning 166, 210 ﬁnite tree 260 ﬁrst-order predicate logic 50 Fischer–Ladner closure 183, 189 ﬁxpoint construct see ﬁxpoint operator in the guarded fragment 160 model 56 mutual see mutual ﬁxpoint operator 88, 135, 155, 172, 173, 201 semantics 54, 156, 172, 204 greatest see greatest ﬁxpoint semantics least see least ﬁxpoint semantics FL complexity 100, 115 FL0 48, 76, 87, 89, 254 FL⊥ 77 FL− 48 FL−(⊓, ◦) complexity 112 FL−(⊓,−) complexity 111 FL−(◦,−) complexity 112 FL−(◦, ⊆) 123 FL−E complexity 110 FL−EN complexity 102 Flex 296 ﬂow of time 239 Ford 390 frame 4, 140, 434 system 2, 37, 140, 283 full existential quantiﬁcation 8, 48 functional approach to Knowledge Representation 12 dependency 165 relation 158 restriction 186 role 94 fuzzy Description Logic 33, 246 logic 246 set 246

E

E see full existential quantiﬁcation edge property see property edge subclass–superclass see subclass–superclass edge element see XML element content see XML element content type see XML element type enhanced traversal 330 entity 162, 466 Entity–Relationship model 161, 463, 466 schema 161,468 epistemic interpretation 72 logic 32, 229 model 73, 234 modeling 371 operator 71, 232, 371 query 235 equality see equality axiom equality axiom 51 equality role-value-map 94, 122 equivalence see equivalent equivalent concepts 48 sets of axioms 51 w.r.t. TBox 62 ER see Entity–Relationship error handling 276 essential property 356 exact cover 107 existential predicate restriction 224 existential quantiﬁcation full see full existential quantiﬁcation limited see limited existential quantiﬁcation on relations 205, 469 expanding domain assumption 229 expansion 53, 65, 66, 310 explanation 274, 276, 396 ExpTime-hardness in AL with axioms 121 in pdl 184 Extensible Markup Language see XML extension function 202 of interpretation 52 t i l k l d 12

G

Galen 308, 326, 406, 407, 413 G 414

general inclusion see inclusion axiom general inclusion axiom 86, see also inclusion axiom generalized terminology 58 Generic Frame Protocol 267 gfp see greatest ﬁxpoint global-as-view 480 graded modality 158, 193 Grail 313, 412, 416, 418–420, 422 graph-based approach 251 greatest ﬁxpoint 56, 202 operator see ﬁxpoint operator semantics 56, 90, 204, 255 guarded fragment 159, 207

of concepts 7, 47 of relations 205, 469 of roles 8, 91, 147, 150, 216 interval-based temporal model see temporal model inverse role 37, 91, 147, 150, 152, 159, 180, 301, 319, 383 IS-A 5, 27, 363, 417, 468 between relationships 165, 468 in the ER model 162, 467

J

Janus 454 Java Theorem Prover 448 Jeroslow–Wang heuristic 356 JTP see Java Theorem Prover

H

H see role hierarchy Harp 337 hierarchy of roles see role hierarchy hook 272 HTML 431, 432 hybrid logic 157 system 19

K

K logic 38, 228 operator 71 K4m 159 KADS 408 Kandor 290 Kee 17, 141 key 163, 362 Kl-One 18, 122, 139, 284, 313 Kl-Two 289 Km 153 knowledge acquisition 278 base 46 consistency 15 viviﬁcation 34, 253 extensional see extensional knowledge intensional see intensional knowledge Kreme 299 K-Rep 221, 300, 411 Kripke frame 159, 230, 233 structure 154, 159, 182 Kris 298, 307, 322 Krss 25, 267, 408, 410 Krypton 288, 313 Ksat 314

I

I see inverse role ICD 410 i•com 166 identity of roles see role identity identity role 152 Imacs 17, 29 incidental property 356 inclusion see inclusion axiom inclusion axiom 14, 51, 311, 420 in terminology 58 individual 138, 353 identiﬁer 353, 354 marker 144 name see nominal value 353 inductive learning 34 inequality assertion 80 inﬁnite tree 187, 260 Information Manifold 483 inheritance 138, 161, 167 by default 139 network 5 instance checking 15, 67, 128 complexity 132 integrity constraint 32, 235, 238 intensional knowledge 12 internalization 117, 150, 153, 184, 186, 208, 312, 313, 320 interpretation 48, 60 canonical see canonical interpretation domain 48 function 48 inter-schema relationship 479 intersection of complex roles 216

L

L2 75, 149, 151 L3 153 language-based approach 251 Lassie 24, 374 lazy unfolding 320, 323 lcs see least common subsumer least common subsumer 34, 252, 254 least ﬁxpoint 56, 202 operator see ﬁxpoint operator semantics 56, 173, 204 legal database state 168 468

less expressive 149 level 81 lfp see least ﬁxpoint Lilog 454 limited existential quantiﬁcation 47 linear inequality 210 Lk 149 local-as-view 480 logical implication 184, 186, 193, 197, 203, 207, 234, 238 w.r.t. ﬁnite models 214 logic of knowledge and belief 31 LogicsWorkbench 314 Login 475 Loom 293, 313, 408, 413, 420

logical form 450, 451, 454 semantic interpretation 450, 451 necessary and sufﬁcient deﬁnition see deﬁnition necessary deﬁnition see specialization negation atomic see atomic negation of concepts see complement of concepts of roles see complement of roles negation normal form 78, 190, 223, 316, 325 negative introspection 229, 233 NeoClassic 271 network-based structure 2, 4 Nikl 135, 289, 313, 407 nominal 60, 157, 200 non-determinism 320 non-deterministic rule 80 non-monotonic consequence relation 235 logic 31, 236, 248 non-primitive 322 non-primitive deﬁnition see deﬁnition non-standard inference 250 normalization 323 notiﬁcation 272 np-hardness in AL with cyclic axioms 122 in AL(⊓) 110 in ALE 109 in ALU 98 in FL−(⊓, ◦) 112 in FL−(⊓,−) 111 in FL−(◦,−) 114 in FL−E 110 in FL−EN 103 number restriction 8, 48, 92, 150, 158, 165 on complex roles 93, 217 on relations, 205 469 qualiﬁed see qualiﬁed number restriction symbolic see symbolic number restriction

M

Maia 454 matcher 257 matching 35, 257 modulo equivalence 257 modulo subsumption 257 materialization 23, 364 medicine 25 medSyndicate 413 membership assertion 15, 59, 197 Meson 221 meta-role 357 MKNF 236 modalized Description Logic 227 modal logic 31, 38, 75, 153, 227 model epistemic see epistemic model ﬁxpoint see ﬁxpoint model of ABox 60 of concept 62 of terminological axioms 51 model checking 69 modeling methodology 369 MOMS heuristic 340 monotone terminology 57 most speciﬁc concept 34, 68, 129, 253, 255 msc see most speciﬁc concept µALCQ 173 µALCQI 201 complexity 203 µ-calculus 88, 153, 155, 201 multi-modal logic 154 mutual ﬁxpoint 203

O

O see nominal object-oriented data model 37, 167 correspondence with Description Logics 169 DBMS 473 schema 167 obvious (non-)subsumption 331 OIL 401, 408, 427, 433, 434 OilEd 445, 448 OKBC 267, 408, 434 oldest-ﬁrst heuristic 341 one-of 60, 129, 147, 150, 152, 157, 200, 436 OntoBuilder 273, 401 OntoEdit 448 Ontolingua 273, 448 ontology 28, 349, 450, 452, 457, 460 open-world assumption see open-world semantics

N

N see number restriction name symbol 51 natural language processing 28, 450 DRT/DRS 459 lexical choice 460 lexical discrimination 451 453

Q

open-world semantics 7, 60, 68, 370 Open Knowledge Base Connectivity see OKBC

Q see qualiﬁed number restriction qualiﬁed number restriction 92, 150, 158, 193, 283, 290, 301, 438 Quantiﬁed Boolean Formulae 114 query answering using views 477, 482 complexity 128 consistency 474, 481 containment 481 epistemic see epistemic query language 464, 474 optimization 476 rewriting 260, 482 Questar 399, 403

P

partial attribute 352 part–whole 417, 23, 366 path tracing 384 pattern see concept pattern PCDATA see XML PCDATA pdl see Propositional Dynamic Logic Pen&Pad 407, 415, 422 Penni 289 planning 27 point-based temporal model see temporal model positive introspection 229, 233 possible worlds semantics 228, 233 Post correspondence problem 127 Pracma 454 precision 429 predicate logic 149 preferential Description Logic 459 primitive concept 52 deﬁnition see specialization subconcept 359 probabilistic assertion 245 Description Logic 33, 243 terminological axiom 243 procedural extension 70 rule see trigger rule Prodigy 414, 415 program 155, 182 deterministic see deterministic program projection 146 property edge 138 Propositional Dynamic Logic 75, 117, 155, 182 complexity 184 converse-dpdl see converse-dpdl converse-pdl see converse-pdl correspondence with Description Logics 185 dpdl see dpdl Fischer–Ladner closure see Fischer–Ladner closure internalization of axioms 184 logical implication 184 program see program satisﬁability 184 with graded modality see graded modality propositional µ-calculus see µ-calculus propositional reasoning 318 Prose 17, 392, 393, 399, 401, 403 Prot´eg´e 408, 414, 445, 448 pruning 277 PSpace-hardness in ALC 115 in ALEN 115 in ALN(⊓) 106 in AL with cyclic axioms 122 in FL 116

R

Racer 302, 307, 346, 436 range 435, 441 RDF 433, 442 RDFS 433, 435, 442 RDF Schema see RDFS realization 15, 68, 129, 287 realizer 286 recall 429 referent 145 reﬂexive–transitive closure of roles 117, 180 regular expression over roles 117, 155, 180, 309 reiﬁcation 164, 166, 194, 362 of relations 206 reiﬁed concept 357 reiﬁed counterpart 194, 206 relation difference see difference of relations intersection see intersection of relations of arbitrary arity 159, 163, 166, 204, 469 selection see selection on relations type 144 union see union of relations well-typed see well-typed relation relational data model 463 relationship in the ER model 162, 466 reiﬁed see reiﬁcation relationship role 358, 363 remote access to knowledge bases 272 Resource Description Framework see RDF retrieval 15, 67 rewriting concepts 35, 260 queries see query rewriting rewriting system 124 rigid term assumption 72 role 46 agreement see agreement assertion 15, 59 atomic see atomic role basic see basic role Boolean operators see Boolean operators on roles

role (cont.) chain 94, 95, 217 closure 32 complement see complement of roles composition see composition of roles conjunction see intersection of roles constructor 91 depth 82 description 91 disagreement see disagreement disjunction see union of roles ﬁller 8 functional see functional role hierarchy 283, 301, 363, 419 identity 117, 180, 314 inclusion axiom 51, 207 intersection see intersection of roles inverse see inverse role in the ER model 162, 466 meta see meta-role negation see complement of roles reﬂexive–transitive closure see reﬂexive–transitive closure of roles restriction 100 transitive see transitive role transitive closure see transitive closure of roles union see union of roles universal see universal role role-value-map 94, 122, 153, 217 containment see containment role-value-map equality see equality role-value-map rule 295, 394, 395 ABox 236 default see default rule knowledge base 71 procedural see trigger rule trigger see trigger rule

semistructured data 172, 473 semistructured data model 172 SEP les 419 SEP-triples 419 Set splitting 103 SG see simple conceptual graph SGML 431 SHIQ 208, 301, 433, 436, 446 SHIQ(D) 436, 445 SHOE 430 SHOQ(D) 447 simple conceptual graph 143, 144 simpliﬁcation 323, 325, 336 simulating existentials with role chain and inverse 112 with role conjunction 106 simulation 173 slot 434 constraint 434 Snomed 25, 406, 408, 410, 416 software engineering 23, 373 information system 374 maintenance 373 soundness of algorithm 74, 81 of characterization 77 Spass 314 specialization 58, 212, 311 SQL 464 state 154 structural subsumption 9 subsumption algorithm 9, 74, 76, 251, 313 structured document 174 inheritance network 44, 139 object 208 subclass–superclass edge 138 subsume see subsumption subsumption 9, 62, 84, 384 subtype–supertype relationships 161 support 144 symbolic name 51 number restriction 94 syntactic branching 334 simpliﬁcation 323 syntactically monotone 202 terminology 58

S

S4 154 same-as 95 SAT 335 *Sat 314 satisﬁability 9, 62, 83, 84, 184, 186, 193, 197, 203 w.r.t. ﬁnite models 214 satisﬁable see satisﬁability Sb-One 299 selection on relations 205, 469 semantic branching 335 semantic data model 37, 161 correspondence with Description Logics 163 semantic network 2, 4, 138, 283 semantics 48, 50 closed-world see closed-world semantics descriptive see descriptive semantics ﬁxpoint see ﬁxpoint semantics greatest ﬁxpoint see greatest ﬁxpoint semantics least ﬁxpoint see least ﬁxpoint semantics of rule 236 of trigger rule 70 open-world see open-world semantics possible worlds see possible worlds semantics

T

tableau-based algorithm 74, 78 tag see XML tag Tambis 422 TBox 12, 46, 51 acyclic see acyclic TBox cyclic see cyclic TBox

Tell&Ask 12 temporal description logic 239 logic 33, 156, 239 model 239 operator 228, 240 termination 81 terminological axiom 51 default 248 default theory 248 system 3 terminology 5, 51 generalized see generalized terminology monotone see monotone terminology syntactically monotone see syntactically monotone terminology thrashing 337 tiling problem 216, 217 told subsumer 329 top concept 47 top-down approach 253 top search 329, 331 total attribute 352 trace 109 technique 318 transformation rule 80 transitive closure of roles 91, 117, 159 role 159, 208, 283, 435 tree automaton on ﬁnite trees 260 on inﬁnite trees 187, 260 two-way alternating see two-way alternating tree automaton tree model property 83, 187, 209 trigger rule 32, 70, 140, 232, 412 Trilogy 389 two-variable fragment see L2 two-way alternating tree automaton 188 typing 167

with number restrictions on complex roles 217 unfoldable knowledge base 311 unfolding see expansion uniﬁcation 35, 256 Uniﬁed Medical Language System 410 Uniﬁed Modeling Language see UML uniﬁer 257 union of concepts 7, 48 of relations 205, 469 of roles 91, 150, 180 unique name assumption 60, 80, 147, 157, 197, 437 universal concept see top concept quantiﬁcation over roles see value restriction role 153, 186, 208, 312 Untangle 428

V

vagueness 243 value restriction 7, 8, 47 varying domain assumption 229 Verbmobil 454 VerticalNet 401 view 369, 472, 477 viviﬁcation see knowledge base viviﬁcation

W

web-based information system 26 well-founded 156, 176, 204, 208 well-typed relation 205 word problem 127, 128 world 154 description see ABox view 479 wrapper 480

X

XCON 389 XML 172, 174, 431, 432, 441, 474 attribute 174 DTD 175 element 174 element content 175 element type 175 PCDATA 175 Schema 447 tag 174 XOL 434 Xtra 454

U

U see union of concepts UML 171 UMLS see Uniﬁed Medical Language System UNA see unique name assumption uncertainty 243 undecidability 94, 122, 215 in FL−(◦, ⊆) 125 in FL−(◦, =) 127 with intersection of complex roles 216